# Avatar Studio — Technical Overview (v2.7)

This workspace is a standalone, static HTML/CSS/JS avatar composer.
It loads a trait registry (`traits.json`), layers 128×128 PNGs onto a canvas, and exports a 512×512 PNG **only after mint/lock**.

## Quick Start

- Windows: run `RUN-WINDOWS.bat`
- Mac/Linux: run `./run.sh`
- Open:
  - Studio: `http://127.0.0.1:8080/index.html`
  - Placement Lab (QA): `http://127.0.0.1:8080/placement-lab.html`

The server is intentionally `no-store` so you can iterate without browser caching issues.

## High-Level Architecture

**Inputs**
- `traits.json`: registry of all traits (categories → items)
- `assets/traits/**`: PNG layers referenced by `traits.json`
- `localStorage`: saved draft selection + nickname; mint record when locked

**Core flow**
1. Load `traits.json` into memory (`traitDB`).
2. Load previous state:
   - If a mint record exists, it wins and the UI becomes read-only.
   - Else, restore draft selection + nickname from localStorage.
3. Build UI (tabs + grid) from `traitDB`.
4. Render preview:
   - Compose a 128×128 base canvas by drawing each selected layer in `DRAW_ORDER`.
   - Draw the composed base canvas into the UI preview canvas (scaled up).
5. Update metadata panel (DNA, hash, JSON).
6. If minted, allow `Export PNG`; mint action auto-downloads once.

**Important constraint**
- “Disable saving” is a best-effort deterrent in the browser. Screenshots/DevTools can’t be fully blocked.

## Trait System

### `traits.json` format
Top-level keys are **categories**. Each category is a list of **traits**:

- `id`: stable identifier (used in selection + DNA)
- `name`: UI label
- `file`: relative path to the PNG
- `rarity`: currently informational (used for styling)

Example:

```json
{
  "hair": [
    { "id": "none", "name": "None", "file": "assets/traits/hair/hair_none.png", "rarity": "common" },
    { "id": "messy_black", "name": "Messy · Black", "file": "assets/traits/hair/hair_messy_black.png", "rarity": "common" }
  ]
}
```

### Category order vs draw order
The project distinguishes between:

- **UI/DNA order**: `CAT_ORDER` in `app.js`
- **Render stacking order**: `DRAW_ORDER` in `app.js`

`DRAW_ORDER` determines what appears on top of what.

### “None-first” behavior
On load, each category list is normalized so any `id === "none"` entry (if present) is moved to index 0.
That makes “None” the first choice wherever it exists.

## Rendering Pipeline (Studio)

Rendering happens in `renderAvatar(selection)` in `app.js`.

### Base dimensions
- Traits are drawn into a 128×128 offscreen canvas.
- The preview UI canvas is larger but uses pixelated scaling.
- Export is generated by drawing the 128×128 composite to a 512×512 export canvas.

### Layer drawing
For each category in `DRAW_ORDER`:

1. Resolve the chosen trait object from `traitDB` (`getTrait`).
2. Compute offsets:
   - `BASE_OFFSET[cat]` + `extraOffset(cat, id)` → `offsetFor(cat, id)`.
3. Load the image with `loadImage(file)` (cached).
4. Draw it onto the base canvas.

### Special cases
- **Hands**: auto-drawn pixel hands (and optionally glove color) are inserted *between* accessory/effect layers.
- **Mouth overlay (cigar/cigarette)**: drawn after accessories using an offscreen canvas + `destination-out` to remove baked mouth pixels.
- **Per-trait scaling**: some traits are scaled/cropped during draw (e.g. spiky hair scaling, space helmet scaling, analyzer eyewear).

### Ponytail “behind head” split
Ponytail hair assets are single PNGs, but the vertical ponytail block needs to render behind the head.
The studio implements a ponytail-only two-pass draw:

1. **Before head is drawn**: clip to `PONYTAIL_BEHIND_HEAD_MASKS` and draw ponytail into the base canvas.
2. **At the normal hair layer**: draw ponytail into an offscreen canvas and punch out the same masked region (so the behind-head pixels don’t double-render in front).

This is implemented using canvas compositing (`destination-out`) and a small union-of-rectangles mask.

## State, Minting, and Metadata

### LocalStorage keys
Versioned keys (via `data-version` on `<html>`) isolate state between versions:

- `avatar_studio_selection_${VERSION}`: draft selection + UI state
- `avatar_studio_nick_${VERSION}`: draft nickname
- `avatar_studio_mint_${VERSION}`: mint record (hard lock)

### Mint lock model
- “Mint (lock)” writes a mint record to localStorage and flips the app into read-only mode.
- Mint record includes `dna`, `hash`, `mintedAt`, `selection`, `nickname`.
- This is **client-side** locking. True immutability requires minting on-chain.

### DNA + hash
- DNA is a compact string encoding of the current selection (category shortcodes).
- Hash is `SHA-256(dna)`.

### Export gating
- Export is disabled until minted.
- Mint triggers a best-effort auto-download of the PNG.

### Metadata JSON
- “Mint & Metadata” panel shows the tokenURI-style JSON:
  - `name`, `description`, `image` placeholder, `external_url`
  - `dna`, `hash`, `minted` boolean
  - `attributes` including Nickname (if set)

## UI + Styling

### `index.html`
Defines the app layout:
- Header brand + status chips
- Toolbar actions (Randomize, Roll tab, Export PNG, Mint)
- Help pill tooltip (“How does your avatar NFT work?”)
- Preview panel (canvas + DNA/Hash/Nickname)
- Traits panel (tabs, search, grid)
- Metadata panel (collapsible)

### `styles.css`
- Implements the visual design (tokens, panels, grid, buttons, tooltip).
- Includes small “anti-save” CSS hints for images/canvas (best-effort).

### Anti-save deterrent
The studio also attaches event listeners to block right-click/drag on images/canvas where possible.

## Placement Lab (QA Tool)

`placement-lab.html` is a separate page with its own inline renderer.
It exists to quickly scan a category and visually compare how each trait sits on a fixed reference avatar.

Important notes:
- It does **not** import `app.js`; renderer logic is duplicated.
- When the studio renderer changes (offsets, scaling, ponytail split), Placement Lab may need a matching update.

## Tooling

### `tools/verify_assets.py`
Offline validator for trait registry correctness:
- Ensures all `traits.json` file paths exist
- Checks duplicate IDs per category
- Reads PNG IHDR to warn on non-128×128 assets

Run:

- `python .\tools\verify_assets.py`

Warnings are allowed for known exceptions where the renderer scales the asset.

## File-by-File Overview

### Root
- `index.html` — main studio UI and DOM structure.
- `styles.css` — styling for the studio UI.
- `app.js` — core logic: trait loading, state, rendering, mint/export, metadata, UI events.
- `traits.json` — registry of all traits and their asset file paths.
- `placement-lab.html` — QA tool for placement/offset tuning (separate renderer).
- `run.py` — local dev server with no-cache headers.
- `RUN-WINDOWS.bat` — Windows launcher for `run.py`.
- `run.sh` — Mac/Linux launcher for `run.py`.
- `README.txt` — quick run instructions + notes.
- `AVATAR-STUDIO-NOTES-v2.7.txt` — changelog/notes for v2.7.
- `avatar_studio_nickname_VS.patch` / `arcade_ui_nickname_VS.patch` — patch artifacts (not executed by the studio).

### Assets
- `assets/traits/**` — category folders of 128×128 PNG layers.

### Tools
- `tools/verify_assets.py` — asset + registry validator.

## Extension Points / Common Changes

- Add a trait: drop PNG into `assets/traits/<category>/`, then add an entry in `traits.json`.
- Change draw order: update `DRAW_ORDER` in `app.js` (be careful: affects all layers).
- Tune placement: update `BASE_OFFSET` / `extraOffset` in `app.js`.
- Add a special-case render rule: extend the per-trait blocks inside `renderAvatar()`.
- Keep Placement Lab aligned: mirror any renderer changes if you depend on it for QA.
