<!DOCTYPE html>
<html lang="en" data-ui-version="2.8" data-game-id="moonshot">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script>
    (function () {
      try {
        if (window.top === window.self) window.location.replace('/');
      } catch (_) {
        // If framing info is restricted, do nothing.
      }
    })();
  </script>
  <title>Moonshot · ArcadeBridge · v2.8</title>
  <!-- built by gruesøme -->
  <!-- SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f -->
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@200;400;600;700;800;900&display=swap" rel="stylesheet" />
  <style>
    :root{
      color-scheme: dark;
      --bg0: #020617;
      --panel: rgba(15, 23, 42, 0.78);
      --border: rgba(255,255,255,0.10);
      --muted: rgba(229,231,235,0.70);
      --text: rgba(229,231,235,0.96);
      --cyan: #22d3ee;
      --cyan2: rgba(34,211,238,0.22);
      --shadow: 0 24px 70px rgba(0,0,0,0.85);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #020617 0%, #020617 40%, #000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Barlow', sans-serif;
      color: var(--text);
    }

    #root { position: fixed; inset: 0; }
    #canvas { width: 100%; height: 100%; display: block; background: #000; }

    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      display: flex;
      gap: 10px;
      z-index: 5;
      pointer-events: none;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(2, 6, 23, 0.62);
      border: 1px solid var(--border);
      box-shadow: 0 18px 40px rgba(0,0,0,0.60);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size: 12px;
      letter-spacing: 0.02em;
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--cyan);
      box-shadow: 0 0 12px rgba(34,211,238,0.55);
    }
    .mono { font-family: var(--mono); opacity: 0.88; }

    .pop { animation: pop 240ms ease-out; }
    @keyframes pop { 0%{ transform: scale(1); } 55%{ transform: scale(1.06); } 100%{ transform: scale(1); } }

    #toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%) translateY(10px);
      opacity: 0;
      z-index: 20;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(34,211,238,0.25);
      background: rgba(2, 6, 23, 0.78);
      box-shadow: 0 18px 45px rgba(0,0,0,0.80);
      transition: opacity 140ms ease-out, transform 140ms ease-out;
    }
    #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: linear-gradient(180deg, rgba(2,6,23,0.18) 0%, rgba(0,0,0,0.78) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .card {
      width: min(860px, calc(100% - 26px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(2, 6, 23, 0.82);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .row { display: flex; align-items: baseline; justify-content: space-between; gap: 10px; }
    .title { font-size: 14px; font-weight: 900; letter-spacing: 0.14em; text-transform: uppercase; }
    .subtitle { margin-top: 10px; font-size: 12px; color: var(--muted); line-height: 1.4; }
    .grid { margin-top: 14px; display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
    @media (max-width: 720px) { .grid { grid-template-columns: 1fr; } }
    .panel {
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.55);
      padding: 12px;
    }
    .panel h3 { margin: 0 0 6px; font-size: 12px; letter-spacing: 0.08em; text-transform: uppercase; }
    .hint { font-size: 11px; color: rgba(229,231,235,0.64); line-height: 1.4; min-height: 1.2em; }
    .kpi { margin-top: 10px; display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
    .k { border: 1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 10px; background: rgba(2, 6, 23, 0.55); }
    .l { font-size: 10px; color: rgba(229,231,235,0.55); letter-spacing: 0.10em; text-transform: uppercase; }
    .v { margin-top: 4px; font-size: 12px; font-weight: 700; }
    .btnrow { margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; }
    .btn {
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(229,231,235,0.92);
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      padding: 10px 14px;
    }
    .btn.primary { border-color: rgba(34,211,238,0.30); background: rgba(34,211,238,0.14); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    #standaloneGate {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      background: radial-gradient(circle at top, rgba(2,6,23,0.92) 0%, rgba(0,0,0,0.96) 100%);
    }
    #standaloneGate.show { display: flex; }
    .sgCard { width: min(520px, calc(100% - 26px)); border-radius: 18px; border: 1px solid rgba(255,255,255,0.12); background: rgba(2, 6, 23, 0.82); box-shadow: var(--shadow); padding: 16px; text-align: center; }
    .sgTitle { font-size: 12px; font-weight: 900; letter-spacing: 0.14em; text-transform: uppercase; }
    .sgBody { margin-top: 10px; font-size: 12px; color: rgba(229,231,235,0.72); line-height: 1.45; }
  </style>
</head>
<body>
  <div id="standaloneGate" aria-label="Dashboard required" role="dialog" aria-modal="true">
    <div class="sgCard">
      <div class="sgTitle">Dashboard required</div>
      <div class="sgBody">Moonshot is embed-only. Open the <strong>Arcade Dashboard</strong> and launch the game from there.</div>
    </div>
  </div>

  <div id="root">
    <canvas id="canvas"></canvas>

    <div class="hud" aria-hidden="true">
      <div class="chip"><span class="dot"></span><b>Moonshot</b><span class="mono" id="hudScore">Score 0</span></div>
      <div class="chip"><span class="mono" id="hudRun">Run --</span><span class="mono" id="hudBest">Best 0</span></div>
    </div>

    <div id="toast"></div>

    <div class="overlay" id="overlay">
      <div class="card">
        <div class="row">
          <div class="title">Moonshot</div>
          <div class="title" style="opacity:0.75">ArcadeBridge v0.3</div>
        </div>
        <div class="subtitle" id="subText">
          Launch from the dashboard. Start a run to spend Credits. Promo runs are not payout-eligible.
        </div>

        <div class="grid">
          <div class="panel">
            <h3>Controls</h3>
            <div class="hint">Tap / Click / Space to thrust. Avoid debris. Score = gates passed.</div>
            <div class="kpi">
              <div class="k"><div class="l">Run cost</div><div class="v" id="kRunCost">10 Credits</div></div>
              <div class="k"><div class="l">Promo runs</div><div class="v" id="kPromo">5</div></div>
              <div class="k"><div class="l">Status</div><div class="v" id="kStatus">Ready</div></div>
            </div>

            <div class="btnrow">
              <button class="btn primary" id="btnStart">Start Run</button>
              <button class="btn" id="btnPromo">Claim Promo (Tx)</button>
            </div>
            <div class="hint" id="hintLine">Tip: Promo claim is a gas-paid transaction in the final build.</div>
          </div>

          <div class="panel">
            <h3>Session</h3>
            <div class="hint" id="sessionLine">Syncing with dashboard…</div>
            <div class="kpi">
              <div class="k"><div class="l">Paid Credits</div><div class="v" id="kPaid">0</div></div>
              <div class="k"><div class="l">Promo Credits</div><div class="v" id="kPromoBal">0</div></div>
              <div class="k"><div class="l">Run type</div><div class="v" id="kRunType">--</div></div>
            </div>
            <div class="hint" id="resultLine"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // built by gruesøme
    // SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f
    (function() {
      'use strict';

      const GAME_ID = 'moonshot';
      const VERSION = '2.7';

      const EMBEDDED = (window.parent && window.parent !== window);
      const standaloneGate = document.getElementById('standaloneGate');
      if (!EMBEDDED) {
        standaloneGate && standaloneGate.classList.add('show');
        // No game boot when standalone.
        return;
      }

      // Bridge + state
      const bridge = {
        post(type, payload) {
          try { window.parent.postMessage(Object.assign({ type }, payload || {}), '*'); } catch (e) {}
        }
      };

      const st = {
        runCostAC: 10,
        promoRuns: 5,
        promoGrantAC: 50,
        promoClaimed: false,
        paidAC: 0,
        promoAC: 0,
        best: 0,
        lastRunType: '--',
        address: '',
      };
      let lastBestShown = 0;

      let activeGrant = null; // { runId, runType, costAC, grantedAt }
      let running = false;
      let gameover = false;

      // UI refs
      const UI = {
        hudScore: document.getElementById('hudScore'),
        hudRun: document.getElementById('hudRun'),
        hudBest: document.getElementById('hudBest'),
        overlay: document.getElementById('overlay'),
        btnStart: document.getElementById('btnStart'),
        btnPromo: document.getElementById('btnPromo'),
        kRunCost: document.getElementById('kRunCost'),
        kPromo: document.getElementById('kPromo'),
        kStatus: document.getElementById('kStatus'),
        kPaid: document.getElementById('kPaid'),
        kPromoBal: document.getElementById('kPromoBal'),
        kRunType: document.getElementById('kRunType'),
        sessionLine: document.getElementById('sessionLine'),
        resultLine: document.getElementById('resultLine'),
        toast: document.getElementById('toast'),
      };

      function toast(msg) {
        try {
          UI.toast.textContent = msg;
          UI.toast.classList.add('show');
          clearTimeout(toast._t);
          toast._t = setTimeout(()=>UI.toast.classList.remove('show'), 1800);
        } catch(e){}
      }

      function fmt(n) { return (Number.isFinite(n) ? Math.floor(n) : 0).toString(); }

      function renderSession() {
        UI.kRunCost.textContent = fmt(st.runCostAC) + ' Credits';
        UI.kPromo.textContent = fmt(st.promoRuns);
        UI.kPaid.textContent = fmt(st.paidAC);
        UI.kPromoBal.textContent = fmt(st.promoAC);
        const newBest = Number(st.best||0);
        UI.hudBest.textContent = 'Best ' + fmt(newBest);
        if (newBest > lastBestShown) {
          lastBestShown = newBest;
          try { UI.hudBest.classList.remove('pop'); void UI.hudBest.offsetWidth; UI.hudBest.classList.add('pop'); } catch {}
        }
        UI.kRunType.textContent = st.lastRunType || '--';
        UI.hudRun.textContent = 'Run ' + (st.lastRunType || '--');
        UI.btnPromo.disabled = !!st.promoClaimed;
        UI.btnPromo.textContent = st.promoClaimed ? 'Promo Claimed' : 'Claim Promo (Tx)';
        UI.sessionLine.textContent = st.address ? ('Connected as ' + st.address.slice(0,6) + '…' + st.address.slice(-4)) : 'Syncing with dashboard…';
      }

      // Game: simple rocket dodge (flappy-style)
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { alpha: false });

      let W = 800, H = 600, DPR = 1;
      function resize() {
        DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        W = Math.floor(window.innerWidth);
        H = Math.floor(window.innerHeight);
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }
      window.addEventListener('resize', resize, { passive: true });
      resize();

      const stars = [];
      const trail = [];
      function initStars() {
        stars.length = 0;
        const count = Math.floor((W * H) / 9000);
        for (let i=0;i<count;i++) {
          stars.push({
            x: Math.random()*W,
            y: Math.random()*H,
            r: Math.random()*1.6 + 0.2,
            a: Math.random()*0.7 + 0.2,
            v: Math.random()*0.6 + 0.15,
          });
        }
      }
      initStars();

      const rocket = { x: 110, y: 0, vy: 0, r: 14 };
      const pipes = [];
      let score = 0;
      trail.length = 0;
      let lastT = 0;
      let spawnT = 0;
      let runStart = 0;

      function resetRun() {
        rocket.x = Math.min(130, W*0.22);
        rocket.y = H*0.5;
        rocket.vy = 0;
        pipes.length = 0;
        score = 0;
        trail.length = 0;
        lastT = 0;
        spawnT = 0;
        runStart = performance.now();
        UI.hudScore.textContent = 'Score 0';
        UI.resultLine.textContent = '';
        gameover = false;
      }

      function spawnPipe() {
        const gapH = Math.max(150, Math.min(220, H*0.28));
        const pad = 60;
        const gapY = pad + Math.random()*(H - pad*2 - gapH);
        const w = Math.max(56, Math.min(74, W*0.08));
        pipes.push({
          x: W + w + 10,
          w,
          gapY,
          gapH,
          passed: false
        });
      }

      function drawBG(dt) {
        // Gradient backdrop
        const g = ctx.createLinearGradient(0,0,0,H);
        g.addColorStop(0, '#030b1e');
        g.addColorStop(1, '#000000');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);

        // Nebula haze (subtle depth)
        const tt = performance.now() * 0.00008;
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        for (let i=0;i<3;i++) {
          const cx = W * (0.15 + 0.7 * (0.5 + 0.5*Math.sin(tt + i*1.7)));
          const cy = H * (0.15 + 0.7 * (0.5 + 0.5*Math.cos(tt*0.9 + i*2.1)));
          const r = Math.max(W,H) * (0.35 + i*0.08);
          const gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
          gg.addColorStop(0, 'rgba(88, 101, 242, 0.12)');
          gg.addColorStop(0.55, 'rgba(34, 211, 238, 0.06)');
          gg.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = gg;
          ctx.fillRect(0,0,W,H);
        }
        ctx.restore();

        // Stars
        const t = performance.now();
        for (const s of stars) {
          s.y += s.v * dt * 0.06;
          if (s.y > H + 10) { s.y = -10; s.x = Math.random()*W; }
          ctx.globalAlpha = s.a;
          ctx.fillStyle = '#e5e7eb';
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
          ctx.fill();
        }

        // Trail particles
        const nowT = performance.now();
        for (let i = trail.length - 1; i >= 0; i--) {
          const p = trail[i];
          const age = nowT - p.t;
          if (age > p.life) { trail.splice(i,1); continue; }
          const k = 1 - age / p.life;
          ctx.globalAlpha = 0.10 + 0.28 * k;
          ctx.fillStyle = 'rgba(34,211,238,' + (0.20 + 0.55*k) + ')';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r * (0.6 + 0.9*k), 0, Math.PI*2);
          ctx.fill();
        }

        // Vignette
        const vg = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.18, W/2, H/2, Math.max(W,H)*0.78);
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = vg;
        ctx.globalAlpha = 1;
        ctx.fillRect(0,0,W,H);

        ctx.globalAlpha = 1;
      }

      function drawPipe(p) {
        const x = p.x;
        const topH = p.gapY;
        const botY = p.gapY + p.gapH;
        const botH = H - botY;

        // Body
        ctx.fillStyle = 'rgba(34,211,238,0.11)';
        ctx.strokeStyle = 'rgba(34,211,238,0.22)';
        ctx.lineWidth = 2;

        // Top
        roundRect(x, 0, p.w, topH, 12);
        ctx.fill();
        ctx.stroke();

        // Bottom
        roundRect(x, botY, p.w, botH, 12);
        ctx.fill();
        ctx.stroke();
      }

      function roundRect(x,y,w,h,r) {
        const rr = Math.min(r, w*0.5, h*0.5);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      function drawRocket() {
        const x = rocket.x, y = rocket.y;
        // Glow
        ctx.save();
        ctx.shadowColor = 'rgba(34,211,238,0.35)';
        ctx.shadowBlur = 18;
        ctx.fillStyle = 'rgba(34,211,238,0.18)';
        ctx.beginPath();
        ctx.arc(x, y, rocket.r + 7, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // Body
        ctx.fillStyle = 'rgba(229,231,235,0.92)';
        ctx.strokeStyle = 'rgba(255,255,255,0.10)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(x, y, rocket.r*0.9, rocket.r*0.75, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        // Window
        ctx.fillStyle = 'rgba(34,211,238,0.88)';
        ctx.beginPath();
        ctx.arc(x + 6, y - 3, 4.2, 0, Math.PI*2);
        ctx.fill();

        // Flame
        const flame = Math.max(0, Math.min(1, (-rocket.vy + 4)/10));
        ctx.fillStyle = 'rgba(255,221,85,' + (0.35 + flame*0.45) + ')';
        ctx.beginPath();
        ctx.moveTo(x - rocket.r, y);
        ctx.quadraticCurveTo(x - rocket.r - (10 + 10*flame), y - 6, x - rocket.r - 2, y - 3);
        ctx.quadraticCurveTo(x - rocket.r - (10 + 10*flame), y + 6, x - rocket.r, y);
        ctx.closePath();
        ctx.fill();
      }

      function collide(p) {
        const rx = rocket.x, ry = rocket.y, rr = rocket.r*0.88;
        if (ry - rr <= 0 || ry + rr >= H) return true;

        const withinX = (rx + rr > p.x) && (rx - rr < p.x + p.w);
        if (!withinX) return false;

        const inGap = (ry - rr > p.gapY) && (ry + rr < p.gapY + p.gapH);
        return !inGap;
      }

      function tick(ts) {
        if (!running) return;
        if (!lastT) lastT = ts;
        const dt = Math.min(32, ts - lastT);
        lastT = ts;

        drawBG(dt);

        // Physics
        const gravity = 0.00185 * H; // scale with viewport
        rocket.vy += gravity * (dt/1000);
        rocket.y += rocket.vy * (dt/16.67);

        // Emit trail (visual-only)
        trail.push({ x: rocket.x - rocket.r - 2, y: rocket.y + (Math.random()*6-3), r: 1.6 + Math.random()*2.2, t: performance.now(), life: 520 });
        if (trail.length > 160) trail.splice(0, trail.length - 160);

        // Spawn
        spawnT += dt;
        const spawnEvery = 1400;
        if (spawnT >= spawnEvery) {
          spawnT -= spawnEvery;
          spawnPipe();
        }

        // Move pipes
        const speed = Math.max(2.6, Math.min(4.4, W/260));
        for (const p of pipes) {
          p.x -= speed * (dt/16.67);
          if (!p.passed && p.x + p.w < rocket.x - 2) {
            p.passed = true;
            score += 1;
            UI.hudScore.textContent = 'Score ' + score;
            try { UI.hudScore.classList.remove('pop'); void UI.hudScore.offsetWidth; UI.hudScore.classList.add('pop'); } catch {}
          }
        }

        // Cull
        while (pipes.length && pipes[0].x + pipes[0].w < -30) pipes.shift();

        // Draw pipes
        for (const p of pipes) drawPipe(p);
        drawRocket();

        // Collisions
        for (const p of pipes) {
          if (collide(p)) {
            endRun('collision');
            return;
          }
        }

        requestAnimationFrame(tick);
      }

      function endRun(reason) {
        if (!running) return;
        running = false;
        gameover = true;

        UI.kStatus.textContent = 'Complete';
        UI.btnStart.disabled = false;
        UI.btnStart.textContent = 'Start Next Run';
        UI.overlay.style.display = 'flex';
        UI.resultLine.textContent = 'Last run: ' + score + ' · ' + (st.lastRunType || '--') + ' · ' + reason;

        const durationMs = Math.max(0, performance.now() - runStart);

        // Report result
        if (activeGrant && activeGrant.runId) {
          bridge.post('ARCADE:RUN_RESULT', {
            gameId: GAME_ID,
            runId: activeGrant.runId,
            score: score,
            durationMs: Math.floor(durationMs),
            clientVersion: VERSION
          });
        }
        activeGrant = null;
      }

      function onThrust() {
        if (!running) return;
        rocket.vy = Math.max(rocket.vy - 7.5, -14.5);
      }

      // Input
      window.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onThrust(); }, { passive:false });
      window.addEventListener('keydown', (e)=>{
        const k = e.key;
        if (k === ' ' || k === 'Spacebar' || k === 'ArrowUp') {
          e.preventDefault(); onThrust();
        }
      });

      // Bridge handlers
      window.addEventListener('message', (ev)=>{
        const m = ev.data;
        if (!m || typeof m !== 'object') return;

        if (m.type === 'ARCADE:SYNC') {
          if (m.game && m.game.id === GAME_ID) {
            st.runCostAC = Number(m.game.runCostAC ?? st.runCostAC);
            st.promoRuns = Number(m.game.promoRuns ?? st.promoRuns);
            st.promoGrantAC = Number(m.game.promoGrantAC ?? st.promoGrantAC);
            st.promoClaimed = !!m.game.promoClaimed;
            st.promoAC = Number(m.game.promoAC ?? st.promoAC);
          }
          if (m.player) {
            st.paidAC = Number(m.player.paidAC ?? st.paidAC);
            st.best = Number(m.player.bestByGame?.[GAME_ID] ?? st.best);
            st.address = String(m.player.address ?? st.address);
          }
          renderSession();
        }

        if (m.type === 'ARCADE:RUN_GRANTED' && m.gameId === GAME_ID) {
          activeGrant = {
            runId: String(m.runId || ''),
            runType: String(m.runType || '--'),
            costAC: Number(m.costAC ?? st.runCostAC),
            grantedAt: Date.now()
          };
          st.lastRunType = activeGrant.runType;
          UI.kRunType.textContent = activeGrant.runType;
          UI.hudRun.textContent = 'Run ' + activeGrant.runType;
          UI.kStatus.textContent = 'Running';
          UI.overlay.style.display = 'none';
          UI.btnStart.disabled = true;
          UI.btnStart.textContent = 'Starting…';

          resetRun();
          running = true;
          UI.btnStart.textContent = 'Start Run';
          requestAnimationFrame(tick);
        }

        if (m.type === 'ARCADE:RUN_DENIED' && m.gameId === GAME_ID) {
          UI.kStatus.textContent = 'Denied';
          UI.btnStart.disabled = false;
          toast(m.reason || 'Not enough Credits');
        }

        if (m.type === 'ARCADE:PROMO_CLAIMED' && m.gameId === GAME_ID) {
          st.promoClaimed = true;
          if (Number.isFinite(m.promoAC)) st.promoAC = Number(m.promoAC);
          renderSession();
          toast('Promo claimed — 5 free runs ready.');
        }

        if (m.type === 'ARCADE:RUN_RECORDED' && m.gameId === GAME_ID) {
          if (Number.isFinite(m.best)) st.best = Number(m.best);
          if (Number.isFinite(m.paidAC)) st.paidAC = Number(m.paidAC);
          if (Number.isFinite(m.promoAC)) st.promoAC = Number(m.promoAC);
          renderSession();
          toast('Run recorded');
        }
      });

      // Buttons
      UI.btnStart.addEventListener('click', ()=>{
        if (running) return;
        UI.kStatus.textContent = 'Requesting…';
        UI.btnStart.disabled = true;
        bridge.post('ARCADE:REQUEST_RUN', { gameId: GAME_ID });
        setTimeout(()=>{ if (!running) UI.btnStart.disabled = false; }, 800);
      });

      UI.btnPromo.addEventListener('click', ()=>{
        if (st.promoClaimed) return;
        bridge.post('ARCADE:REQUEST_PROMO', { gameId: GAME_ID });
        toast('Promo claim requested (confirm in dashboard)');
      });

      // Boot
      renderSession();
      bridge.post('ARCADE:READY', { gameId: GAME_ID, version: VERSION });
      toast('Ready');
    })();
  </script>
</body>
</html>
