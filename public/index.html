<html lang="en">
<head>
  <!-- built by grues√É¬∏me - Pixi.js Migration -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>$TBAG's Tappy Rocket - Pixi.js Edition</title>

  <!-- PWA Configuration -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Tappy Rocket">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <meta name="description" content="$TBAG's Tappy Rocket - Play to earn $TBAG tokens in this addictive Web3 rocket game on Linea blockchain">

  <!-- Pixi.js v7 - WebGL renderer with excellent performance -->
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>

  <!-- Ethers.js for Web3 integration -->
  <!-- built by grues√∏me (version 1.4) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.2/dist/ethers.umd.min.js"></script>

  <!-- Google Fonts: Barlow -->
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@200;700;800&display=swap" rel="stylesheet" />

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      user-select: none;
      font-family: 'Barlow', sans-serif;
      font-weight: 200;
    }

    #game-container {
      position: fixed;
      width: 100vw;
      height: 100vh;
      max-width: 500px;
      max-height: 900px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at top, #1a1a2e 0%, #000 60%);
      border-radius: 0;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), 0 0 80px rgba(138, 43, 226, 0.6);
      overflow: hidden;
      font-family: 'Barlow', sans-serif;
    }

    @media (min-width: 500px) {
      #game-container {
        border-radius: 20px;
        width: 400px;
        height: 600px;
      }
    }

    /* Mobile touch optimization */
    @media (max-width: 500px) {
      #game-container {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }
      button, .btn-restart {
        min-height: 44px;
        min-width: 44px;
        font-size: 16px;
      }
    }

    #pixi-canvas {
      display: block;
      border-radius: 20px;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Web3 UI panel styling */
    #web3-ui {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 420px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
      align-items: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      color: #00ffff;
      font-family: 'Barlow', sans-serif;
      font-size: 13px;
      z-index: 30;
      /* smooth fade + prevent stray taps while hidden */
      opacity: 1;
      pointer-events: auto;
      transition: opacity 220ms ease-in-out, transform 220ms ease-in-out;
      will-change: opacity, transform;
    }

    /* Web3 panel - only fade on mobile */
    @media (max-width: 500px) {
      #web3-ui.hidden-in-game {
        opacity: 0;
        pointer-events: none;
        transform: translateX(-50%) translateY(-10px);
      }
    }

    #web3-ui button {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 4px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      white-space: nowrap;
      transition: all 0.15s;
    }

    #web3-ui button:hover {
      background: rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
    }

    #web3-ui span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
    }

    #credit-count {
      background: rgba(0, 255, 0, 0.15);
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(0, 255, 0, 0.5);
      color: #00ff00;
      font-weight: 800;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
      min-width: 80px;
      text-align: center;
    }

    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #e0e0ff;
      text-shadow: 0 0 6px rgba(0, 255, 255, 0.7);
      font-family: 'Barlow', sans-serif;
      font-size: 18px;
      pointer-events: none;
      z-index: 10;
    }

    .hud-left, .hud-right {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .hud-label {
      font-size: 13px;
      text-transform: uppercase;
      opacity: 0.7;
      letter-spacing: 1px;
    }

    .hud-value {
      font-size: 21px;
      font-weight: 700;
    }

    .hud-tbag {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 17px;
      letter-spacing: 0.5px;
    }

    .hud-tbag span {
      font-weight: 700;
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .combo-indicator {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 60px;
      font-family: 'Barlow', sans-serif;
      font-size: 18px;
      color: #ffdd55;
      text-shadow: 0 0 10px rgba(255, 221, 85, 0.9);
      pointer-events: none;
      z-index: 15;
    }

    .speed-meter-container {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      color: #ccc;
      font-size: 13px;
      font-family: 'Barlow', sans-serif;
      pointer-events: none;
      z-index: 10;
    }

    .speed-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
    }

    .speed-bar {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.06);
      overflow: hidden;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) inset;
    }

    .speed-bar-fill {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #00ffcc, #00ffff, #ff00ff);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      transition: width 0.1s linear;
    }

    .music-mute-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 50%;
      color: #00ffff;
      font-size: 20px;
      cursor: pointer;
      z-index: 20;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .music-mute-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    }

    .music-mute-btn.muted {
      color: #ff4444;
      border-color: rgba(255, 68, 68, 0.4);
      text-decoration: line-through;
    }

    .music-mute-btn.muted:hover {
      background: rgba(255, 68, 68, 0.2);
      border-color: #ff4444;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
    }

    .sfx-mute-btn {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 40px;
      height: 40px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 50%;
      color: #00ffff;
      font-size: 18px;
      cursor: pointer;
      z-index: 20;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .sfx-mute-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    }

    .sfx-mute-btn.muted {
      color: #ff4444;
      border-color: rgba(255, 68, 68, 0.4);
    }

    .sfx-mute-btn.muted:hover {
      background: rgba(255, 68, 68, 0.2);
      border-color: #ff4444;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
    }

    .sfx-mute-btn.muted::after {
      content: 'üîá';
      position: absolute;
    }

    .menu-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin: 20px 0;
    }

    .menu-audio-btn {
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 255, 0.4);
      border-radius: 50%;
      color: #00ffff;
      font-size: 22px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .menu-audio-btn:hover {
      background: rgba(0, 255, 255, 0.2);
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      transform: scale(1.1);
    }

    .menu-audio-btn.muted {
      color: #ff4444;
      border-color: rgba(255, 68, 68, 0.4);
    }

    .menu-audio-btn.muted:hover {
      background: rgba(255, 68, 68, 0.2);
      border-color: #ff4444;
      box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
    }

    .menu-overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      color: #fff;
      text-align: center;
      pointer-events: auto;
      cursor: pointer;
    }

    .menu-overlay.hidden {
      display: none;
    }

    .start-panel {
      padding: 20px 18px;
      border-radius: 16px;
      background: linear-gradient(145deg, rgba(10, 10, 25, 0.95), rgba(45, 15, 65, 0.98));
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.7);
      width: 80%;
      max-width: 320px;
    }

    .start-title {
      font-family: 'Barlow', sans-serif;
      font-size: 26px;
      margin-bottom: 10px;
      color: #00ffff;
      text-shadow: 0 0 16px rgba(0, 255, 255, 0.9);
    }

    .start-instructions {
      font-size: 15px;
      line-height: 1.4;
      color: #ddd;
      margin-bottom: 12px;
    }

    .start-hint {
      font-size: 12px;
      opacity: 0.7;
    }

    .game-over-panel {
      padding: 20px 18px;
      border-radius: 16px;
      background: linear-gradient(145deg, rgba(10, 10, 25, 0.95), rgba(45, 15, 65, 0.98));
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), 0 0 40px rgba(138, 43, 226, 0.7);
      width: 80%;
      max-width: 300px;
      max-height: 90vh;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .game-over-title {
      font-family: 'Barlow', sans-serif;
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 12px;
      color: #00ffff;
      text-shadow: 0 0 16px rgba(0, 255, 255, 0.9);
    }

    .game-over-subtitle {
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 16px;
      line-height: 1.3;
      color: #ddd;
      opacity: 0.85;
    }

    .btn-restart {
      margin-top: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 10px 0;
      border-radius: 999px;
      border: none;
      outline: none;
      cursor: pointer;
      background: linear-gradient(135deg, #00ffff, #8a2be2);
      color: #000;
      font-family: 'Barlow', sans-serif;
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 1px;
      text-transform: uppercase;
      box-shadow: 0 0 12px rgba(0, 255, 255, 0.8), 0 0 25px rgba(138, 43, 226, 0.9);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    .btn-restart:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 16px rgba(0, 255, 255, 1), 0 0 30px rgba(138, 43, 226, 1);
    }

    .btn-restart:active {
      transform: translateY(1px);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7), 0 0 20px rgba(138, 43, 226, 0.7);
    }

    .hint-text {
      margin-top: 8px;
      font-size: 10px;
      opacity: 0.7;
    }

    .leaderboard-panel {
      margin-top: 15px;
      padding: 10px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(0,255,255,0.3);
      border-radius: 10px;
      max-width: 260px;
      margin-left: auto;
      margin-right: auto;
    }

    .leaderboard-title {
      color: #00ffff;
      font-size: 16px;
      margin-bottom: 6px;
      text-align: center;
      font-weight: 700;
    }

    .leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 120px;
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.3) rgba(0,0,0,0.2);
    }

    .leaderboard-list::-webkit-scrollbar {
      width: 8px;
    }

    .leaderboard-list::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
    }

    .leaderboard-list::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
    }

    .leaderboard-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.5);
    }

    .leaderboard-list li {
      display: flex;
      justify-content: space-between;
      padding: 6px;
      margin-bottom: 4px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      color: white;
      font-size: 12px;
    }

    .admin-reset-btn {
      margin-top: 10px;
      padding: 6px 12px;
      background: rgba(255, 0, 0, 0.2);
      border: 1px solid rgba(255, 0, 0, 0.4);
      border-radius: 8px;
      color: #ff4444;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .admin-reset-btn:hover {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.6);
    }

    /* Tutorial overlay - simple transparent click-to-close */
    .tutorial-overlay {
      position: absolute;
      inset: 0;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      pointer-events: auto;
      cursor: pointer;
    }

    .tutorial-overlay.hidden {
      display: none;
    }

    .tutorial-hint-text {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Barlow', sans-serif;
      font-size: 14px;
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      opacity: 0.8;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .menu-button {
      padding: 15px 40px;
      font-size: 24px;
      font-weight: 700;
      font-family: 'Barlow', sans-serif;
      color: #fff;
      background: linear-gradient(135deg, #8a2be2, #00ffff);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .menu-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(138, 43, 226, 0.6);
    }

    .menu-button:active {
      transform: scale(0.95);
    }

    .score-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 20px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 30px;
    }

    .score-label {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-value {
      font-size: 28px;
      font-weight: 700;
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .tbag-graffiti {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 260px;
      height: auto;
      opacity: 0;
      pointer-events: none;
      filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.9));
      transition: opacity 0.25s ease-out, transform 0.25s ease-out;
      z-index: 20;
    }

    .tbag-graffiti.active {
      opacity: 1;
      transform: scale(1.05);
    }
    
    .touch-indicator {
      position: absolute;
      width: 60px;
      height: 60px;
      border: 3px solid rgba(0, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      z-index: 100;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }
    
    .touch-indicator.active {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    /* First-run tutorial overlay */
    .tutorial-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      background: radial-gradient(circle at 50% 15%, rgba(0, 255, 255, 0.08), transparent 55%),
                  linear-gradient(to bottom, rgba(3, 12, 32, 0.8), rgba(0, 0, 0, 0.85));
      color: #fff;
      font-family: "Barlow", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      text-align: center;
      z-index: 110;
      opacity: 1;
      pointer-events: auto;
      transition: opacity 220ms ease-out;
    }

    .tutorial-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .tutorial-content {
      max-width: 360px;
      width: 100%;
      background: rgba(4, 16, 40, 0.9);
      border-radius: 14px;
      border: 1px solid rgba(0, 255, 255, 0.45);
      box-shadow:
        0 0 0 1px rgba(0, 0, 0, 0.65),
        0 0 32px rgba(0, 255, 255, 0.45);
      padding: 14px 16px 12px;
      backdrop-filter: blur(10px);
    }

    .tutorial-title {
      font-size: 18px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 6px;
      color: #e8f7ff;
    }

    .tutorial-body {
      font-size: 13px;
      line-height: 1.4;
      opacity: 0.9;
    }

    .tutorial-body strong {
      color: #4ef0ff;
      font-weight: 600;
    }

    .tutorial-powerups {
      margin-top: 12px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .powerup-row {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      line-height: 1.3;
      opacity: 0.95;
    }

    .powerup-icon {
      width: 28px;
      height: 28px;
      flex-shrink: 0;
      object-fit: contain;
      filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.4));
    }

    .powerup-row strong {
      color: #4ef0ff;
      font-weight: 600;
      display: inline;
    }

    .tutorial-hint {
      margin-top: 10px;
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.8;
      animation: tutorialHintPulse 1.4s ease-in-out infinite;
    }

    @keyframes tutorialHintPulse {
      0%   { opacity: 0.3; transform: translateY(0); }
      50%  { opacity: 1;   transform: translateY(-2px); }
      100% { opacity: 0.3; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <!-- Web3 UI Panel -->
  <div id="web3-ui">
    <button id="connect-btn">Connect Wallet</button>
    <button id="disconnect-btn" style="display:none;">Disconnect</button>
    <span id="wallet-address"></span>
    <span id="credit-count">üéÆ 0</span>
    <button id="purchase-btn">Buy Credit</button>
    <button id="refresh-btn" style="display:none;">üîÑ Refresh</button>
  </div>

  <div id="game-container">
    <!-- HUD -->
    <div class="hud">
      <div class="hud-left">
        <div class="hud-label">Score</div>
        <div class="hud-value" id="scoreDisplay">0</div>
        <div class="hud-label">HIGH SCORE</div>
        <div class="hud-value" id="hudHighScoreDisplay">0</div>
        <div class="hud-tbag">
          <span>$TBAGs:</span>
          <div id="tbagDisplay">0</div>
        </div>
      </div>
    </div>

    <!-- Music Mute Button -->
    <button id="musicMuteButton" class="music-mute-btn" title="Toggle Background Music">‚ô´</button>
    
    <!-- Sound Effects Mute Button -->
    <button id="sfxMuteButton" class="sfx-mute-btn" title="Toggle Sound Effects">üîä</button>

    <!-- Combo Indicator -->
    <div class="combo-indicator" id="comboIndicator">COMBO x1</div>

    <!-- Speed Meter -->
    <div class="speed-meter-container">
      <div class="speed-label">
        <span>Speed</span>
        <span id="speedValue">1.0x</span>
      </div>
      <div class="speed-bar">
        <div class="speed-bar-fill" id="speedBarFill"></div>
      </div>
    </div>

    <!-- Graffiti image displayed when $TBAGs are collected -->
    <img id="graffitiImage" class="tbag-graffiti" src="./assets/images/tbagsecured.png" alt="$TBAG secured" />
    
    <!-- Touch indicator for mobile feedback -->
    <div id="touchIndicator" class="touch-indicator"></div>

    <!-- Transparent first-run tutorial overlay -->
    <div id="tutorialOverlay" class="tutorial-overlay">
      <div class="tutorial-content">
        <div class="tutorial-title">$TBAG&rsquo;s Tappy Rocket</div>
        <div class="tutorial-body">
          Tap, click, or press <strong>SPACE / ‚Üë</strong> to fire your thrusters.<br />
          Dodge the <strong>red candles</strong>, grab <strong>powerups</strong>, and secure <strong>$TBAGs</strong>.
        </div>
        <div style="color: red; font-weight: bold; font-size: 16px; margin: 10px 0; text-align: center;">
          ‚ö†Ô∏è WARNING: GAME GET FAST ‚ö†Ô∏è
        </div>
        <div class="tutorial-powerups">
          <div class="powerup-row">
            <img src="./assets/images/slow.png" alt="Slow-Mo" class="powerup-icon" />
            <span><strong>Slow-Mo:</strong> Brief slowdown + small permanent speed reduction</span>
          </div>
          <div class="powerup-row">
            <img src="./assets/images/sherk.png" alt="More Score" class="powerup-icon" />
            <span><strong>More Score:</strong> Temporarily increases all points by random factors</span>
          </div>
          <div class="powerup-row">
            <img src="./assets/images/gun.png" alt="Gun" class="powerup-icon" />
            <span><strong>Gun:</strong> Auto-fires bullets to destroy red candles</span>
          </div>
          <div class="powerup-row">
            <img src="./assets/images/cece.png" alt="Cece Rockets" class="powerup-icon" />
            <span><strong>Cece Rockets:</strong> Rapid RPG burst ahead</span>
          </div>
          <div class="powerup-row">
            <img src="./assets/images/invincibility.png" alt="Invincibility" class="powerup-icon" />
            <span><strong>Invincibility:</strong> Shield + destroys candles on contact</span>
          </div>
        </div>
        <div class="tutorial-hint">Tap anywhere to continue</div>
      </div>
    </div>

    <!-- Start Menu -->
    <div class="menu-overlay hidden" id="startMenu">
      <div class="start-panel">
        <div class="start-title">$TBAG's Tappy Rocket</div>
        <div class="start-instructions">
          Tap or press SPACE/UP to thrust your rocket.<br />
          Dodge the red candles, gather powerups, and secure $TBAGs!
        </div>
        <div class="menu-buttons">
          <button id="startMusicBtn" class="menu-audio-btn" title="Toggle Music">‚ô´</button>
          <button id="startSfxBtn" class="menu-audio-btn" title="Toggle Sound Effects">üîä</button>
        </div>
        <div class="start-hint">Tap or press SPACE to start</div>
      </div>
    </div>

    <!-- Game Over Menu -->
    <div class="menu-overlay hidden" id="gameOverMenu">
      <div class="game-over-panel">
        <div class="game-over-title">MISSION FAILED</div>
        <div class="score-row">
          <div class="score-label">Final Score</div>
          <div class="score-value" id="finalScoreDisplay">0</div>
        </div>
        <div class="score-row">
          <div class="score-label">High Score</div>
          <div class="score-value" id="finalHighScoreDisplay">0</div>
        </div>
        <div class="score-row">
          <div class="score-label">$TBAGs Collected</div>
          <div class="score-value" id="finalTbagDisplay">0</div>
        </div>
        <div class="score-row">
          <div class="score-label">$TBAG High Score</div>
          <div class="score-value" id="finalTbagHighScoreDisplay">0</div>
        </div>
        <div class="menu-buttons">
          <button id="gameoverMusicBtn" class="menu-audio-btn" title="Toggle Music">‚ô´</button>
          <button id="gameoverSfxBtn" class="menu-audio-btn" title="Toggle Sound Effects">üîä</button>
        </div>
        <div class="leaderboard-panel">
          <div class="leaderboard-title">Global Leaderboard</div>
          <ul id="leaderboardList" class="leaderboard-list"></ul>
        </div>
        <button id="adminResetBtn" class="admin-reset-btn" style="display:none;">Reset Leaderboard</button>
        <button class="btn-restart" id="restartButton" ontouchstart="this.classList.add('touched')" ontouchend="this.classList.remove('touched')">Re-Launch Rocket</button>
        <div class="hint-text">Press SPACE / TAP to thrust. Avoid the red candles.</div>
      </div>
    </div>
  </div>

  <script>
    // ==================== DEBUG FLAG ====================
    // Debug mode: enabled in development, disabled in production
    const DEBUG = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const debugLog = (...args) => DEBUG && console.log(...args);
    const debugWarn = (...args) => DEBUG && console.warn(...args);
    // Keep console.error for production error tracking

    // ==================== GAME STATE ====================
    const GAME_WIDTH = 400;
    const GAME_HEIGHT = 600;
    
    // Game balance constants
    const BIRD_COLLISION_RADIUS = 0.4; // Adjusted to match 1.6x visual sprite size
    const ROCKET_SIZE_MULTIPLIER = 1.6; // Matches backup display size (32 * 1.6 = 51.2px)
    const GRAVITY = 0.25;
    const BASE_SPEED = 3.21;
    const SPEED_INCREMENT_MIN = 0.03;
    const SPEED_INCREMENT_MAX = 0.08;
    const COMBO_DURATION_FRAMES = 120;
    const PIPE_SPAWN_INTERVAL = 90;
    const POWERUP_MIN_SPAWN_CHANCE = 0.30;

    // ==================== WEB3 INTEGRATION ====================
    // Signature: YnVpbHQgYnkgZ3J1ZXPDuG1l
    // This section handles wallet connection, credit purchasing and credit tracking.
    const CONTRACT_ADDRESS = '0xB670AB661c91081A44DEE43D9f0c79CEa5930dDf';
    const CONTRACT_ABI = [
      {
        inputs: [ { internalType: 'uint256', name: 'amount', type: 'uint256' } ],
        name: 'purchaseCreditsWithETH',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
      },
      {
        inputs: [],
        name: 'creditPriceETH',
        outputs: [ { internalType: 'uint256', name: '', type: 'uint256' } ],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [ { internalType: 'address', name: '', type: 'address' } ],
        name: 'credits',
        outputs: [ { internalType: 'uint256', name: '', type: 'uint256' } ],
        stateMutability: 'view',
        type: 'function',
      },
    ];

    let provider;
    let signer;
    let contract;
    // Don't auto-load wallet from localStorage - require manual connection
    let walletAddress = null;
    let creditPriceWei;
    const USD_PRICE_PER_CREDIT = 0.01; // Cost per credit in USD (1 cent)
    // Use a fixed credit price of 5,000,000,000,000¬†wei (0.000005¬†ETH) instead of dynamically
    // computing the price from the ETH/USD oracle.  This hardcoded price matches roughly
    // $0.01 when ETH ‚âà $2,000 and ensures deterministic cost without depending on
    // CoinGecko or the contract‚Äôs creditPriceETH value.  See commit message for details.
    const CREDIT_PRICE_WEI = 5000000000000n;
    // Initialize credits from localStorage, fallback to 0 if not found
    const savedCredits = localStorage.getItem('tappyCredits');
    window.localCredits = savedCredits ? parseInt(savedCredits, 10) : 0;
    debugLog('üíæ Loaded credits from localStorage:', window.localCredits);

    // Centralized credit sync function - single source of truth
    async function syncCredits() {
      if (!contract || !walletAddress) {
        debugWarn('Cannot sync credits: no contract or wallet');
        return false;
      }
      
      try {
        debugLog('üîÑ Syncing credits from blockchain for:', walletAddress);
        const creditsBN = await contract.credits(walletAddress);
        const onChainCredits = Number(creditsBN);
        
        // Don't overwrite if game is active - local credit usage takes precedence
        if (game.started && !game.over) {
          debugLog('‚ö†Ô∏è Game is active, skipping credit overwrite. Blockchain:', onChainCredits, 'Local:', window.localCredits);
          return true;
        }
        
        window.localCredits = onChainCredits;
        localStorage.setItem('tappyCredits', String(onChainCredits));
        updateCreditDisplay();
        
        debugLog('‚úÖ Credits synced:', onChainCredits);
        return true;
      } catch (err) {
        console.error('‚ùå Failed to sync credits:', err);
        return false;
      }
    }

    // Update credit display in the UI
    function updateCreditDisplay() {
      const addrSpan = document.getElementById('wallet-address');
      const creditSpan = document.getElementById('credit-count');
      if (!addrSpan || !creditSpan) return;
      if (walletAddress) {
        const short = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
        addrSpan.textContent = short;
      } else {
        addrSpan.textContent = '';
      }
      creditSpan.textContent = 'üéÆ ' + window.localCredits;
    }

    // Use a credit when starting a game. Returns true if credit consumed, otherwise false.
    window.useCredit = function () {
      debugLog('=== USE CREDIT CALLED ===');
      debugLog('walletAddress:', walletAddress);
      debugLog('window.localCredits:', window.localCredits);
      debugLog('typeof window.localCredits:', typeof window.localCredits);
      debugLog('Number.isFinite(window.localCredits):', Number.isFinite(window.localCredits));
      
      if (!walletAddress) {
        alert('Connect your wallet first.');
        return false;
      }
      
      // Force read from localStorage to ensure we have latest value
      const savedCredits = localStorage.getItem('tappyCredits');
      if (savedCredits) {
        window.localCredits = parseInt(savedCredits, 10);
        debugLog('Reloaded credits from localStorage:', window.localCredits);
      }
      
      if (!Number.isFinite(window.localCredits)) {
        debugWarn('Credits not finite, defaulting to 0');
        window.localCredits = 0;
      }
      
      if (window.localCredits <= 0) {
        alert(`You need credits to play. You have ${window.localCredits} credits. Please buy a credit first.`);
        return false;
      }

      debugLog('‚úÖ Using 1 credit, current balance:', window.localCredits);
      window.localCredits -= 1;
      localStorage.setItem('tappyCredits', String(window.localCredits));
      updateCreditDisplay();
      debugLog('‚úÖ Credit used, new balance:', window.localCredits);
      return true;
    };

    // Connect wallet handler with mobile support
    async function connectWallet() {
      debugLog('=== MOBILE WALLET CONNECT START ===');
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      debugLog('Mobile device:', isMobile);
      debugLog('window.ethereum present:', !!window.ethereum);
      
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const purchaseBtn = document.getElementById('purchase-btn');
      
      if (!window.ethereum) {
        if (isMobile) {
          const deepLink = `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}${window.location.search}`;
          debugLog('No wallet detected, opening MetaMask:', deepLink);
          alert('Opening MetaMask mobile app...');
          window.location.href = deepLink;
          return;
        } else {
          alert('Please install MetaMask browser extension.');
          return;
        }
      }
      
      try {
        if (connectBtn) connectBtn.disabled = true;
        
        debugLog('[1/5] Initializing provider...');
        provider = new ethers.BrowserProvider(window.ethereum);
        
        debugLog('[2/5] Requesting account access...');
        const accounts = await provider.send('eth_requestAccounts', []);
        debugLog('Accounts returned:', accounts);
        
        debugLog('[3/5] Getting signer...');
        signer = await provider.getSigner();
        walletAddress = await signer.getAddress();
        debugLog('Connected wallet:', walletAddress);
        
        // Check network and switch if needed
        const network = await provider.getNetwork();
        debugLog('Current network chainId:', network.chainId.toString());
        
        if (network.chainId !== 59141n) {
          debugLog('Wrong network, switching to Linea Sepolia...');
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0xe705' }]
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              debugLog('Network not found, adding Linea Sepolia...');
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0xe705',
                  chainName: 'Linea Sepolia',
                  nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                  rpcUrls: ['https://rpc.sepolia.linea.build'],
                  blockExplorerUrls: ['https://sepolia.lineascan.build']
                }]
              });
            } else {
              throw switchError;
            }
          }
          // Reinitialize after network switch
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();
          walletAddress = await signer.getAddress();
          debugLog('Network switched, wallet reconnected:', walletAddress);
        }
        
        debugLog('[4/5] Creating contract instance...');
        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        
        // Sync credits from blockchain with centralized function
        debugLog('[5/5] Syncing credits from blockchain...');
        let syncSuccess = false;
        let retries = 3;
        
        while (!syncSuccess && retries > 0) {
          syncSuccess = await syncCredits();
          if (!syncSuccess) {
            retries--;
            if (retries > 0) {
              debugLog(`Sync failed, retrying... (${retries} left)`);
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }
        
        if (!syncSuccess) {
          debugWarn('‚ö†Ô∏è Could not sync credits after retries, defaulting to 0');
          window.localCredits = 0;
          localStorage.setItem('tappyCredits', '0');
        }
        
        // Update UI
        if (connectBtn) {
          connectBtn.style.display = 'none';
          connectBtn.disabled = false;
        }
        if (disconnectBtn) disconnectBtn.style.display = 'inline-block';
        if (purchaseBtn) purchaseBtn.disabled = false;
        
        const refreshBtn = document.getElementById('refresh-btn');
        if (refreshBtn) refreshBtn.style.display = 'inline-block';
        
        updateCreditDisplay();
        
        // Show admin button if admin wallet
        if (walletAddress.toLowerCase() === "0x3100ff9597b87e791e5bb8c0d57c94336a432089") {
          document.getElementById("adminResetBtn").style.display = "block";
        }
        
        debugLog('=== MOBILE WALLET CONNECT SUCCESS ===');
      } catch (err) {
        console.error(err);
        alert('Wallet connection failed');
      }
    }

    // Manual credit refresh function
    async function refreshCredits() {
      if (!contract || !walletAddress) {
        alert('‚ö†Ô∏è Not connected to wallet');
        return;
      }
      
      const refreshBtn = document.getElementById('refresh-btn');
      if (refreshBtn) refreshBtn.disabled = true;
      
      try {
        alert('üîÑ Syncing credits from blockchain...');
        const success = await syncCredits();
        
        if (success) {
          alert(`‚úÖ Credits synced! You have ${window.localCredits} credits`);
        } else {
          alert('‚ùå Failed to sync credits. Check console for details.');
        }
      } finally {
        if (refreshBtn) refreshBtn.disabled = false;
      }
    }
    
    // Disconnect wallet handler
    function disconnectWallet() {
      debugLog('=== DISCONNECTING WALLET ===');
      
      // Clear all state
      walletAddress = null;
      provider = null;
      signer = null;
      contract = null;
      window.localCredits = 0;
      
      // Clear all localStorage
      localStorage.removeItem('tappyWalletAddress');
      localStorage.removeItem('tappyCredits');
      
      // Update buttons
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const purchaseBtn = document.getElementById('purchase-btn');
      const refreshBtn = document.getElementById('refresh-btn');
      
      if (connectBtn) {
        connectBtn.style.display = 'inline-block';
        connectBtn.disabled = false;
      }
      if (disconnectBtn) disconnectBtn.style.display = 'none';
      if (purchaseBtn) purchaseBtn.disabled = true;
      if (refreshBtn) refreshBtn.style.display = 'none';
      
      updateCreditDisplay();
      debugLog('‚úÖ Wallet disconnected, state cleared');
    }

    // Helper to fetch current ETH price in USD from CoinGecko
    async function fetchEthUsdPrice() {
      try {
        const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
        const data = await resp.json();
        return data.ethereum.usd;
      } catch (e) {
        debugWarn('Unable to fetch ETH price; falling back to contract price', e);
        return null;
      }
    }

    // Purchase one credit using ETH priced at USD_PRICE_PER_CREDIT
    async function purchaseCredit() {
      if (!contract || !walletAddress) {
        alert('Connect your wallet first.');
        return;
      }

      const purchaseBtn = document.getElementById('purchase-btn');
      if (purchaseBtn && purchaseBtn.disabled) return;

      try {
        if (purchaseBtn) purchaseBtn.disabled = true;
        window.isPurchasing = true;

        debugLog('=== STARTING CREDIT PURCHASE ===');
        debugLog('Price:', CREDIT_PRICE_WEI.toString(), 'wei');
        debugLog('Wallet:', walletAddress);

        // Send transaction
        debugLog('[1/3] Sending transaction...');
        const tx = await contract.purchaseCreditsWithETH(1, { value: CREDIT_PRICE_WEI });
        debugLog('Transaction hash:', tx.hash);
        
        // Wait for confirmation with mobile-friendly timeout
        debugLog('[2/3] Waiting for confirmation (this may take 10-30 seconds on mobile)...');
        const receipt = await tx.wait();
        debugLog('Transaction confirmed, status:', receipt.status);
        
        if (receipt.status === 1) {
          // Force blockchain resync with retry logic
          debugLog('[3/3] Resyncing credits from blockchain...');
          purchaseBtn.textContent = '‚è≥ Syncing...';
          let synced = false;
          let attempts = 5;
          
          while (!synced && attempts > 0) {
            // Wait for blockchain state to propagate
            await new Promise(resolve => setTimeout(resolve, 500));
            
            synced = await syncCredits();
            
            if (!synced) {
              attempts--;
              debugLog(`Sync failed, retrying... (${attempts} left)`);
            } else if (window.localCredits <= 0) {
              // Synced but no credits yet, keep trying
              synced = false;
              attempts--;
              debugLog(`Credits not updated yet, retrying... (${attempts} left)`);
            }
          }
          
          if (!synced || window.localCredits <= 0) {
            debugWarn('‚ö†Ô∏è Could not verify credit update, using fallback');
            window.localCredits = (window.localCredits || 0) + 1;
            localStorage.setItem('tappyCredits', String(window.localCredits));
            updateCreditDisplay();
          }
          
          alert('‚úÖ Credit purchased! You now have ' + window.localCredits + ' credit(s).');
          debugLog('=== PURCHASE SUCCESS ===');
        } else {
          console.error('‚ùå Transaction failed, status:', receipt.status);
          alert('Transaction failed. Please try again.');
        }
      } catch (err) {
        console.error('‚ùå Purchase error:', err);
        if (err.code === 4001) {
          alert('Transaction cancelled.');
        } else {
          alert('Purchase failed: ' + (err.message || 'Unknown error'));
        }
      } finally {
        window.isPurchasing = false;
        if (purchaseBtn) purchaseBtn.disabled = false;
      }
    }

    // Bind button events once DOM is ready
    window.addEventListener('DOMContentLoaded', () => {
      const connectBtn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const purchaseBtn = document.getElementById('purchase-btn');
      const refreshBtn = document.getElementById('refresh-btn');
      
      // Add both click and touchstart handlers for mobile reliability
      if (connectBtn) {
        connectBtn.addEventListener('click', connectWallet);
        connectBtn.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          connectWallet();
        }, { passive: false });
      }
      
      if (disconnectBtn) {
        disconnectBtn.addEventListener('click', disconnectWallet);
        disconnectBtn.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          disconnectWallet();
        }, { passive: false });
      }
      
      if (purchaseBtn) {
        purchaseBtn.addEventListener('click', purchaseCredit);
        purchaseBtn.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          purchaseCredit();
        }, { passive: false });
      }
      
      if (refreshBtn) {
        refreshBtn.addEventListener('click', refreshCredits);
        refreshBtn.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          refreshCredits();
        }, { passive: false });
      }
      
      updateCreditDisplay();
      
      // Handle wallet events for mobile reconnection
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', async (accounts) => {
          debugLog('=== ACCOUNT CHANGED ===');
          debugLog('New accounts:', accounts);
          
          if (accounts.length > 0) {
            try {
              // Full reconnection with new account
              provider = new ethers.BrowserProvider(window.ethereum);
              signer = await provider.getSigner();
              walletAddress = await signer.getAddress();
              contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
              
              debugLog('Reconnected with new account:', walletAddress);
              
              // Force blockchain resync with retry
              let synced = false;
              let retries = 3;
              
              while (!synced && retries > 0) {
                synced = await syncCredits();
                if (!synced && retries > 0) {
                  retries--;
                  debugLog(`Sync failed, retrying... (${retries} left)`);
                  await new Promise(resolve => setTimeout(resolve, 1000));
                }
              }
              
              if (!synced) {
                debugWarn('‚ö†Ô∏è Could not sync credits for new account');
                // Don't reset to 0 - keep localStorage value and alert user
                alert('‚ö†Ô∏è Could not sync credits from blockchain. Click refresh button to retry.');
              }
              
              updateCreditDisplay();
            } catch (err) {
              console.error('‚ùå Account switch failed:', err);
              disconnectWallet();
            }
          } else {
            debugLog('No accounts, disconnecting...');
            disconnectWallet();
          }
        });
        
        window.ethereum.on('chainChanged', () => {
          // Don't reload if currently purchasing - prevents losing credits
          if (window.isPurchasing) {
            debugLog('Chain changed during purchase, deferring reload...');
            return;
          }
          window.location.reload();
        });
      }
    });
    
    // Resync credits when tab regains focus (critical for mobile wallet returns)
    window.addEventListener('focus', () => {
      if (contract && walletAddress) {
        debugLog('üîÑ Tab focused - loading credits from localStorage first');
        // Load from localStorage immediately for instant UI update
        const savedCredits = localStorage.getItem('tappyCredits');
        if (savedCredits) {
          window.localCredits = parseInt(savedCredits, 10);
          updateCreditDisplay();
        }
        // DON'T sync from blockchain if game is active - prevents credit overwrite race condition
        if (!game.started || game.over) {
          debugLog('üîÑ Game not active, syncing from blockchain');
          syncCredits();
        } else {
          debugLog('‚ö†Ô∏è Game is active, skipping blockchain sync to prevent credit overwrite');
        }
      }
    });
    
    const game = {
      started: false,
      over: false,
      bird: null,
      pipes: [],
      bullets: [],
      muzzleFlashes: [],
      rockets: [],
      explosions: [],
      particles: [],
      powerups: [],
      ceceActive: false,
      score: 0,
      highScore: 0,
      tbags: 0,
      tbagHighScore: 0,
      redCandlesPassed: 0,
      speed: BASE_SPEED,
      baseSpeed: BASE_SPEED,
      multiplier: 1,
      gravity: GRAVITY,
      shakeMag: 0,
      shakeDecay: 0.9,
      flashAlpha: 0,
      slowActive: false,
      slowPowerupsCollected: 0, // Track how many slow powerups collected for permanent reduction
      invincible: false,
      doubleScoreActive: false,
      combo: 1,
      comboTimer: 0,
      comboFlash: 0,
      flash: 0,
      flashColor: [255, 255, 255],
      shake: 0,
      muted: false,
      musicMuted: false, // Separate control for background music
      ceceParticles: [],
      ceceSmokes: [],
      ceceFlashes: [],
      ceceLastShotFrame: 0,
      logoParticles: [],
      logoFlash: 0,
      logoShake: 0,
      slowWaves: [],
      slowFadeCounter: 0,
      slowWarpLevel: 0,
      sherkAnim: null,
      nearMissFlash: 0,
      warningFlash: 0,
      burstInProgress: false,
      logo: null,
      logoParticles: [],
      logoFlash: 0,
      logoShake: 0
    };

    // Object pool and rendering limits
    // Auto-detect mobile once at startup
    const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    const MAX_BULLETS = isMobile ? 6 : 25;
    const MAX_ROCKETS = isMobile ? 4 : 12;
    const MAX_PARTICLES = isMobile ? 12 : 40;
    const MAX_EXPLOSIONS = isMobile ? 2 : 6;
    const MAX_SLOW_WAVES = isMobile ? 2 : 8;
    const MAX_FLOATING_TEXTS = isMobile ? 5 : 20;
    const MAX_MUZZLE_FLASHES = isMobile ? 2 : 10;
    const GUN_FIRE_INTERVAL = isMobile ? 15 : 10;
    const INVINC_FIRE_INTERVAL = isMobile ? 8 : 4;
    const POWERUP_COOLDOWN_FRAMES = 140;

    let gunTimer = 0;
    let slowTimer = 0;
    let doubleTimer = 0;
    let ceceTimer = 0;
    let invTimer = 0;
    let lastPipeTime = 0;
    let pipeInterval = 90;
    let powerupTimer = 0;
    let frameCount = 0;

    // DOM elements
    const dom = {
      scoreDisplay: document.getElementById('scoreDisplay'),
      hudHighScoreDisplay: document.getElementById('hudHighScoreDisplay'),
      tbagDisplay: document.getElementById('tbagDisplay'),
      comboIndicator: document.getElementById('comboIndicator'),
      speedValue: document.getElementById('speedValue'),
      speedBarFill: document.getElementById('speedBarFill'),
      graffitiImage: document.getElementById('graffitiImage'),
      touchIndicator: document.getElementById('touchIndicator'),
      tutorialOverlay: document.getElementById('tutorialOverlay'),
      startMenu: document.getElementById('startMenu'),
      gameOverMenu: document.getElementById('gameOverMenu'),
      restartButton: document.getElementById('restartButton'),
      finalScoreDisplay: document.getElementById('finalScoreDisplay'),
      finalHighScoreDisplay: document.getElementById('finalHighScoreDisplay'),
      finalTbagDisplay: document.getElementById('finalTbagDisplay'),
      finalTbagHighScoreDisplay: document.getElementById('finalTbagHighScoreDisplay')
    };

    const TUTORIAL_KEY = 'tappyRocketTutorialSeen';

    function showTutorialIfNeeded() {
      if (!dom.tutorialOverlay) return;
      // Always show tutorial on page load (removed localStorage check)
      dom.tutorialOverlay.classList.remove('hidden');
    }

    function dismissTutorial() {
      if (!dom.tutorialOverlay) return;
      dom.tutorialOverlay.classList.add('hidden');
      // Show start menu after tutorial is dismissed
      if (dom.startMenu) {
        dom.startMenu.classList.remove('hidden');
      }
      // Note: Not storing to localStorage, will show again on refresh
    }

    if (dom.tutorialOverlay) {
      dom.tutorialOverlay.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        dismissTutorial();
      });
      dom.tutorialOverlay.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        e.preventDefault();
        dismissTutorial();
      }, { passive: false });
    }

    // Call once at startup
    showTutorialIfNeeded();

    // ==================== PIXI.JS SETUP ====================
    // Optimize renderer settings for mobile (reuse isMobile variable defined above)
    
    const app = new PIXI.Application({
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
      backgroundColor: 0x000000,
      antialias: !isMobile, // Disable antialiasing on mobile for better performance
      resolution: isMobile ? 1 : (window.devicePixelRatio || 1), // Force 1x resolution on mobile
      autoDensity: true,
      powerPreference: isMobile ? 'default' : 'high-performance'
    });
    
    // Mobile-specific renderer optimizations
    if (isMobile) {
      app.renderer.resolution = Math.min(window.devicePixelRatio, 1.0);
      PIXI.settings.ROUND_PIXELS = true;
      app.renderer.plugins.interaction.moveWhenInside = true;
    }
    
    // Enable smooth textures globally (NEAREST for mobile performance)
    if (isMobile) {
      PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
      PIXI.settings.ROUND_PIXELS = true;
      app.ticker.maxFPS = 45; // Limit mobile FPS
    } else {
      PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;
      PIXI.settings.ROUND_PIXELS = false;
      app.ticker.maxFPS = 60;
    }

    document.getElementById('game-container').appendChild(app.view);
    app.view.id = 'pixi-canvas';

    // Container for all game objects
    const gameContainer = new PIXI.Container();
    app.stage.addChild(gameContainer);

    // Powerup visual effects layer (drawn on top of everything)
    const powerupEffectsLayer = new PIXI.Graphics();
    
    // Floating multiplier texts for double score powerup
    const floatingTexts = [];

    // ==================== BACKGROUND ELEMENTS ====================
    // Helper function to generate organic irregular polygon shapes
    function createIrregularPolygon(size, points, irregularity) {
      const vertices = [];
      for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const radiusVariation = 1 + (Math.random() - 0.5) * irregularity;
        const radius = size * radiusVariation;
        vertices.push(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius
        );
      }
      return vertices;
    }
    
    // Helper to create wispy elongated cloud shape
    function createWispyShape(size) {
      const vertices = [];
      const points = 12 + Math.floor(Math.random() * 8);
      const stretchX = 0.6 + Math.random() * 0.8; // 0.6-1.4x width
      const stretchY = 1.2 + Math.random() * 0.8; // 1.2-2.0x height
      for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const radiusVar = 0.7 + Math.random() * 0.6;
        vertices.push(
          Math.cos(angle) * size * radiusVar * stretchX,
          Math.sin(angle) * size * radiusVar * stretchY
        );
      }
      return vertices;
    }
    
    // Deep space gradient layers with organic nebula shapes
    const bgLayers = [];
    
    // Reduce layer counts on mobile
    const CLOUD_COUNT = isMobile ? 5 : 15;
    const MID_LAYER_COUNT = isMobile ? 4 : 12;
    
    // Layer 1: Deep space nebula clouds (slowest, darkest) - optimized
    for (let i = 0; i < CLOUD_COUNT; i++) {
      const cloud = new PIXI.Graphics();
      const x = Math.random() * GAME_WIDTH * 2.5;
      const y = Math.random() * GAME_HEIGHT;
      const size = Math.random() * 180 + 100;
      
      // Random shape type
      const shapeType = Math.floor(Math.random() * 3);
      let vertices;
      if (shapeType === 0) {
        vertices = createIrregularPolygon(size, 16, 0.6);
      } else if (shapeType === 1) {
        vertices = createWispyShape(size * 0.8);
      } else {
        vertices = createIrregularPolygon(size, 20, 0.8);
      }
      
      // Color variation
      const gradient = Math.random();
      const alphaVar = 0.02 + Math.random() * 0.04; // 0.02-0.06 (reduced opacity)
      
      // Pre-calculate scaled vertex arrays (performance optimization)
      const vertices75 = [];
      const vertices50 = [];
      for (let j = 0; j < vertices.length; j++) {
        vertices75.push(vertices[j] * 0.75);
        vertices50.push(vertices[j] * 0.5);
      }
      
      if (gradient > 0.6) {
        // Deep blue with slight variation
        const colorVar = Math.floor(Math.random() * 0x000022);
        cloud.beginFill(0x000011 + colorVar, alphaVar);
        cloud.drawPolygon(vertices);
        cloud.endFill();
        cloud.beginFill(0x000033 + colorVar, alphaVar * 0.7);
        cloud.drawPolygon(vertices75);
        cloud.endFill();
        cloud.beginFill(0x001155 + colorVar, alphaVar * 0.4);
        cloud.drawPolygon(vertices50);
        cloud.endFill();
      } else if (gradient > 0.3) {
        // Black to purple-blue
        const colorVar = Math.floor(Math.random() * 0x000033);
        cloud.beginFill(0x000000, alphaVar * 1.1);
        cloud.drawPolygon(vertices);
        cloud.endFill();
        cloud.beginFill(0x0a0022 + colorVar, alphaVar * 0.75);
        cloud.drawPolygon(vertices75);
        cloud.endFill();
        cloud.beginFill(0x1a0044 + colorVar, alphaVar * 0.45);
        cloud.drawPolygon(vertices50);
        cloud.endFill();
      } else {
        // Dark teal-blue
        const colorVar = Math.floor(Math.random() * 0x001111);
        cloud.beginFill(0x000a11 + colorVar, alphaVar * 0.95);
        cloud.drawPolygon(vertices);
        cloud.endFill();
        cloud.beginFill(0x001a33 + colorVar, alphaVar * 0.65);
        cloud.drawPolygon(vertices75);
        cloud.endFill();
        cloud.beginFill(0x002a55 + colorVar, alphaVar * 0.35);
        cloud.drawPolygon(vertices50);
        cloud.endFill();
      }
      
      cloud.x = x;
      cloud.y = y;
      cloud.speed = 0.01 + Math.random() * 0.01; // Slowest (farthest)
      cloud.baseAlpha = alphaVar;
      cloud.colorPhase = Math.random() * Math.PI * 2;
      cloud.driftSpeed = (Math.random() - 0.5) * 0.15;
      cloud.baseY = y;
      cloud.rotation = Math.random() * Math.PI * 2;
      cloud.rotationSpeed = (Math.random() - 0.5) * 0.0005;
      cloud.baseScale = 1.0;
      cloud.scalePhase = Math.random() * Math.PI * 2;
      cloud.depthLayer = 1; // Farthest
      if (!isMobile) {
        cloud.filters = [new PIXI.BlurFilter(15 + Math.random() * 5)];
      } else {
        cloud.filters = null;
      }
      cloud.cacheAsBitmap = true; // PERFORMANCE: Cache as bitmap texture
      bgLayers.push(cloud);
      gameContainer.addChildAt(cloud, 0);
    }
    
    // Layer 2: Mid-depth nebula gradients (medium speed) - optimized
    for (let i = 0; i < MID_LAYER_COUNT; i++) {
      const layer = new PIXI.Graphics();
      const x = Math.random() * GAME_WIDTH * 2.5;
      const y = Math.random() * GAME_HEIGHT;
      const size = Math.random() * 120 + 70;
      
      // Generate organic shape
      const shapeType = Math.floor(Math.random() * 3);
      let vertices;
      if (shapeType === 0) {
        vertices = createIrregularPolygon(size, 14, 0.7);
      } else if (shapeType === 1) {
        vertices = createWispyShape(size * 0.9);
      } else {
        vertices = createIrregularPolygon(size, 18, 0.5);
      }
      
      // Blue gradient variations with alpha variance
      const hue = i % 5;
      const alphaVar = 0.03 + Math.random() * 0.05; // 0.03-0.08 (reduced opacity)
      const colorVar = Math.floor(Math.random() * 0x000033);
      
      // Pre-calculate scaled vertex arrays
      const vertices65 = [];
      const vertices70 = [];
      const vertices40 = [];
      const vertices45 = [];
      const vertices60 = [];
      const vertices35 = [];
      const vertices68 = [];
      const vertices38 = [];
      const vertices63 = [];
      const vertices37 = [];
      for (let j = 0; j < vertices.length; j++) {
        vertices65.push(vertices[j] * 0.65);
        vertices70.push(vertices[j] * 0.7);
        vertices40.push(vertices[j] * 0.4);
        vertices45.push(vertices[j] * 0.45);
        vertices60.push(vertices[j] * 0.6);
        vertices35.push(vertices[j] * 0.35);
        vertices68.push(vertices[j] * 0.68);
        vertices38.push(vertices[j] * 0.38);
        vertices63.push(vertices[j] * 0.63);
        vertices37.push(vertices[j] * 0.37);
      }
      
      if (hue === 0) {
        // Cyan-ish blue
        layer.beginFill(0x000022 + colorVar, alphaVar * 1.1);
        layer.drawPolygon(vertices);
        layer.endFill();
        layer.beginFill(0x001144 + colorVar, alphaVar * 0.7);
        layer.drawPolygon(vertices65);
        layer.endFill();
        layer.beginFill(0x002266 + colorVar, alphaVar * 0.45);
        layer.drawPolygon(vertices40);
        layer.endFill();
      } else if (hue === 1) {
        // Deep navy
        layer.beginFill(0x00001a + colorVar, alphaVar * 1.15);
        layer.drawPolygon(vertices);
        layer.endFill();
        layer.beginFill(0x000033 + colorVar, alphaVar * 0.75);
        layer.drawPolygon(vertices70);
        layer.endFill();
        layer.beginFill(0x000055 + colorVar, alphaVar * 0.5);
        layer.drawPolygon(vertices45);
        layer.endFill();
      } else if (hue === 2) {
        // Dark blue-purple
        layer.beginFill(0x0a0011 + colorVar, alphaVar * 1.05);
        layer.drawPolygon(vertices);
        layer.endFill();
        layer.beginFill(0x150033 + colorVar, alphaVar * 0.72);
        layer.drawPolygon(vertices68);
        layer.endFill();
        layer.beginFill(0x200055 + colorVar, alphaVar * 0.42);
        layer.drawPolygon(vertices38);
        layer.endFill();
      } else if (hue === 3) {
        // Teal-blue
        layer.beginFill(0x001122 + colorVar, alphaVar * 0.95);
        layer.drawPolygon(vertices);
        layer.endFill();
        layer.beginFill(0x002244 + colorVar, alphaVar * 0.65);
        layer.drawPolygon(vertices60);
        layer.endFill();
        layer.beginFill(0x003366 + colorVar, alphaVar * 0.38);
        layer.drawPolygon(vertices35);
        layer.endFill();
      } else {
        // Purple-navy mix
        layer.beginFill(0x0a001a + colorVar, alphaVar * 1.0);
        layer.drawPolygon(vertices);
        layer.endFill();
        layer.beginFill(0x150044 + colorVar, alphaVar * 0.68);
        layer.drawPolygon(vertices63);
        layer.endFill();
        layer.beginFill(0x200077 + colorVar, alphaVar * 0.4);
        layer.drawPolygon(vertices37);
        layer.endFill();
      }
      
      layer.x = x;
      layer.y = y;
      layer.speed = 0.04 + Math.random() * 0.04; // Medium speed (mid-depth)
      layer.baseAlpha = alphaVar;
      layer.colorPhase = Math.random() * Math.PI * 2;
      layer.driftSpeed = (Math.random() - 0.5) * 0.2;
      layer.baseY = y;
      layer.rotation = Math.random() * Math.PI * 2;
      layer.rotationSpeed = (Math.random() - 0.5) * 0.001;
      layer.baseScale = 1.0;
      layer.scalePhase = Math.random() * Math.PI * 2;
      layer.depthLayer = 2; // Mid-depth
      if (!isMobile) {
        layer.filters = [new PIXI.BlurFilter(20 + Math.random() * 8)];
      } else {
        layer.filters = null;
      }
      bgLayers.push(layer);
      gameContainer.addChildAt(layer, Math.min(bgLayers.length - 1, gameContainer.children.length));
    }
    
    // PERFORMANCE: Use ParticleContainer for stars (10-100x faster than individual Graphics)
    const starContainer = new PIXI.ParticleContainer(200, {
      position: true,
      alpha: true,
      scale: false,
      rotation: false,
      uvs: false,
      tint: true
    });
    gameContainer.addChild(starContainer);
    
    const stars = [];
    // Desaturated star color palette - very subtle differences
    const starColors = [
      { color: 0xd5d9e0, weight: 0.02 }, // Subtle blue tint
      { color: 0xdce0e5, weight: 0.05 }, // Very subtle blue-white
      { color: 0xe5e8eb, weight: 0.10 }, // Near white with slight cool tint
      { color: 0xeeeee8, weight: 0.15 }, // Near white with slight warm tint
      { color: 0xeeeade, weight: 0.25 }, // Very subtle yellow (most common)
      { color: 0xebe5d8, weight: 0.20 }, // Very subtle orange
      { color: 0xe8e0d5, weight: 0.15 }, // Very subtle warm
      { color: 0xe5ddd0, weight: 0.05 }, // Subtle warm
      { color: 0xe0d8cc, weight: 0.02 }, // Faint warm
      { color: 0xddd5c8, weight: 0.01 }  // Very faint warm
    ];
    
    function getRandomStarColor() {
      const rand = Math.random();
      let cumulative = 0;
      for (const star of starColors) {
        cumulative += star.weight;
        if (rand <= cumulative) return star.color;
      }
      return starColors[4].color; // Default to yellow
    }
    
    // Create simple star texture for particle container
    const starGraphics = new PIXI.Graphics();
    starGraphics.beginFill(0xFFFFFF);
    starGraphics.drawCircle(0, 0, 2);
    starGraphics.endFill();
    const starTexture = app.renderer.generateTexture(starGraphics);
    
    const STAR_COUNT = isMobile ? 50 : 150;
    for (let i = 0; i < STAR_COUNT; i++) {
      const star = new PIXI.Sprite(starTexture);
      star.anchor.set(0.5);
      // Wide brightness range: very faint (0.05) to very bright (1.0)
      const brightness = Math.pow(Math.random(), 2.5); // Power distribution favors dimmer stars
      const alpha = brightness * 0.85 + 0.15; // 0.15 to 1.0
      const starColor = getRandomStarColor();
      star.tint = starColor;
      star.alpha = alpha;
      const size = brightness * 1.5 + 0.15; // 0.15 to 1.65 scale
      star.scale.set(size);
      star.x = Math.random() * GAME_WIDTH;
      star.y = Math.random() * GAME_HEIGHT;
      star.speed = 0.15 + Math.random() * 0.25; // Fastest (closest) 0.15-0.4
      star.baseBrightness = brightness;
      star.baseAlpha = alpha;
      star.baseColor = starColor;
      star.depthLayer = 3; // Closest
      stars.push(star);
      starContainer.addChild(star);
    }

    function updateStars() {
      for (const star of stars) {
        star.x -= star.speed * (game.speed / game.baseSpeed);
        
        // Generate new star on right side as game moves
        if (star.x < -10) {
          star.x = GAME_WIDTH + 10;
          star.y = Math.random() * GAME_HEIGHT;
          const brightness = Math.pow(Math.random(), 2.5);
          star.baseBrightness = brightness;
          star.baseAlpha = brightness * 0.85 + 0.15;
          star.alpha = star.baseAlpha;
        }
      }
    }
    
    function updateBackgroundLayers() {
      // Mobile: update every other frame to reduce CPU load
      if (isMobile && frameCount % 2 !== 0) return;
      
      const time = Date.now() * 0.0005;
      for (const layer of bgLayers) {
        layer.x -= layer.speed * (game.speed / game.baseSpeed);
        
        // Generate new nebula on right side as game moves
        if (layer.x < -400) {
          layer.x = GAME_WIDTH + 400;
          layer.baseY = Math.random() * GAME_HEIGHT;
          layer.y = layer.baseY;
        }
        
        // PERFORMANCE: Only update visible layers (culling)
        if (layer.x > -500 && layer.x < GAME_WIDTH + 500) {
          // Only vertical drift - no pulsing animations
          if (layer.baseY !== undefined) {
            const drift1 = Math.sin(time * 0.15 + layer.colorPhase) * 20;
            const drift2 = Math.sin(time * 0.25 + layer.colorPhase * 1.3) * 8;
            layer.y = layer.baseY + drift1 + drift2;
          }
          layer.visible = true;
        } else {
          layer.visible = false; // Hide off-screen layers
        }
      }
    }

    // ==================== OBJECT POOLS ====================
    class ObjectPool {
      constructor(createFn, resetFn, initialSize = 10) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = [];
        
        // Pre-populate pool
        for (let i = 0; i < initialSize; i++) {
          this.pool.push(this.createFn());
        }
      }

      get() {
        let obj;
        if (this.pool.length > 0) {
          obj = this.pool.pop();
        } else {
          obj = this.createFn();
        }
        this.active.push(obj);
        return obj;
      }

      release(obj) {
        const index = this.active.indexOf(obj);
        if (index > -1) {
          this.active.splice(index, 1);
          this.resetFn(obj);
          this.pool.push(obj);
          if (obj.sprite) obj.sprite.visible = false;
        }
      }

      releaseAll() {
        while (this.active.length > 0) {
          this.release(this.active[0]);
        }
      }
    }

    // ==================== AUDIO MANAGER ====================
    const AudioMode = {
      NONE: 'none',
      HTML5: 'html5',
      WEBAUDIO: 'webaudio'
    };

    const audioConfig = {
      mode: AudioMode.NONE,
      ready: false,
      sfxMuted: false,
      musicMuted: false,
      tracks: {
        music: null,
        flap: null,
        score: null,
        explosion: null,
      },
    };

    // Legacy compatibility - keep these for desktop WebAudio path
    let audioContext;
    let bgMusicSource = null;
    let bgMusicGain = null;
    const sounds = {};

    // Call once on DOM ready
    function initAudioLayer() {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

      if (!isMobile) {
        // Desktop: use existing WebAudio path
        audioConfig.mode = AudioMode.WEBAUDIO;
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          debugLog('AudioContext created for desktop');
        } catch (err) {
          console.error('Failed to create AudioContext:', err);
          audioConfig.ready = false; // Disable audio if initialization fails
          audioContext = {
            state: 'running',
            resume: () => Promise.resolve(),
            createGain: () => ({ gain: { value: 0 }, connect: () => {} }),
            createBufferSource: () => ({ buffer: null, loop: false, connect: () => {}, start: () => {} }),
            destination: {},
            decodeAudioData: () => Promise.reject('Audio not supported')
          };
        }
        audioConfig.ready = true;
        return;
      }

      // Mobile: lean HTML5 audio only, no fancy WebAudio
      debugLog('Mobile detected: using HTML5 Audio');
      audioConfig.mode = AudioMode.HTML5;

      try {
        audioConfig.tracks.music = new Audio('./assets/audio/background.mp3');
        audioConfig.tracks.music.loop = true;
        audioConfig.tracks.music.preload = 'none';
        audioConfig.tracks.music.volume = 0.4;

        audioConfig.tracks.flap = new Audio('./assets/audio/flap.mp3');
        audioConfig.tracks.flap.preload = 'none';
        audioConfig.tracks.flap.volume = 0.5;

        audioConfig.tracks.score = new Audio('./assets/audio/score.mp3');
        audioConfig.tracks.score.preload = 'none';
        audioConfig.tracks.score.volume = 0.6;

        audioConfig.tracks.explosion = new Audio('./assets/audio/explosion.mp3');
        audioConfig.tracks.explosion.preload = 'none';
        audioConfig.tracks.explosion.volume = 0.7;

        audioConfig.ready = true;
      } catch (err) {
        console.error('Failed to initialize mobile audio:', err);
        audioConfig.ready = false; // Disable audio if initialization fails
      }

      // Unlock on first touch/click
      const unlock = () => {
        try {
          Object.values(audioConfig.tracks).forEach(a => {
            if (!a) return;
            a.muted = audioConfig.musicMuted && a === audioConfig.tracks.music;
            try { a.play().then(() => a.pause()).catch(() => {}); } catch (_) {}
          });
        } catch (err) {
          console.error('Audio unlock failed:', err);
          audioConfig.ready = false;
        }
        window.removeEventListener('touchstart', unlock);
        window.removeEventListener('click', unlock);
      };
      window.addEventListener('touchstart', unlock, { once: true });
      window.addEventListener('click', unlock, { once: true });
    }

    function playSfx(name) {
      if (!audioConfig.ready || audioConfig.sfxMuted) return;
      if (audioConfig.mode !== AudioMode.HTML5) return; // desktop handled elsewhere

      const base = audioConfig.tracks[name];
      if (!base) return;

      // Simple, low-overhead clone
      const a = base.cloneNode();
      a.volume = base.volume;
      a.play().catch(() => {});
    }

    function setMusicMuted(muted) {
      audioConfig.musicMuted = muted;
      const m = audioConfig.tracks.music;
      if (!m) return;
      if (muted) m.pause();
      else m.play().catch(() => {});
    }

    function setSfxMuted(muted) {
      audioConfig.sfxMuted = muted;
    }

    // Aggressive audio unlock - try on every user interaction
    function forceAudioUnlock() {
      try {
        if (audioConfig.mode === AudioMode.WEBAUDIO && audioContext && audioContext.state !== 'running') {
          audioContext.resume();
        }
      } catch (err) {
        debugWarn('Audio unlock failed:', err);
        if (isMobile) game.muted = true;
      }
    }
    
    // Unlock everywhere including mobile touchstart
    ['touchstart', 'touchend', 'mousedown', 'click', 'keydown'].forEach(event => {
      document.addEventListener(event, forceAudioUnlock, { passive: true });
    });
    
    // Mobile-specific audio unlock
    document.addEventListener('touchstart', () => {
      if (audioContext && audioContext.state !== 'running') {
        audioContext.resume().catch(e => {
          if (isMobile) game.muted = true;
        });
      }
    }, { once: true });

    // Load and play background music from MP3
    // Background music: "background.mp3" made by Elisaveta Stoycheva
    // https://pixabay.com/users/elisaveta_stoycheva-49582321/
    function loadBackgroundMusic() {
      return fetch('./assets/audio/background.mp3')
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          sounds.background = audioBuffer;
        })
        .catch(err => debugWarn('Background music not found, continuing without it:', err));
    }
    
    function createBackgroundMusic() {
      if (bgMusicSource || !sounds.background) return;
      
      // Skip background music entirely on mobile for performance
      if (audioConfig.mode === AudioMode.HTML5) {
        debugLog('Background music DISABLED on mobile for performance');
        return;
      }
      
      try {
        // Web Audio API for desktop only
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            startMusicSource();
          }).catch(err => {
            debugWarn('Audio context resume failed:', err);
          });
        } else {
          startMusicSource();
        }
        
        function startMusicSource() {
          try {
            bgMusicGain = audioContext.createGain();
            bgMusicGain.gain.value = game.musicMuted ? 0 : 0.2;
            bgMusicGain.connect(audioContext.destination);
            
            bgMusicSource = audioContext.createBufferSource();
            bgMusicSource.buffer = sounds.background;
            bgMusicSource.loop = true;
            bgMusicSource.connect(bgMusicGain);
            bgMusicSource.start(0);
            
            debugLog('Background music started from MP3');
          } catch (err) {
            console.error('Failed to start music source:', err);
            bgMusicSource = null;
            bgMusicGain = null;
          }
        }
      } catch (err) {
        console.error('Failed to create background music:', err);
      }
    }
    
    function stopBackgroundMusic() {
      if (!bgMusicSource) return;
      
      try {
        bgMusicSource.stop();
        bgMusicSource = null;
        bgMusicGain = null;
        debugLog('Background music stopped');
      } catch (e) {
        debugWarn('Error stopping background music:', e);
      }
    }

    function loadSound(name, url) {
      return fetch(url)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          sounds[name] = audioBuffer;
        })
        .catch(err => debugWarn(`Failed to load sound ${name}:`, err));
    }
    
    function safePlay(name, volume = 1.0, rate = 1.0) {
      if (game.muted) return;
      
      // Mobile HTML5 Audio path - use AudioManager
      if (audioConfig.mode === AudioMode.HTML5) {
        playSfx(name);
        return;
      }

      // Desktop WebAudio path
      try {
        if (!sounds[name]) return;
        
        const source = audioContext.createBufferSource();
        source.buffer = sounds[name];
        source.playbackRate.value = rate;
        
        const gainNode = audioContext.createGain();
        gainNode.gain.value = volume;
        
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);
        source.start(0);
        
        // Store reference to invincibility audio so we can stop it later
        if (name === 'invincibility') {
          if (game.invincibilityAudio) {
            game.invincibilityAudio.stop();
          }
          game.invincibilityAudio = source;
        }
      } catch (error) {
        // Silently fail on mobile
      }
    }

    // Load all sounds
    Promise.all([
      loadSound('flap', './assets/audio/flap.mp3'),
      loadSound('lift', './assets/audio/lift.mp3'),
      loadSound('score', './assets/audio/score.mp3'),
      loadSound('hit', './assets/audio/lift.mp3'),
      loadSound('explosion', './assets/audio/explosion.mp3'),
      loadSound('powerup', './assets/audio/tbagburst.mp3'),
      loadSound('shoot', './assets/audio/gun.mp3'),
      loadSound('sherk', './assets/audio/sherk.mp3'),
      loadSound('slow', './assets/audio/slow.mp3'),
      loadSound('invincibility', './assets/audio/invincibility.mp3'),
      loadSound('tbagsecured', './assets/audio/tbagsecured.mp3'),
      loadBackgroundMusic() // Load background music MP3
    ]);

    // ==================== GRAPHICS & SPRITES ====================
    // Load actual image assets
    const assets = {};
    
    async function loadAssets() {
      try {
        assets.rocket = await PIXI.Assets.load('./assets/images/tbag-rocket-transparent.png');
        assets.redCandle = await PIXI.Assets.load('./assets/images/red-candle-stick.png');
        assets.greenCandle = await PIXI.Assets.load('./assets/images/green-candle-stick.png');
        assets.gun = await PIXI.Assets.load('./assets/images/gun.png');
        assets.slow = await PIXI.Assets.load('./assets/images/slow.png');
        assets.sherk = await PIXI.Assets.load('./assets/images/sherk.png');
        assets.cece = await PIXI.Assets.load('./assets/images/cece.png');
        assets.invincibility = await PIXI.Assets.load('./assets/images/invincibility.png');
        assets.flame = await PIXI.Assets.load('./assets/images/flame.png');
        assets.restartLogo = await PIXI.Assets.load('./assets/images/tbagburst.png');
        debugLog('Assets loaded successfully');
      } catch (error) {
        console.error('Failed to load assets:', error);
      }
    }

    // Create graphics for visual elements
    function createCircleTexture(radius, color) {
      const graphics = new PIXI.Graphics();
      graphics.beginFill(color);
      graphics.drawCircle(0, 0, radius);
      graphics.endFill();
      return app.renderer.generateTexture(graphics);
    }

    function createRectTexture(width, height, color) {
      const graphics = new PIXI.Graphics();
      graphics.beginFill(color);
      graphics.drawRect(-width/2, -height/2, width, height);
      graphics.endFill();
      return app.renderer.generateTexture(graphics);
    }

    // Textures (fallbacks)
    const textures = {
      bullet: createCircleTexture(2.5, 0xFFFF00), // r=2.5 matches backup
      particle: createCircleTexture(2, 0xFF0000)
    };

    // ==================== BIRD CLASS ====================
    class Bird {
      constructor() {
        // Create sprite with placeholder, will be updated after assets load
        this.sprite = new PIXI.Sprite();
        this.sprite.anchor.set(0.5);
        this.size = 32;
        
        // Create flame sprite FIRST so it renders behind rocket
        this.flameSprite = new PIXI.Sprite();
        this.flameSprite.anchor.set(0.5);
        this.flameSprite.visible = false;
        gameContainer.addChild(this.flameSprite);
        
        // Add rocket sprite after flame so it renders on top
        gameContainer.addChild(this.sprite);
        
        // Create sherk icon sprite on top of rocket
        this.sherkSprite = new PIXI.Sprite();
        this.sherkSprite.anchor.set(0.5);
        this.sherkSprite.visible = false;
        gameContainer.addChild(this.sherkSprite);
        
        this.flameTimer = 0;
        this.reset();
      }

      setTexture() {
        if (assets.rocket) {
          this.sprite.texture = assets.rocket;
          // Scale rocket sprite for better visibility
          const displaySize = this.size * ROCKET_SIZE_MULTIPLIER;
          this.sprite.width = displaySize;
          this.sprite.height = displaySize;
        }
        if (assets.flame) {
          this.flameSprite.texture = assets.flame;
        }
        if (assets.sherk) {
          this.sherkSprite.texture = assets.sherk;
        }
      }

      reset() {
        this.x = 64;
        this.y = GAME_HEIGHT / 2;
        this.vy = 0;
        this.sprite.x = this.x;
        this.sprite.y = this.y;
        this.sprite.rotation = 0;
        this.sprite.visible = true;
      }

      flap() {
        this.vy = -5;
        this.flameTimer = 10; // Trigger flame for 10 frames
        const pitch = 0.95 + Math.random() * 0.1;
        safePlay('flap', 0.3, pitch);
        safePlay('lift', 0.4, pitch);
      }

      update() {
        if (!game.started || game.over) return;

        // Add motion trail when moving fast
        if (Math.abs(this.vy) > 3 && frameCount % 3 === 0) {
          createParticles(this.x - 10, this.y, 1, 0x00AAFF, { 
            speedMin: 0.5, 
            speedMax: 1, 
            lifeMin: 8, 
            lifeMax: 12,
            direction: Math.PI,
            spread: Math.PI / 3
          });
        }

        // Apply gravity and velocity
        this.vy += game.gravity;
        
        // Clamp velocity to prevent it from getting too extreme
        if (this.vy > 8) this.vy = 8;
        if (this.vy < -8) this.vy = -8;
        
        this.y += this.vy;

        // Rotation based on velocity (map from -5,5 to -0.02,0.01)
        const clampedV = Math.max(-5, Math.min(5, this.vy));
        const angle = -0.02 + (clampedV + 5) * 0.003;
        this.sprite.rotation = angle;

        // Game over when flying off screen bounds
        if (this.y > GAME_HEIGHT) {
          if (game.started && !game.over) {
            gameOver();
          }
        }
        if (this.y < 0) {
          if (game.started && !game.over) {
            gameOver();
          }
        }

        this.sprite.x = this.x;
        this.sprite.y = this.y;
        
        // Update flame sprite
        if (this.flameTimer > 0 && assets.flame) {
          this.flameSprite.visible = true;
          this.flameSprite.texture = assets.flame;
          
          // Position flame behind rocket with proper rotation
          this.flameSprite.x = this.x;
          this.flameSprite.y = this.y;
          this.flameSprite.rotation = angle;
          
          // Offset flame position in local rotated space (6px more left, 6px more down)
          const flameOffsetX = -56; // Behind rocket (50 + 6 left)
          const flameOffsetY = this.size * 0.8 + 18; // Below center (12 + 6 down)
          
          // Apply rotation to offset
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          this.flameSprite.x += flameOffsetX * cos - flameOffsetY * sin;
          this.flameSprite.y += flameOffsetX * sin + flameOffsetY * cos;
          
          // Scale flame dramatically
          const flameScale = 5.5 * 1.1 * 1.1;
          this.flameSprite.width = this.size * 1.2 * flameScale;
          this.flameSprite.height = this.size * 1.5 * flameScale;
          
          this.flameTimer--;
        } else {
          this.flameSprite.visible = false;
        }
        
        // Update sherk icon animation
        if (game.sherkAnim !== null && assets.sherk) {
          const duration = 60;
          const progress = game.sherkAnim / duration;
          const sherkScale = 1 + 2 * progress; // Grow from 1x to 3x
          const baseSize = 36;
          const iconSize = baseSize * sherkScale;
          
          this.sherkSprite.visible = true;
          this.sherkSprite.x = this.x;
          this.sherkSprite.y = this.y;
          this.sherkSprite.width = iconSize;
          this.sherkSprite.height = iconSize;
          // Quadratic fade: stays more opaque longer, then fades at the end
          this.sherkSprite.alpha = 1 - (progress * progress);
        } else {
          this.sherkSprite.visible = false;
        }
      }

      checkCollision(pipe) {
        // Match original game.html collision: use 20% of base size, not visual sprite size
        const collisionRadius = this.size * 0.2; // 32 * 0.2 = 6.4px like original
        
        const horizontallyAligned =
          this.x + collisionRadius > pipe.x &&
          this.x - collisionRadius < pipe.x + pipe.w;
        const aboveTop = this.y - collisionRadius < (pipe.collisionTop || pipe.top);
        const belowBottom = this.y + collisionRadius > (pipe.collisionBottom || pipe.bottom);
        
        return horizontallyAligned && (aboveTop || belowBottom);
      }
    }

    // ==================== PIPE CLASS ====================
    class Pipe {
      constructor() {
        this.topSprite = new PIXI.Sprite();
        this.bottomSprite = new PIXI.Sprite();
        this.topSprite.anchor.set(0, 1);
        this.bottomSprite.anchor.set(0, 0);
        this.scored = false;
        this.passed = false;
        this.w = 50;
        gameContainer.addChild(this.topSprite);
        gameContainer.addChild(this.bottomSprite);
      }

      reset(x, gap, gapY, isRed = false) {
        this.x = x;
        this.gap = gap;
        this.gapY = gapY;
        this.isRed = isRed;
        this.scored = false;
        this.passed = false;
        
        // Calculate top and bottom positions
        this.top = gapY - gap / 2;
        this.bottom = gapY + gap / 2;
        
        // Use red candles with texture slicing to flip segments
        if (assets.redCandle) {
          const baseTexture = assets.redCandle.baseTexture;
          const imgHeight = baseTexture.height;
          const sliceH = imgHeight / 2;
          
          // Top segment: use BOTTOM half of texture (flipped so wick points up)
          const topRect = new PIXI.Rectangle(0, sliceH, baseTexture.width, sliceH);
          this.topSprite.texture = new PIXI.Texture(baseTexture, topRect);
          
          // Bottom segment: use TOP half of texture (flipped so wick points down)
          const bottomRect = new PIXI.Rectangle(0, 0, baseTexture.width, sliceH);
          this.bottomSprite.texture = new PIXI.Texture(baseTexture, bottomRect);
          
          // Set width and height to match original
          this.topSprite.width = this.w;
          this.topSprite.height = this.top;
          this.bottomSprite.width = this.w;
          this.bottomSprite.height = GAME_HEIGHT - this.bottom;
        }
        
        this.topSprite.visible = true;
        this.bottomSprite.visible = true;
        this.updatePosition();
      }

      updatePosition() {
        this.topSprite.x = this.x;
        this.topSprite.y = this.top;
        this.bottomSprite.x = this.x;
        this.bottomSprite.y = this.bottom;
        
        // Collision boundaries match visual sprite edges exactly
        // Top sprite: anchor (0,1) means sprite ENDS at this.top (its bottom edge)
        // Bottom sprite: anchor (0,0) means sprite STARTS at this.bottom (its top edge)
        // These ARE the collision boundaries - no adjustment needed
        this.collisionTop = this.top;
        this.collisionBottom = this.bottom;
      }

      update() {
        this.x -= game.speed;
        this.updatePosition();
        
        // Check scoring
        if (!this.scored && this.x < game.bird.x) {
          this.scored = true;
          // All pipes are red candles in this game (not target practice)
          incrementScore(false, this.isRed);
          const scorePitch = 1.0 + (game.combo - 1) * 0.05; // Higher pitch for higher combos
          safePlay('score', 0.4, Math.min(scorePitch, 1.5)); // Cap at 1.5x pitch
        }

        return this.x < -100; // Return true if off-screen
      }

      destroy() {
        this.topSprite.visible = false;
        this.bottomSprite.visible = false;
      }
    }

    // Pipe pool
    const pipePool = new ObjectPool(
      () => new Pipe(),
      (pipe) => pipe.destroy(),
      6
    );

    // ==================== BULLET CLASS ====================
    class Bullet {
      constructor() {
        this.sprite = new PIXI.Sprite(textures.bullet);
        this.sprite.anchor.set(0.5);
        this.r = 2.5;
        gameContainer.addChild(this.sprite);
      }

      reset(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx || 12;
        this.vy = vy || 0;
        this.sprite.visible = true;
        this.sprite.x = x;
        this.sprite.y = y;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.sprite.x = this.x;
        this.sprite.y = this.y;
        
        return this.x < -10 || this.x > GAME_WIDTH + 10 || 
               this.y < -10 || this.y > GAME_HEIGHT + 10;
      }

      hits(pipe) {
        // Match original: include bullet radius, use inclusive boundaries
        const inX = this.x + this.r >= pipe.x && this.x - this.r <= pipe.x + pipe.w;
        const inY = this.y - this.r <= pipe.top || this.y + this.r >= pipe.bottom;
        return inX && inY;
      }
    }

    const bulletPool = new ObjectPool(
      () => new Bullet(),
      (bullet) => { bullet.sprite.visible = false; },
      MAX_BULLETS
    );

    // ==================== ROCKET CLASS ====================
    class Rocket {
      constructor() {
        this.sprite = new PIXI.Graphics();
        this.trail = [];
        gameContainer.addChild(this.sprite);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 7;
        this.vy = 0;
        this.life = 120;
        this.r = 7; // Use actual sprite radius for collision
        this.trail = [];
        this.sprite.visible = true;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 10) this.trail.shift();
        
        this.draw();
        return this.life <= 0 || this.x > GAME_WIDTH + 50;
      }

      draw() {
        this.sprite.clear();
        
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
          const pos = this.trail[i];
          const t = (i + 1) / this.trail.length;
          const size = 14 * (0.8 + (1 - t) * 0.2);
          const alpha = 1 - (i / this.trail.length) * 0.7;
          this.sprite.beginFill(0xFF3200, alpha);
          this.sprite.drawCircle(pos.x, pos.y, size / 2);
          this.sprite.endFill();
        }
        
        // Draw missile body
        this.sprite.beginFill(0xC80000);
        this.sprite.drawCircle(this.x, this.y, 7);
        this.sprite.endFill();
        
        this.sprite.beginFill(0xFF6400);
        this.sprite.drawCircle(this.x, this.y, 4.9);
        this.sprite.endFill();
        
        // Nose cone (triangle)
        this.sprite.beginFill(0xFF0000);
        this.sprite.moveTo(this.x + 7, this.y);
        this.sprite.lineTo(this.x - 7, this.y - 4.67);
        this.sprite.lineTo(this.x - 7, this.y + 4.67);
        this.sprite.closePath();
        this.sprite.endFill();
      }

      hits(pipe) {
        // Use actual sprite radius (7px) for collision at visual contact
        const inX = this.x + this.r >= pipe.x && this.x - this.r <= pipe.x + pipe.w;
        const inY = this.y - this.r <= pipe.top || this.y + this.r >= pipe.bottom;
        return inX && inY;
      }
    }

    const rocketPool = new ObjectPool(
      () => new Rocket(),
      (rocket) => { rocket.sprite.visible = false; rocket.sprite.clear(); },
      MAX_ROCKETS
    );

    // ==================== PARTICLE CLASS ====================
    class Particle {
      constructor() {
        this.sprite = new PIXI.Sprite(textures.particle);
        this.sprite.anchor.set(0.5);
        gameContainer.addChild(this.sprite);
      }

      reset(x, y, vx, vy, color, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.sprite.tint = color;
        this.sprite.visible = true;
        this.sprite.x = x;
        this.sprite.y = y;
        this.sprite.alpha = 1;
        // Add size variation for visual diversity
        const sizeVariation = 0.5 + Math.random() * 1.0; // 0.5x to 1.5x
        this.sprite.scale.set(sizeVariation);
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.life--;
        
        this.sprite.x = this.x;
        this.sprite.y = this.y;
        this.sprite.alpha = this.life / this.maxLife;
        
        return this.life <= 0;
      }
    }

    const particlePool = new ObjectPool(
      () => new Particle(),
      (particle) => { particle.sprite.visible = false; },
      MAX_PARTICLES
    );

    // ==================== POWERUP CLASS ====================
    class Powerup {
      constructor() {
        this.sprite = new PIXI.Sprite();
        this.sprite.anchor.set(0.5);
        this.r = 18;
        gameContainer.addChild(this.sprite);
      }

      reset(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.collected = false;
        this.sprite.visible = true;
        
        // Set texture based on type
        const textureMap = {
          gun: assets.gun,
          slow: assets.slow,
          double: assets.sherk,
          cece: assets.cece,
          invincibility: assets.invincibility
        };
        
        const texture = textureMap[type];
        if (texture) {
          this.sprite.texture = texture;
          // Calculate base scale to achieve desired size (43.2px to match backup)
          const targetSize = this.r * 2.4; // 18 * 2.4 = 43.2px (matches backup: 36 * 1.2)
          const textureSize = Math.max(texture.width, texture.height);
          this.baseScale = targetSize / textureSize;
          this.sprite.scale.set(this.baseScale);
        }
        
        this.sprite.x = this.x;
        this.sprite.y = this.y;
      }

      update(game) {
        this.x -= 2; // Original speed = 2
        this.sprite.x = this.x;
        this.sprite.y = this.y;

        // Pulsing scale animation - 70% slower, scales with game speed
        // Apply pulse on top of base scale
        const speedFactor = game ? (game.speed / game.baseSpeed) : 1;
        const pulseFactor = 1.0 + 0.15 * Math.sin(frameCount * 0.036 * speedFactor);
        const finalScale = (this.baseScale || 1) * pulseFactor;
        this.sprite.scale.set(finalScale);

        return this.x < -this.r;
      }

      checkCollision(bird) {
        const dx = this.x - bird.x;
        const dy = this.y - bird.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        return dist < bird.size + this.r; // Bird size + powerup radius
      }
    }

    const powerupPool = new ObjectPool(
      () => new Powerup(),
      (powerup) => { powerup.sprite.visible = false; },
      10
    );

    // ==================== SLOW WAVE CLASS ====================
    class SlowWave {
      constructor() {
        this.graphics = new PIXI.Graphics();
        gameContainer.addChild(this.graphics);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.r = 0;
        this.alpha = 200;
        this.graphics.visible = true;
      }

      update() {
        // Smooth expansion
        this.r += 3;
        this.alpha -= 2.5;
        
        this.graphics.clear();
        if (this.alpha > 0) {
          // Multiple bright ripple rings with high opacity
          const opacity = this.alpha / 255;
          
          // Main bright ring - thicker and brighter
          this.graphics.lineStyle(4, 0x00E0FF, Math.min(opacity * 0.9, 0.9));
          this.graphics.drawCircle(this.x, this.y, this.r);
          
          // Inner bright ring
          if (this.r > 12) {
            this.graphics.lineStyle(3, 0x00FFFF, Math.min(opacity * 0.7, 0.8));
            this.graphics.drawCircle(this.x, this.y, this.r - 8);
          }
          
          // Outer trailing ring
          if (this.r > 18) {
            this.graphics.lineStyle(2.5, 0x00C8FF, Math.min(opacity * 0.6, 0.7));
            this.graphics.drawCircle(this.x, this.y, this.r + 6);
          }
          
          // Add glow effect
          if (this.r < 50) {
            this.graphics.lineStyle(6, 0x00FFFF, opacity * 0.2);
            this.graphics.drawCircle(this.x, this.y, this.r);
          }
        }
        
        return this.alpha <= 0 || this.r > 300;
      }

      destroy() {
        this.graphics.visible = false;
        this.graphics.clear();
      }
    }

    const slowWavePool = new ObjectPool(
      () => new SlowWave(),
      (wave) => wave.destroy(),
      MAX_SLOW_WAVES
    );

    // ==================== CECE SPECIAL EFFECT CLASSES ====================
    class CeceParticle {
      constructor() {
        this.graphics = new PIXI.Graphics();
        gameContainer.addChild(this.graphics);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = 6 + Math.random() * 10;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.gravity = 0.25;
        this.friction = 0.97;
        this.life = 40 + Math.random() * 30;
        this.age = 0;
        this.r = 4 + Math.random() * 5;
        // 60% bright orange, 40% dark red
        this.color = Math.random() < 0.6 ? 0xFF3200 : 0xC80000;
        this.graphics.visible = true;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.vy += this.gravity;
        this.age++;
        
        const t = this.age / this.life;
        const alpha = t < 0.5 ? (t / 0.5) : (1 - (t - 0.5) / 0.5);
        
        this.graphics.clear();
        this.graphics.beginFill(this.color, alpha);
        this.graphics.drawCircle(this.x, this.y, this.r);
        this.graphics.endFill();
        
        return this.age >= this.life;
      }

      destroy() {
        this.graphics.visible = false;
        this.graphics.clear();
      }
    }

    const ceceParticlePool = new ObjectPool(
      () => new CeceParticle(),
      (particle) => particle.destroy(),
      60
    );

    class CeceSmoke {
      constructor() {
        this.graphics = new PIXI.Graphics();
        gameContainer.addChild(this.graphics);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.r = 25 + Math.random() * 30;
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 3;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed - 1.5; // Upward bias
        this.growth = 0.15 + Math.random() * 0.2;
        this.gravity = 0.04;
        this.friction = 0.97;
        this.life = 100 + Math.random() * 80;
        this.age = 0;
        this.graphics.visible = true;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.vy += this.gravity;
        this.r += this.growth;
        this.age++;
        
        const t = this.age / this.life;
        const alpha = t < 0.3 ? (t / 0.3) * 0.63 : (1 - (t - 0.3) / 0.7) * 0.63;
        
        this.graphics.clear();
        this.graphics.beginFill(0x141414, alpha);
        this.graphics.drawCircle(this.x, this.y, this.r);
        this.graphics.endFill();
        
        return this.age >= this.life;
      }

      destroy() {
        this.graphics.visible = false;
        this.graphics.clear();
      }
    }

    const ceceSmokePool = new ObjectPool(
      () => new CeceSmoke(),
      (smoke) => smoke.destroy(),
      60
    );

    class CeceMuzzleFlash {
      constructor() {
        this.graphics = new PIXI.Graphics();
        powerupEffectsLayer.addChild(this.graphics);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.life = 8;
        this.age = 0;
        this.graphics.visible = true;
      }

      update() {
        this.age++;
        const t = this.age / this.life;
        
        this.graphics.clear();
        
        // Core: white expanding circle
        const coreR = 30 * t;
        const coreAlpha = 1 - t;
        this.graphics.beginFill(0xFFFFFF, coreAlpha);
        this.graphics.drawCircle(this.x, this.y, coreR);
        this.graphics.endFill();
        
        // Outer glow: orange
        const glowR = 45 * t;
        this.graphics.beginFill(0xFF6400, 0.6);
        this.graphics.drawCircle(this.x, this.y, glowR);
        this.graphics.endFill();
        
        // Sparks: twelve rotating points for more dramatic effect
        const sparkR = 18 * t;
        const sparkCount = isMobile ? 6 : 12;
        for (let i = 0; i < sparkCount; i++) {
          const angle = (this.age * 0.3) + (Math.PI * 2 / 12) * i;
          const sx = this.x + Math.cos(angle) * sparkR;
          const sy = this.y + Math.sin(angle) * sparkR;
          const sparkSize = i % 2 === 0 ? 6 : 4; // Alternate sizes
          this.graphics.beginFill(0xFF9600, 1 - t * 0.7); // Stay more opaque
          this.graphics.drawCircle(sx, sy, sparkSize);
          this.graphics.endFill();
        }
        
        return this.age >= this.life;
      }

      destroy() {
        this.graphics.visible = false;
        this.graphics.clear();
      }
    }

    const ceceMuzzleFlashPool = new ObjectPool(
      () => new CeceMuzzleFlash(),
      (flash) => flash.destroy(),
      15
    );

    // ==================== EXPLOSION CLASS ====================
    class Explosion {
      constructor() {
        this.sprite = new PIXI.Graphics();
        gameContainer.addChild(this.sprite);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.life = 20;
        this.maxLife = 20;
        this.sprite.visible = true;
      }

      update() {
        this.life--;
        const scale = 1 + (this.maxLife - this.life) / this.maxLife;
        const alpha = this.life / this.maxLife;
        
        this.sprite.clear();
        this.sprite.beginFill(0xFF6600, alpha);
        this.sprite.drawCircle(this.x, this.y, 20 * scale);
        this.sprite.endFill();
        
        this.sprite.beginFill(0xFFFF00, alpha * 0.5);
        this.sprite.drawCircle(this.x, this.y, 10 * scale);
        this.sprite.endFill();
        
        return this.life <= 0;
      }
    }

    const explosionPool = new ObjectPool(
      () => new Explosion(),
      (explosion) => { explosion.sprite.visible = false; explosion.sprite.clear(); },
      MAX_EXPLOSIONS
    );

    // ==================== MUZZLE FLASH CLASS ====================
    class MuzzleFlash {
      constructor() {
        this.sprite = new PIXI.Graphics();
        gameContainer.addChild(this.sprite);
      }

      reset(x, y) {
        this.x = x;
        this.y = y;
        this.life = 10;
        this.sprite.visible = true;
      }

      update() {
        this.life--;
        const alpha = this.life / 10;
        const size = 20 + (10 - this.life) * 2;
        
        this.sprite.clear();
        this.sprite.lineStyle(2, 0xFFFF00, alpha);
        this.sprite.drawCircle(this.x, this.y, size);
        
        return this.life <= 0;
      }
    }

    const muzzleFlashPool = new ObjectPool(
      () => new MuzzleFlash(),
      (flash) => { flash.sprite.visible = false; flash.sprite.clear(); },
      20
    );

    // ==================== LOGO BURST EFFECT ====================
    class LogoParticle {
      constructor() {
        this.sprite = new PIXI.Graphics();
        gameContainer.addChild(this.sprite);
      }
      
      reset(x, y, vx, vy, color, life, size) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.size = size;
        this.sprite.visible = true;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.25; // gravity
        this.vx *= 0.995;
        this.vy *= 0.995;
        this.life--;
        
        const alpha = this.life / this.maxLife;
        this.sprite.clear();
        this.sprite.beginFill(this.color, alpha);
        this.sprite.drawCircle(this.x, this.y, this.size);
        this.sprite.endFill();
        
        return this.life <= 0;
      }
      
      destroy() {
        this.sprite.visible = false;
        this.sprite.clear();
      }
    }
    
    const logoParticlePool = new ObjectPool(
      () => new LogoParticle(),
      (particle) => particle.destroy(),
      60
    );
    
    function createLogoBurst() {
      if (!assets.restartLogo) {
        debugWarn('Logo burst asset not loaded, skipping animation');
        game.burstInProgress = false;
        return;
      }
      
      const cx = GAME_WIDTH / 2;
      const cy = GAME_HEIGHT / 2;
      const angle = Math.random() * Math.PI * 2;
      
      game.logo = {
        sprite: new PIXI.Sprite(assets.restartLogo),
        x: cx,
        y: cy,
        vx: Math.cos(angle) * 6.9, // 15% faster than 6
        vy: Math.sin(angle) * 6.9, // 15% faster than 6
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 0.207, // 15% faster rotation
        life: 120,
        maxLife: 120,
        size: 80, // Smaller base size
        scale: 0.6, // Start at 0.6x scale
        opacity: 1
      };
      
      game.logo.sprite.anchor.set(0.5);
      game.logo.sprite.x = cx;
      game.logo.sprite.y = cy;
      // Set sprite size based on base size
      const displaySize = game.logo.size * game.logo.scale;
      game.logo.sprite.width = displaySize;
      game.logo.sprite.height = displaySize;
      game.logo.sprite.alpha = 1;
      game.logo.sprite.visible = true;
      // Add to top of container for visibility
      gameContainer.addChild(game.logo.sprite);
      gameContainer.setChildIndex(game.logo.sprite, gameContainer.children.length - 1);
      
      // Create explosion particles matching logo colors (purple #8A2BE2 and cyan #00FFFF)
      game.logoParticles = [];
      const logoParticleCount = isMobile ? 20 : 60;
      for (let i = 0; i < logoParticleCount; i++) {
        const ang = Math.random() * Math.PI * 2; // Random angle for full 360 coverage
        const speed = Math.random() * 9 + 3;
        const px = Math.cos(ang) * speed;
        const py = Math.sin(ang) * speed;
        // Alternate between purple and cyan for visual variety
        const color = Math.random() < 0.5 ? 0x8A2BE2 : 0x00FFFF; // Purple or Cyan
        const life = Math.floor(Math.random() * 30 + 40);
        const size = Math.random() * 8 + 5; // Larger particles (5-13px)
        
        const particle = logoParticlePool.get();
        particle.reset(cx, cy, px, py, color, life, size);
        game.logoParticles.push(particle);
      }
      
      game.logoFlash = 30;
      game.logoShake = 15;
    }
    
    function updateLogoBurst() {
      if (game.logoFlash > 0) game.logoFlash--;
      
      // Update particles
      for (let i = game.logoParticles.length - 1; i >= 0; i--) {
        if (game.logoParticles[i].update()) {
          logoParticlePool.release(game.logoParticles[i]);
          game.logoParticles.splice(i, 1);
        }
      }
      
      // Update main logo
      if (game.logo) {
        const l = game.logo;
        l.x += l.vx;
        l.y += l.vy;
        l.vx *= 0.985;
        l.vy *= 0.985;
        l.rotation += l.rotSpeed;
        l.life--;
        
        // Scale animation: starts at 0.6, grows to 1.8, then shrinks back to 0.6
        const t = l.life / l.maxLife; // 1.0 at start, 0.0 at end
        const targetScale = 0.6 + (1.8 - 0.6) * Math.sin(t * Math.PI); // Smooth growth and shrink
        l.scale += (targetScale - l.scale) * 0.15;
        l.opacity = t; // Fade out as life decreases
        
        l.sprite.x = l.x;
        l.sprite.y = l.y;
        l.sprite.rotation = l.rotation;
        // Apply scale to base size
        const displaySize = l.size * l.scale;
        l.sprite.width = displaySize;
        l.sprite.height = displaySize;
        l.sprite.alpha = l.opacity;
        
        if (l.life <= 0) {
          gameContainer.removeChild(l.sprite);
          l.sprite.destroy();
          game.logo = null;
          debugLog('Logo expired, resetting burstInProgress');
          game.burstInProgress = false; // Reset immediately when logo expires
        }
      }
    }
    
    function renderLogoBurstFlash() {
      if (game.logoFlash > 0) {
        const t = game.logoFlash / 30; // 1.0 at start, 0.0 at end
        // Interpolate RGB from purple (138,43,226) to cyan (0,255,255)
        // At t=1 (start): full purple, at t=0 (end): full cyan
        const r = Math.floor(138 * t + 0 * (1 - t)); // 138 -> 0
        const g = Math.floor(43 * t + 255 * (1 - t)); // 43 -> 255
        const b = Math.floor(226 * t + 255 * (1 - t)); // 226 -> 255
        
        const intensity = t * 0.86; // Fade intensity from 86% to 0%
        const color = (r << 16) | (g << 8) | b;
        
        // Only apply if intensity is significant
        if (intensity > 0.1) {
          app.renderer.backgroundColor = color;
        }
      }
    }
    
    function startIntroBurst() {
      debugLog('startIntroBurst called, assets.restartLogo:', !!assets.restartLogo);
      
      if (!assets.restartLogo) {
        debugWarn('Skipping intro burst - asset not loaded');
        return;
      }
      
      game.burstInProgress = true;
      safePlay('powerup', 0.6, 1.0);
      setTimeout(() => {
        debugLog('Creating burst now');
        createLogoBurst();
      }, 300);
    }

    // ==================== GAME LOGIC ====================
    function incrementScore(isTarget, isRedCandle, isDestroyed = false) {
      // Calculate base score
      let baseScore = 1;
      if (isTarget) baseScore += 1;
      if (game.doubleScoreActive) baseScore *= 2;
      
      // Apply combo multiplier to score
      const scoreIncrease = baseScore * game.combo;
      
      const oldScore = game.score;
      game.score += scoreIncrease;
      
      // Deterministic speed scaling based on score progression
      const progressFactor = Math.min(game.score / 100, 1.0);
      let speedIncrease = SPEED_INCREMENT_MIN + (progressFactor * (SPEED_INCREMENT_MAX - SPEED_INCREMENT_MIN));
      
      // Lower speed ramping on mobile to prevent frame drops
      if (isMobile) speedIncrease *= 0.5;
      
      // If destroyed a red candle, apply increased speed (75% instead of 50%)
      if (isDestroyed && isRedCandle) {
        speedIncrease *= 0.75;
      }
      
      game.multiplier += speedIncrease;
      
      // Randomized combo system matching original game.html
      if (Math.random() < 0.35) {
        // 35% chance to reset combo (increased from 20%)
        game.combo = 1;
      } else if (Math.random() < 0.5) {
        // ~32.5% chance to increase by 1
        game.combo += 1;
      } else {
        // ~32.5% chance to increase by 2
        game.combo += 2;
      }
      // Randomize combo timer (60-180 frames = 1-3 seconds at 60fps)
      game.comboTimer = Math.floor(Math.random() * 120) + 60;
      game.comboFlash = 255;
      
      if (isRedCandle) {
        game.redCandlesPassed++;
        debugLog('Red candle passed! Total:', game.redCandlesPassed);
        if (game.redCandlesPassed % 5 === 0) {
          game.tbags++;
          debugLog('TBAG EARNED! Total tbags:', game.tbags);
          dom.tbagDisplay.textContent = game.tbags;
          
          if (game.tbags > game.tbagHighScore) {
            game.tbagHighScore = game.tbags;
            localStorage.setItem('tappyRocketTbagHighScore', game.tbagHighScore);
          }
          
          // Trigger graffiti animation
          triggerGraffiti();
        }
      }
      
      // Update high score if current score exceeds it
      if (game.score > game.highScore) {
        game.highScore = game.score;
        localStorage.setItem('tappyRocketHighScore', game.highScore);
        if (dom.hudHighScoreDisplay) {
          dom.hudHighScoreDisplay.textContent = game.highScore;
        }
      }
      
      dom.scoreDisplay.textContent = game.score;
      updateSpeedMeter();
    }

    function updateSpeedMeter() {
      const actualSpeed = game.multiplier * game.slowPermanentMultiplier;
      const effectiveMultiplier = Math.min(actualSpeed, 8);
      const ratio = effectiveMultiplier / 8;
      dom.speedValue.textContent = `${actualSpeed.toFixed(1)}x`;
      dom.speedBarFill.style.width = `${ratio * 100}%`;
    }

    function updateCombo() {
      if (game.comboTimer > 0) {
        game.comboTimer--;
      } else if (game.combo > 1) {
        game.combo = 1;
      }
      if (game.comboFlash > 0) {
        game.comboFlash -= 10;
      }
      dom.comboIndicator.textContent = `COMBO x${game.combo}`;
      dom.comboIndicator.style.opacity = 0.5 + 0.5 * (game.comboFlash / 255);
    }

    function triggerGraffiti() {
      if (!dom.graffitiImage) return;
      dom.graffitiImage.classList.add('active');
      setTimeout(() => {
        dom.graffitiImage.classList.remove('active');
      }, 700);
      safePlay('tbagsecured', 0.6, 1.0);
    }

    function spawnPipe() {
      // Random gap size between 200-250 (from backup reference)
      const gap = Math.random() * 50 + 200;
      // Random center position
      const center = Math.random() * (GAME_HEIGHT - gap) + gap / 2;
      // All pipes are red candles (for $TBAG counting)
      const isRed = true;
      
      const pipe = pipePool.get();
      pipe.reset(GAME_WIDTH, gap, center, isRed);
      pipe.nearMissChecked = false; // Track for near-miss detection
      game.pipes.push(pipe);
    }

    function fireBullet() {
      if (game.bullets.length >= MAX_BULLETS) return;
      
      const bullet = bulletPool.get();
      bullet.reset(game.bird.x + 15, game.bird.y, 8, 0);
      game.bullets.push(bullet);
      
      const shootPitch = 0.95 + Math.random() * 0.15; // Pitch variation (0.95-1.1)
      safePlay('shoot', 0.2, shootPitch);
    }

    function createParticles(x, y, count, color, options = {}) {
      let speedMin = options.speedMin || 1;
      let speedMax = options.speedMax || 3;
      let lifeMin = options.lifeMin || 30;
      let lifeMax = options.lifeMax || 50;
      const spread = options.spread || Math.PI * 2; // Full circle by default
      const direction = options.direction || 0; // Direction offset
      
      // Mobile optimizations: reduce particle count and lifetimes
      if (isMobile) {
        lifeMin *= 0.4;
        lifeMax *= 0.4;
        count = Math.max(1, Math.ceil(count * 0.3)); // Reduce to 30% of original
      }
      
      for (let i = 0; i < count && particlePool.active.length < MAX_PARTICLES; i++) {
        const angle = direction + (Math.random() - 0.5) * spread;
        const speed = Math.random() * (speedMax - speedMin) + speedMin;
        const particle = particlePool.get();
        particle.reset(
          x, y,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          color,
          lifeMin + Math.random() * (lifeMax - lifeMin)
        );
        game.particles.push(particle);
      }
    }

    function spawnPowerup() {
      if (powerupTimer > 0) return;
      
      // Get the last spawned pipe to align powerup with its gap
      const lastPipe = game.pipes[game.pipes.length - 1];
      if (!lastPipe) return;
      
      // Spawn chance decreases with speed but has minimum floor
      const speedFactor = game.speed / game.baseSpeed;
      let spawnChance = Math.max(0.90 / Math.sqrt(speedFactor), POWERUP_MIN_SPAWN_CHANCE);
      if (Math.random() > spawnChance) return;
      
      const types = ['gun', 'slow', 'double', 'invincibility', 'cece'];
      const weights = [0.10, 0.50, 0.20, 0.10, 0.10];
      
      let r = Math.random();
      let type = types[0];
      let sum = 0;
      for (let i = 0; i < types.length; i++) {
        sum += weights[i];
        if (r < sum) {
          type = types[i];
          break;
        }
      }
      
      // Position inside the pipe gap
      const x = lastPipe.x + lastPipe.w + Math.random() * 90 + 30;
      let y;
      if (lastPipe.bottom - lastPipe.top > 40) {
        y = Math.random() * (lastPipe.bottom - lastPipe.top - 40) + lastPipe.top + 20;
      } else {
        y = (lastPipe.top + lastPipe.bottom) / 2;
      }
      
      const powerup = powerupPool.get();
      powerup.reset(x, y, type);
      game.powerups.push(powerup);
      
      // Spawn effect particles
      createParticles(x, y, 6, 0xFFFFFF, { 
        speedMin: 1, 
        speedMax: 2, 
        lifeMin: 15, 
        lifeMax: 25 
      });
      
      powerupTimer = POWERUP_COOLDOWN_FRAMES;
    }

    function activatePowerup(type) {
      if (type === 'gun') {
        gunTimer = 360; // Reduced from 420 (1 second less at 60fps)
      } else if (type === 'slow') {
        slowTimer = 138;
        game.slowActive = true;
        game.slowFadeCounter = 0;
        game.slowWarpLevel = 1; // Start screen warp effect
        // Spawn initial slow wave
        if (game.slowWaves.length < MAX_SLOW_WAVES) {
          const wave = slowWavePool.get();
          wave.reset(game.bird.x, game.bird.y);
          game.slowWaves.push(wave);
        }
        // Play slow motion audio
        safePlay('slow', 0.6, 1.0);
      } else if (type === 'double') {
        doubleTimer = 600; // 10 seconds (added 0.5 seconds)
        game.doubleScoreActive = true;
        game.sherkAnim = 0; // Start sherk icon grow animation
        // Add minor speed boost for sherk
        game.baseSpeed *= 1.08;
        safePlay('sherk', 0.5, 0.95); // Play sherk sound (not powerup sound)
        // Cyan burst with sparkles
        createParticles(game.bird.x, game.bird.y, 12, 0x00FFFF, { speedMin: 2, speedMax: 5 });
        createParticles(game.bird.x, game.bird.y, 8, 0xFFFFFF, { speedMin: 3, speedMax: 6, lifeMin: 25, lifeMax: 40 });
        return; // Don't play generic powerup sound
      } else if (type === 'cece') {
        ceceTimer = 200;
        game.ceceActive = true;
        game.ceceLastShotFrame = frameCount - 26;
      } else if (type === 'invincibility') {
        invTimer = 212; // Reduced from 260 (0.8 seconds less at 60fps)
        game.invincible = true;
        game.flash = 100;
        game.flashColor = [0, 255, 255]; // Cyan flash for invincibility
        game.shake = 3;
        // Cyan burst with impact
        createParticles(game.bird.x, game.bird.y, 12, 0x00FFFF, { speedMin: 2, speedMax: 5 });
        createParticles(game.bird.x, game.bird.y, 8, 0xFF00FF, { speedMin: 3, speedMax: 6, lifeMin: 25, lifeMax: 40 });
        // Play invincibility theme (80s action track)
        safePlay('invincibility', 0.4, 0.9);
        return; // Don't play generic powerup sound
      }
      
      safePlay('powerup', 0.5, 1.0);
      game.flash = 80; // Flash for other powerups
      game.flashColor = [255, 255, 255]; // White flash
      game.shake = 4;
      // Rainbow burst with upward bias
      createParticles(game.bird.x, game.bird.y, 5, 0xFF00FF, { speedMin: 2, speedMax: 4, direction: -Math.PI/2, spread: Math.PI });
      createParticles(game.bird.x, game.bird.y, 5, 0x00FFFF, { speedMin: 2, speedMax: 4, direction: -Math.PI/2, spread: Math.PI });
      createParticles(game.bird.x, game.bird.y, 5, 0x00FF00, { speedMin: 2, speedMax: 4, direction: -Math.PI/2, spread: Math.PI });
    }

    function explodePipe(pipe, isCece = false) {
      const explosion = explosionPool.get();
      explosion.reset(pipe.x + pipe.w / 2, (pipe.top + pipe.bottom) / 2);
      game.explosions.push(explosion);
      
      const centerX = pipe.x + pipe.w / 2;
      const centerY = (pipe.top + pipe.bottom) / 2;
      
      if (isCece) {
        // Cece explosions: spawn only CeceParticle and CeceSmoke (no regular particles)
        const topY = pipe.top / 2;
        const bottomY = (GAME_HEIGHT + pipe.bottom) / 2;
        
        // Spawn Cece particles (red/orange sparks) - 10 for top segment, 10 for bottom
        const ceceParticleCount = isMobile ? 3 : 10;
        for (let i = 0; i < ceceParticleCount; i++) {
          const particle = ceceParticlePool.get();
          particle.reset(centerX, topY);
          game.ceceParticles.push(particle);
        }
        for (let i = 0; i < ceceParticleCount; i++) {
          const particle = ceceParticlePool.get();
          particle.reset(centerX, bottomY);
          game.ceceParticles.push(particle);
        }
        
        // Spawn Cece smoke (dark smoke puffs) - 10 for top, 10 for bottom
        const ceceSmokeCount = isMobile ? 3 : 10;
        for (let i = 0; i < ceceSmokeCount; i++) {
          const smoke = ceceSmokePool.get();
          smoke.reset(centerX, topY);
          game.ceceSmokes.push(smoke);
        }
        for (let i = 0; i < ceceSmokeCount; i++) {
          const smoke = ceceSmokePool.get();
          smoke.reset(centerX, bottomY);
          game.ceceSmokes.push(smoke);
        }
        
        game.shake = 8;
        game.flash = 255;
        game.flashColor = [255, 100, 0]; // Orange flash for Cece
      } else {
        // Regular explosions: outward burst with color gradient
        const expParticleCount1 = isMobile ? 3 : 10;
        const expParticleCount2 = isMobile ? 2 : 6;
        const expParticleCount3 = isMobile ? 1 : 4;
        createParticles(centerX, centerY, expParticleCount1, 0xFF6600, { speedMin: 2, speedMax: 4 });
        createParticles(centerX, centerY, expParticleCount2, 0xFFAA00, { speedMin: 3, speedMax: 5 });
        createParticles(centerX, centerY, expParticleCount3, 0xFFFF00, { speedMin: 1, speedMax: 3, lifeMin: 15, lifeMax: 25 });
        game.shake = 5;
        game.flash = 50;
        game.flashColor = [255, 255, 255]; // White flash for regular explosions
      }
      
      const explosionPitch = 0.9 + Math.random() * 0.2; // Pitch variation (0.9-1.1)
      const explosionVolume = isCece ? 0.55 : 0.4 + Math.random() * 0.1; // Louder for cece
      safePlay('explosion', explosionVolume, explosionPitch);
    }

    function gameOver() {
      game.over = true;
      game.shake = 10; // Screen shake on game over
      game.flash = 150;
      game.flashColor = [255, 255, 255]; // White flash

      // Stop all looping powerup audio
      if (game.invincibilityAudio) {
        try {
          game.invincibilityAudio.stop();
        } catch (e) {}
        game.invincibilityAudio = null;
      }
      
      // Update high score
      if (game.score > game.highScore) {
        game.highScore = game.score;
        localStorage.setItem('tappyRocketHighScore', game.highScore);
      }
      
      // Update UI
      dom.finalScoreDisplay.textContent = game.score;
      dom.finalHighScoreDisplay.textContent = game.highScore;
      dom.finalTbagDisplay.textContent = game.tbags;
      dom.finalTbagHighScoreDisplay.textContent = game.tbagHighScore;
      
      // Notify parent about game over and score
      window.parent.postMessage({
        type: 'SCORE_SUBMIT',
        payload: {
          score: game.score,
          highScore: game.highScore,
          tbags: game.tbags,
          timestamp: Date.now()
        }
      }, '*');
      
      // Submit score to leaderboard
      submitScoreToLeaderboard(game.score, game.tbags);
      
      // Load and display leaderboard
      loadLeaderboardIntoUI();
      
      dom.gameOverMenu.classList.remove('hidden');
      safePlay('hit', 0.5);
    }

    async function submitScoreToLeaderboard(score, tbags) {
      if (!walletAddress) return;
      
      const initials = prompt("Enter initials (optional, max 3 letters):");
      
      // User pressed cancel ‚Äî DO NOTHING
      if (initials === null) return;
      
      try {
        const res = await fetch("/api/leaderboard/submit", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            wallet: walletAddress,
            score,
            tbags: tbags || 0,
            initials: initials || ""
          })
        });
        
        const data = await res.json();
        
        if (!res.ok || !data.ok) {
          console.error("Score submission failed:", data);
        } else {
          debugLog("Score submitted successfully, total scores:", data.count);
          // Reload leaderboard to show new score
          await loadLeaderboardIntoUI();
        }
      } catch (error) {
        console.error("Error submitting score:", error);
      }
    }

    async function loadLeaderboardIntoUI() {
      try {
        const res = await fetch("/api/leaderboard/list");
        
        if (!res.ok) {
          console.error("Leaderboard list HTTP error", res.status);
          const list = document.getElementById("leaderboardList");
          list.innerHTML = '<li style="justify-content: center; opacity: 0.6;">Error loading</li>';
          return;
        }
        
        const data = await res.json();
        const list = document.getElementById("leaderboardList");
        
        if (!data || data.length === 0) {
          list.innerHTML = '<li style="justify-content: center; opacity: 0.6;">No scores yet</li>';
          return;
        }
        
        list.innerHTML = data
          .map((e, i) => `
            <li>
              <span>#${i + 1} ${e.initials ? e.initials : e.wallet.slice(0, 6)}</span>
              <span>${e.score}/${e.tbags || 0}</span>
            </li>
          `)
          .join("");
      } catch (error) {
        console.error("Error loading leaderboard:", error);
        const list = document.getElementById("leaderboardList");
        list.innerHTML = '<li style="justify-content: center; opacity: 0.6;">Error loading</li>';
      }
    }

    function initGame() {
      debugLog('=== INIT GAME CALLED ===');
      game.started = false;
      game.over = false;
      game.score = 0;
      game.tbags = 0;
      game.redCandlesPassed = 0;
      game.slowPermanentMultiplier = 1.0;
      game.baseSpeed = BASE_SPEED;
      game.speed = game.baseSpeed;
      game.multiplier = 1;
      game.combo = 1;
      game.comboTimer = 0;
      game.comboFlash = 0;
      game.slowActive = false;
      game.invincible = false;
      game.doubleScoreActive = false;
      game.ceceActive = false;
      game.shake = 0;
      game.flash = 0;
      game.flashColor = [255, 255, 255];
      game.logoFlash = 0;
      game.logoShake = 0;
      game.slowWarpLevel = 0;
      game.slowFadeCounter = 0;
      
      // Stop any audio loops
      if (game.invincibilityAudio) {
        try {
          game.invincibilityAudio.stop();
        } catch (e) {}
        game.invincibilityAudio = null;
      }
      
      // Clear logo burst if active
      if (game.logo && game.logo.sprite) {
        gameContainer.removeChild(game.logo.sprite);
        game.logo.sprite.destroy();
        game.logo = null;
      }
      
      // Clear pools
      pipePool.releaseAll();
      bulletPool.releaseAll();
      rocketPool.releaseAll();
      particlePool.releaseAll();
      powerupPool.releaseAll();
      explosionPool.releaseAll();
      muzzleFlashPool.releaseAll();
      slowWavePool.releaseAll();
      ceceParticlePool.releaseAll();
      ceceSmokePool.releaseAll();
      
      game.pipes = [];
      game.bullets = [];
      game.rockets = [];
      game.particles = [];
      game.powerups = [];
      game.explosions = [];
      game.muzzleFlashes = [];
      game.slowWaves = [];
      game.ceceParticles = [];
      game.ceceSmokes = [];
      
      // Create bird if it doesn't exist
      if (!game.bird) {
        game.bird = new Bird();
        if (assets.rocket) {
          game.bird.setTexture();
        }
      } else {
        game.bird.reset();
        if (assets.rocket) {
          game.bird.setTexture();
        }
        // Ensure bird sprite is added to container and visible
        if (!gameContainer.children.includes(game.bird.sprite)) {
          gameContainer.addChild(game.bird.sprite);
        }
        game.bird.sprite.visible = true;
      }
      
      // Add powerup effects layer on top of everything
      if (!gameContainer.children.includes(powerupEffectsLayer)) {
        gameContainer.addChild(powerupEffectsLayer);
      }
      
      // Reset timers
      gunTimer = 0;
      slowTimer = 0;
      doubleTimer = 0;
      ceceTimer = 0;
      invTimer = 0;
      lastPipeTime = 0;
      powerupTimer = 0;
      frameCount = 0;
      
      // Update UI
      dom.scoreDisplay.textContent = '0';
      dom.tbagDisplay.textContent = '0';
      dom.comboIndicator.textContent = 'COMBO x1';
      dom.comboIndicator.style.opacity = '0.8';
      updateSpeedMeter();
      
      // Clear floating texts
      floatingTexts.length = 0;
    }

    // ==================== WEB3 UI TOGGLE ====================
    
    function toggleWeb3DuringGameplay(isRunning) {
      const isMobileView = window.innerWidth <= 500;
      if (!isMobileView) return; // Only hide on mobile
      
      const web3 = document.getElementById('web3-ui');
      if (!web3) return;
      
      if (isRunning) {
        web3.classList.add('hidden-in-game');
      } else {
        web3.classList.remove('hidden-in-game');
      }
    }

    // ==================== SLOW EFFECTS ====================
    
    function updateSlowEffects() {
      // Spawn new waves while slow is active (every 10 frames for continuous ripples)
      if (game.slowActive && slowTimer > 0) {
        if (frameCount % 10 === 0 && game.slowWaves.length < MAX_SLOW_WAVES) {
          const wave = slowWavePool.get();
          wave.reset(game.bird.x, game.bird.y);
          game.slowWaves.push(wave);
        }
      }
      
      // Update fade counter for audio/visual effects
      game.slowFadeCounter++;
      const fadeDuration = 2.3 * 60; // frames for fade
      const ratio = Math.min(Math.max(game.slowFadeCounter / fadeDuration, 0), 1);
      game.slowWarpLevel = Math.max(0, 1 - ratio);
      
      // Update and render slow waves
      for (let i = game.slowWaves.length - 1; i >= 0; i--) {
        const wave = game.slowWaves[i];
        if (wave.update()) {
          slowWavePool.release(wave);
          game.slowWaves.splice(i, 1);
        }
      }
    }

    // ==================== POWERUP VISUAL EFFECTS ====================
    
    function updateFloatingTexts() {
      // Spawn new floating x2/x3/x4 texts during double score
      if (game.doubleScoreActive && doubleTimer > 0 && frameCount % 12 === 0 && game.bird) {
        // Prevent memory leak by capping array size
        if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
          floatingTexts.shift();
        }
        const choices = [2, 3, 4];
        const mult = choices[Math.floor(Math.random() * choices.length)];
        floatingTexts.push({
          x: game.bird.x + (Math.random() - 0.5) * 36,
          y: game.bird.y + (Math.random() - 0.5) * 32,
          alpha: 1,
          scale: Math.random() * 0.5 + 0.9,
          text: 'x' + mult
        });
      }
      
      // Update and remove faded texts
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y -= 0.5;
        t.alpha -= 0.02;
        if (t.alpha <= 0) {
          floatingTexts.splice(i, 1);
        }
      }
    }
    
    function renderPowerupIndicators() {
      powerupEffectsLayer.clear();
      powerupEffectsLayer.removeChildren();
      
      if (!game.bird || !game.started || game.over) return;
      
      const bx = game.bird.x;
      const by = game.bird.y;
      const birdSize = game.bird.size;
      
      // Slow motion visual - water ripple rings radiating from rocket
      if (game.slowActive && slowTimer > 0) {
        // Create multiple expanding ripple rings with varying opacity
        const time = frameCount * 0.08;
        
        // Ring 1 - Outermost
        const r1 = birdSize + 25 + Math.sin(time) * 8;
        const alpha1 = (0.6 + Math.sin(time) * 0.2) * game.slowWarpLevel;
        powerupEffectsLayer.lineStyle(3, 0x00E0FF, alpha1);
        powerupEffectsLayer.drawCircle(bx, by, r1);
        
        // Ring 2 - Middle
        const r2 = birdSize + 18 + Math.sin(time + 2) * 6;
        const alpha2 = (0.7 + Math.sin(time + 2) * 0.2) * game.slowWarpLevel;
        powerupEffectsLayer.lineStyle(2.5, 0x00C8FF, alpha2);
        powerupEffectsLayer.drawCircle(bx, by, r2);
        
        // Ring 3 - Inner
        const r3 = birdSize + 12 + Math.sin(time + 4) * 4;
        const alpha3 = (0.5 + Math.sin(time + 4) * 0.2) * game.slowWarpLevel;
        powerupEffectsLayer.lineStyle(2, 0x00AAFF, alpha3);
        powerupEffectsLayer.drawCircle(bx, by, r3);
        
        // Add a subtle glow fill
        const glowRadius = birdSize + 8;
        powerupEffectsLayer.beginFill(0x0099FF, 0.08 * game.slowWarpLevel);
        powerupEffectsLayer.drawCircle(bx, by, glowRadius);
        powerupEffectsLayer.endFill();
      }
      
      // Double score - rotating orbs
      if (game.doubleScoreActive && doubleTimer > 0) {
        // Speed factor based on actual game speed including slow powerup effect
        const currentSpeed = game.speed * (game.slowActive ? 0.25 : 1);
        const speedFactor = (currentSpeed / BASE_SPEED) * 2; // Increased from 0.5 to 2 for more visible effect
        
        // Outer ring - 6 dots, spinning fast, closer to rocket
        const outerR = birdSize + 28;
        const outerAngle = frameCount * 0.03 * speedFactor; // Further reduced base speed
        const outerDotCount = isMobile ? 4 : 6;
        for (let i = 0; i < outerDotCount; i++) {
          const a = outerAngle + (i * Math.PI * 2 / 6);
          const ox = bx + Math.cos(a) * outerR;
          const oy = by + Math.sin(a) * outerR;
          powerupEffectsLayer.beginFill(0xFFE066, 0.85);
          powerupEffectsLayer.drawCircle(ox, oy, 4);
          powerupEffectsLayer.endFill();
        }
        
        // Middle ring - 4 dots, spinning medium speed opposite direction
        const midR = birdSize + 20;
        const midAngle = -frameCount * 0.0225 * speedFactor; // Further reduced base speed
        const midDotCount = isMobile ? 2 : 4;
        for (let i = 0; i < midDotCount; i++) {
          const a = midAngle + (i * Math.PI * 2 / 4);
          const ox = bx + Math.cos(a) * midR;
          const oy = by + Math.sin(a) * midR;
          powerupEffectsLayer.beginFill(0xFFD040, 0.9);
          powerupEffectsLayer.drawCircle(ox, oy, 5);
          powerupEffectsLayer.endFill();
        }
        
        // Inner ring - 2 dots, spinning slowest
        const innerR = birdSize + 12;
        const innerAngle = frameCount * 0.015 * speedFactor; // Further reduced base speed
        for (let i = 0; i < 2; i++) {
          const a = innerAngle + (i * Math.PI);
          const ox = bx + Math.cos(a) * innerR;
          const oy = by + Math.sin(a) * innerR;
          powerupEffectsLayer.beginFill(0xFFFFAA, 0.95);
          powerupEffectsLayer.drawCircle(ox, oy, 6);
          powerupEffectsLayer.endFill();
        }
      }
      
      // Cece aura - pulsing red rings
      if (game.ceceActive && ceceTimer > 0) {
        const speedFactor = game.speed / game.baseSpeed;
        const baseRad = 55;
        const pulse = Math.sin(frameCount * 0.09 * speedFactor) * 8;
        const outerR = baseRad + pulse;
        const innerR = outerR + 15;
        
        // Outer ring - bright red
        powerupEffectsLayer.lineStyle(6, 0xFF0000, 0.78);
        powerupEffectsLayer.drawCircle(bx, by, outerR);
        
        // Inner ring - darker red
        powerupEffectsLayer.lineStyle(3, 0xC80000, 0.59);
        powerupEffectsLayer.drawCircle(bx, by, innerR);
      }
      
      // Invincibility shield aura
      if (game.invincible && invTimer > 0) {
        const speedFactor = game.speed / game.baseSpeed;
        // Primary cyan ring
        const base = birdSize + 10;
        const pulse = Math.sin(frameCount * 0.054 * speedFactor) * 5;
        const outer = base + pulse;
        
        powerupEffectsLayer.lineStyle(4, 0x00FFFF, 0.59);
        powerupEffectsLayer.drawCircle(bx, by, outer);
        
        // Secondary magenta ring
        const inner = base - 7 + Math.sin(frameCount * 0.054 * speedFactor + 1.5) * 5;
        powerupEffectsLayer.lineStyle(2, 0xFF66FF, 0.43);
        powerupEffectsLayer.drawCircle(bx, by, inner);
        
        // Draw shield sprite if available
        if (assets.invincibility && assets.invincibility.width) {
          const shieldSize = (birdSize * 2.0) * (0.9 + 0.15 * Math.sin(frameCount * 0.25));
          const shieldSprite = new PIXI.Sprite(assets.invincibility);
          shieldSprite.anchor.set(0.5);
          shieldSprite.x = bx;
          shieldSprite.y = by;
          shieldSprite.width = shieldSize;
          shieldSprite.height = shieldSize;
          shieldSprite.tint = 0x00FFFF;
          shieldSprite.alpha = 0.71;
          powerupEffectsLayer.addChild(shieldSprite);
        }
      }
      
      // Gun indicator - subtle glow (gun has no special visual in original, just bullets)
      if (gunTimer > 0) {
        powerupEffectsLayer.lineStyle(1, 0xFFFF00, 0.3);
        powerupEffectsLayer.drawCircle(bx, by, birdSize + 8);
      }
      
      // Draw animated rings around powerup pickups
      for (const powerup of game.powerups) {
        const osc = Math.sin(frameCount * 0.1);
        const baseSize = powerup.r * 2;
        const ring1 = baseSize + osc * 8 + 12;
        const ring2 = baseSize + osc * 8 + 20;
        
        // Outer ring
        const outerWidth = 3 + Math.sin(frameCount * 0.15) * 1.5;
        powerupEffectsLayer.lineStyle(outerWidth, 0x00FFFF, 0.71);
        powerupEffectsLayer.drawCircle(powerup.x, powerup.y, ring1 / 2);
        
        // Inner ring
        const innerWidth = 2 + Math.sin(frameCount * 0.15) * 1;
        powerupEffectsLayer.lineStyle(innerWidth, 0x00FFFF, 0.47);
        powerupEffectsLayer.drawCircle(powerup.x, powerup.y, ring2 / 2);
      }
      
      // Draw floating multiplier texts
      for (const t of floatingTexts) {
        const style = new PIXI.TextStyle({
          fontFamily: 'Barlow, sans-serif',
          fontSize: 20 * t.scale,
          fill: 0xFFFFFF,
          align: 'center'
        });
        const text = new PIXI.Text(t.text, style);
        text.anchor.set(0.5);
        text.x = t.x;
        text.y = t.y;
        text.alpha = t.alpha;
        powerupEffectsLayer.addChild(text);
      }
      
      // Sherk icon animation now handled in Bird.update()
    }

    function startGame() {
      debugLog('=== START GAME CALLED ===');

      if (!walletAddress) {
        alert('Connect your wallet first.');
        return;
      }

      // Reload credits from localStorage before starting game
      const savedCredits = localStorage.getItem('tappyCredits');
      if (savedCredits) {
        window.localCredits = parseInt(savedCredits, 10);
        updateCreditDisplay();
        debugLog('üéÆ Pre-game credit check:', window.localCredits);
      }

      if (typeof window.useCredit === 'function') {
        const ok = window.useCredit();
        if (!ok) {
          return;
        }
      }

      // Actually start the game
      doStartGame();
    }
    
    function doStartGame() {
      // Force audio
      forceAudioUnlock();
      
      // Notify parent that game is starting
      window.parent.postMessage({ 
        type: 'GAME_STARTED',
        payload: { timestamp: Date.now() }
      }, '*');

      // Start background music on first user interaction
      try {
        if (!bgMusicSource && sounds.background) {
          createBackgroundMusic();
        }
      } catch (err) {
        console.error('Failed to start background music:', err);
      }

      // Hide menus immediately
      debugLog('Hiding menus...');
      dom.startMenu.classList.add('hidden');
      dom.gameOverMenu.classList.add('hidden');
      debugLog('Menus hidden - startMenu has hidden class:', dom.startMenu.classList.contains('hidden'));
      
      // Reset game state first
      debugLog('Calling initGame()...');
      initGame();
      debugLog('initGame() completed');
      
      // Trigger logo burst
      debugLog('Calling startIntroBurst()...');
      startIntroBurst();
      debugLog('startIntroBurst() completed');
      
      // Start the game immediately so bird can be controlled
      game.started = true;
      game.over = false;
      debugLog('=== START GAME COMPLETE === game.started:', game.started, 'game.over:', game.over);
    }

    // ==================== SCREEN TRANSFORM EFFECTS ====================
    let displacementSprite = null;
    let displacementFilter = null;
    
    function initDisplacementFilter() {
      // Create a displacement map texture with water ripple pattern
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Create concentric ripple pattern
      const centerX = 256;
      const centerY = 256;
      const imageData = ctx.createImageData(512, 512);
      
      for (let y = 0; y < 512; y++) {
        for (let x = 0; x < 512; x++) {
          const dx = x - centerX;
          const dy = y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Create wave pattern based on distance
          const wave = Math.sin(distance * 0.08) * 127.5 + 127.5;
          
          // Add some directional displacement
          const angle = Math.atan2(dy, dx);
          const offsetX = Math.cos(angle) * wave;
          const offsetY = Math.sin(angle) * wave;
          
          const index = (y * 512 + x) * 4;
          imageData.data[index] = offsetX;     // Red channel for X displacement
          imageData.data[index + 1] = offsetY; // Green channel for Y displacement
          imageData.data[index + 2] = 128;     // Blue channel neutral
          imageData.data[index + 3] = 255;     // Alpha
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      displacementSprite = PIXI.Sprite.from(canvas);
      displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
      displacementSprite.anchor.set(0.5);
      displacementSprite.x = GAME_WIDTH / 2;
      displacementSprite.y = GAME_HEIGHT / 2;
      
      displacementFilter = new PIXI.DisplacementFilter(displacementSprite);
      displacementFilter.scale.x = 0;
      displacementFilter.scale.y = 0;
      
      app.stage.addChild(displacementSprite);
    }
    
    function applyScreenTransforms() {
      // Reset to identity transform first
      gameContainer.scale.set(1, 1);
      gameContainer.position.set(0, 0);
      gameContainer.pivot.set(0, 0);
      
      let totalShakeX = 0;
      let totalShakeY = 0;
      let applyZoom = false;
      let zoomScale = 1;
      
      // Logo burst zoom effect - simple smooth zoom in and out
      if (game.logoShake > 0 && !game.over) {
        // logoShake decays from 15 to 0
        const progress = game.logoShake / 15; // 1.0 to 0.0
        
        // Sine wave for smooth zoom in/out: starts at 0, peaks at 0.5, returns to 0
        const zoomCurve = Math.sin(progress * Math.PI);
        
        zoomScale = 1 + zoomCurve * 0.1; // Zoom from 1.0 to 1.1 and back
        applyZoom = true;
        
        // Force disable any filters during logo burst
        if (gameContainer.filters) {
          gameContainer.filters = null;
        }
      }
      // Apply water ripple displacement filter ONLY during slow powerup
      else if (game.slowActive && slowTimer > 0 && game.slowWarpLevel > 0 && !game.over) {
        if (!displacementFilter) initDisplacementFilter();
        
        const speedFactor = game.speed / game.baseSpeed;
        
        // Position displacement sprite at rocket's position for ripple origin
        if (displacementSprite && game.bird) {
          displacementSprite.x = game.bird.x;
          displacementSprite.y = game.bird.y;
          displacementSprite.rotation += 0.02;
          
          // Pulsing scale for animated effect - 70% slower, scales with game speed
          const spriteScale = 1.2 + Math.sin(frameCount * 0.018 * speedFactor) * 0.15;
          displacementSprite.scale.set(spriteScale);
        }
        
        // Enhanced ripple intensity with pulsing effect - 70% slower, scales with game speed
        const baseIntensity = game.slowWarpLevel * 35;
        const pulse = Math.sin(frameCount * 0.03 * speedFactor) * 0.5 + 0.5; // 0 to 1 oscillation
        const intensity = baseIntensity * (0.7 + pulse * 0.3); // Vary between 70% and 100%
        
        displacementFilter.scale.x = intensity;
        displacementFilter.scale.y = intensity * 0.9; // Slightly less vertical distortion
        
        gameContainer.filters = [displacementFilter];
      } else {
        if (gameContainer.filters) {
          gameContainer.filters = null;
        }
      }
      
      // Regular game shake only (logo has zoom, not shake)
      if (game.shake > 0 && !game.over) {
        totalShakeX += (Math.random() - 0.5) * game.shake * 2;
        totalShakeY += (Math.random() - 0.5) * game.shake * 2;
      }
      
      // Apply zoom first if needed (set pivot and base position)
      if (applyZoom) {
        gameContainer.pivot.set(GAME_WIDTH / 2, GAME_HEIGHT / 2);
        gameContainer.position.set(GAME_WIDTH / 2, GAME_HEIGHT / 2);
        gameContainer.scale.set(zoomScale, zoomScale);
      }
      
      // Apply accumulated shake on top of zoom
      if (totalShakeX !== 0 || totalShakeY !== 0) {
        gameContainer.position.x += totalShakeX;
        gameContainer.position.y += totalShakeY;
      }
    }

    // Update shake values at end of frame (after rendering)
    function updateShakeValues() {
      // Don't update shake after game over (let it freeze on final shake)
      if (game.over) return;
      
      if (game.logoShake > 0) {
        game.logoShake *= 0.9;
        if (game.logoShake < 0.5) {
          game.logoShake = 0;
        }
      }
      
      if (game.shake > 0) {
        game.shake *= game.shakeDecay;
        if (game.shake < 0.5) {
          game.shake = 0;
        }
      }
    }

    // ==================== GAME LOOP ====================
    app.ticker.add((delta) => {
      frameCount++;
      
      // Apply screen warp and shake transforms before rendering
      applyScreenTransforms();
      
      // Update logo burst effect (needs to run even when game not started)
      if (game.logo || game.logoParticles.length > 0 || game.logoFlash > 0 || game.logoShake > 0) {
        updateLogoBurst();
      }
      
      // Update background (always run for visual continuity)
      updateBackgroundLayers();
      updateStars();
      
      if (!game.started || game.over) return;
      
      // Countdown timers
      if (gunTimer > 0) gunTimer--;
      if (slowTimer > 0) {
        slowTimer--;
        if (slowTimer === 0) {
          game.slowActive = false;
          game.slowPermanentMultiplier *= 0.48875; // Reduced by 15% from 0.575 (0.575 * 0.85)
          updateSpeedMeter();
          debugLog(`Slow expired! Permanent multiplier: ${game.slowPermanentMultiplier.toFixed(2)}x`);
          slowTimer = -1;
        }
      }
      if (doubleTimer > 0) {
        doubleTimer--;
        if (doubleTimer === 0) game.doubleScoreActive = false;
      }
      if (ceceTimer > 0) {
        ceceTimer--;
        if (ceceTimer === 0) game.ceceActive = false;
      }
      if (invTimer > 0) {
        invTimer--;
        if (invTimer === 0) {
          game.invincible = false;
          // Stop invincibility audio when powerup expires
          if (game.invincibilityAudio) {
            game.invincibilityAudio.stop();
            game.invincibilityAudio = null;
          }
        }
      }
      if (powerupTimer > 0) powerupTimer--;
      
      // Update sherk animation
      if (game.sherkAnim !== null) {
        game.sherkAnim++;
        if (game.sherkAnim >= 60) {
          game.sherkAnim = null;
        }
      }
      
      // Update combo
      updateCombo();
      
      // Update speed for slow powerup (temporary 75% reduction + permanent multiplier)
      const targetSpeed = game.baseSpeed * game.multiplier * game.slowPermanentMultiplier * (game.slowActive ? 0.25 : 1);
      game.speed += (targetSpeed - game.speed) * 0.1;
      
      // Update bird
      game.bird.update();
      
      // Spawn pipes when none exist or last pipe is far enough left
      if (game.pipes.length === 0 || game.pipes[game.pipes.length - 1].x < GAME_WIDTH - 350) {
        spawnPipe();
        spawnPowerup();
      }
      
      // Update pipes
      for (let i = game.pipes.length - 1; i >= 0; i--) {
        const pipe = game.pipes[i];
        const offScreen = pipe.update();
        
        // Near-miss detection (tight squeeze past pipes)
        if (!pipe.nearMissChecked && game.bird.x > pipe.x && game.bird.x < pipe.x + pipe.w) {
          const collisionRadius = game.bird.size * 0.2; // Match collision detection
          const topClearance = game.bird.y - collisionRadius - pipe.collisionTop;
          const bottomClearance = pipe.collisionBottom - (game.bird.y + collisionRadius);
          
          if (topClearance < 30 || bottomClearance < 30) {
            // game.nearMissFlash = 150; // Disabled - no near-miss flash
            createParticles(game.bird.x, game.bird.y, 4, 0x00FFFF, { speedMin: 1, speedMax: 2, lifeMin: 15, lifeMax: 25 });
          }
          pipe.nearMissChecked = true;
        }
        
        // Check collision
        if (!game.invincible && game.bird.checkCollision(pipe)) {
          gameOver();
          // Enhanced crash particles with multiple colors and directions
          createParticles(game.bird.x, game.bird.y, 15, 0xFF0000, { speedMin: 3, speedMax: 6 }); // Red explosion
          createParticles(game.bird.x, game.bird.y, 10, 0xFF6600, { speedMin: 2, speedMax: 5 }); // Orange debris
          createParticles(game.bird.x, game.bird.y, 8, 0xFFFF00, { speedMin: 4, speedMax: 7, lifeMin: 20, lifeMax: 30 }); // Yellow sparks
          createParticles(game.bird.x, game.bird.y, 5, 0xFFFFFF, { speedMin: 5, speedMax: 8, lifeMin: 15, lifeMax: 25 }); // White flash
          return;
        }
        
        // Remove off-screen pipes
        if (offScreen) {
          pipePool.release(pipe);
          game.pipes.splice(i, 1);
        }
      }
      
      // Auto-fire gun
      if (gunTimer > 0 && frameCount % GUN_FIRE_INTERVAL === 0) {
        fireBullet();
        const flash = muzzleFlashPool.get();
        flash.reset(game.bird.x + 25, game.bird.y - 2);
        game.muzzleFlashes.push(flash);
      }
      
      // Auto-fire invincibility minigun
      if (game.invincible && invTimer > 0 && frameCount % INVINC_FIRE_INTERVAL === 0) {
        fireBullet();
        // Add small muzzle flash for mini-gun
        const flash = muzzleFlashPool.get();
        flash.reset(game.bird.x + game.bird.size, game.bird.y);
        game.muzzleFlashes.push(flash);
      }
      
      // Fire Cece rockets
      if (game.ceceActive && ceceTimer > 0) {
        if (frameCount - game.ceceLastShotFrame >= 15 && game.rockets.length < MAX_ROCKETS) {
          const rocket = rocketPool.get();
          const bx = game.bird.x + game.bird.size;
          const by = game.bird.y + game.bird.size / 2;
          rocket.reset(bx, by);
          game.rockets.push(rocket);
          
          // Spawn muzzle flash at launch point
          const flash = ceceMuzzleFlashPool.get();
          flash.reset(bx, by);
          game.ceceFlashes.push(flash);
          
          game.ceceLastShotFrame = frameCount;
          const rocketPitch = 0.75 + Math.random() * 0.15; // Much deeper missile sounds (was 0.95-1.15)
          safePlay('shoot', 0.45, rocketPitch); // Louder volume for heavy missiles
        }
      }
      
      // Update bullets
      for (let i = game.bullets.length - 1; i >= 0; i--) {
        const bullet = game.bullets[i];
        if (bullet.update()) {
          bulletPool.release(bullet);
          game.bullets.splice(i, 1);
          continue;
        }
        
        // Check bullet-pipe collisions
        for (let j = game.pipes.length - 1; j >= 0; j--) {
          const pipe = game.pipes[j];
          if (bullet.hits(pipe)) {
            explodePipe(pipe);
            pipePool.release(pipe);
            game.pipes.splice(j, 1);
            bulletPool.release(bullet);
            game.bullets.splice(i, 1);
            incrementScore(true, pipe.isRed, true); // isDestroyed = true
            break;
          }
        }
      }
      
      // Update rockets
      for (let i = game.rockets.length - 1; i >= 0; i--) {
        const rocket = game.rockets[i];
        if (rocket.update()) {
          rocketPool.release(rocket);
          game.rockets.splice(i, 1);
          continue;
        }
        
        // Check rocket-pipe collisions
        for (let j = game.pipes.length - 1; j >= 0; j--) {
          const pipe = game.pipes[j];
          if (rocket.hits(pipe)) {
            explodePipe(pipe, game.ceceActive && ceceTimer > 0);
            pipePool.release(pipe);
            game.pipes.splice(j, 1);
            rocketPool.release(rocket);
            game.rockets.splice(i, 1);
            incrementScore(true, pipe.isRed, true); // isDestroyed = true
            break;
          }
        }
      }
      
      // Update powerups
      for (let i = game.powerups.length - 1; i >= 0; i--) {
        const powerup = game.powerups[i];
        const offScreen = powerup.update(game);
        
        if (powerup.checkCollision(game.bird)) {
          activatePowerup(powerup.type);
          powerupPool.release(powerup);
          game.powerups.splice(i, 1);
        } else if (offScreen) {
          powerupPool.release(powerup);
          game.powerups.splice(i, 1);
        }
      }
      
      // Update explosions
      for (let i = game.explosions.length - 1; i >= 0; i--) {
        const explosion = game.explosions[i];
        if (explosion.update()) {
          explosionPool.release(explosion);
          game.explosions.splice(i, 1);
        }
      }
      
      // Update muzzle flashes
      for (let i = game.muzzleFlashes.length - 1; i >= 0; i--) {
        const flash = game.muzzleFlashes[i];
        if (flash.update()) {
          muzzleFlashPool.release(flash);
          game.muzzleFlashes.splice(i, 1);
        }
      }
      
      // Update particles
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const particle = game.particles[i];
        if (particle.update()) {
          particlePool.release(particle);
          game.particles.splice(i, 1);
        }
      }
      
      // Update Cece particles
      for (let i = game.ceceParticles.length - 1; i >= 0; i--) {
        const particle = game.ceceParticles[i];
        if (particle.update()) {
          ceceParticlePool.release(particle);
          game.ceceParticles.splice(i, 1);
        }
      }
      
      // Update Cece smoke
      for (let i = game.ceceSmokes.length - 1; i >= 0; i--) {
        const smoke = game.ceceSmokes[i];
        if (smoke.update()) {
          ceceSmokePool.release(smoke);
          game.ceceSmokes.splice(i, 1);
        }
      }
      
      // Update Cece muzzle flashes
      for (let i = game.ceceFlashes.length - 1; i >= 0; i--) {
        const flash = game.ceceFlashes[i];
        if (flash.update()) {
          ceceMuzzleFlashPool.release(flash);
          game.ceceFlashes.splice(i, 1);
        }
      }
      
      // Update slow motion wave effects
      updateSlowEffects();
      
      // Update floating multiplier texts
      updateFloatingTexts();
      
      // Update logo burst effect
      if (game.logo || game.logoParticles.length > 0 || game.logoFlash > 0 || game.logoShake > 0) {
        updateLogoBurst();
      }
      
      // Render powerup visual indicators
      renderPowerupIndicators();
      
      // Apply flash
      if (game.flash > 0) {
        game.flash -= 5;
        if (game.flash <= 0) {
          game.flash = 0;
          game.flashColor = [255, 255, 255]; // Reset to white when flash ends
        }
      }
      
      // Update near-miss flash (cyan tint)
      if (game.nearMissFlash > 0) {
        game.nearMissFlash -= 8;
        if (game.nearMissFlash < 0) game.nearMissFlash = 0;
      }
      
      // Update warning flash
      if (game.warningFlash > 0) {
        game.warningFlash -= 6;
        if (game.warningFlash < 0) game.warningFlash = 0;
      }
      
      // Render screen flash overlays
      app.renderer.backgroundColor = 0x000000;
      
      // Render logo burst flash first (lowest priority)
      renderLogoBurstFlash();
      
      // Overlay other flashes
      if (game.flash > 0 || game.nearMissFlash > 0) {
        const flashIntensity = game.flash / 255;
        const nearMissIntensity = game.nearMissFlash / 150;
        
        // Blend flashes: use flashColor for damage, cyan for near-miss
        if (flashIntensity > nearMissIntensity) {
          const r = Math.floor(game.flashColor[0] * flashIntensity);
          const g = Math.floor(game.flashColor[1] * flashIntensity);
          const b = Math.floor(game.flashColor[2] * flashIntensity);
          app.renderer.backgroundColor = (r << 16) | (g << 8) | b;
        } else if (nearMissIntensity > 0) {
          const cyan = Math.floor(255 * nearMissIntensity);
          app.renderer.backgroundColor = (cyan << 8) | cyan; // 0x00FFFF
        }
      }
      
      // Update shake values at end of frame
      updateShakeValues();
    });

    // ==================== INPUT HANDLING ====================
    function showTouchFeedback(x, y) {
      if (!dom.touchIndicator || !isMobile) return;
      
      dom.touchIndicator.style.left = x + 'px';
      dom.touchIndicator.style.top = y + 'px';
      dom.touchIndicator.classList.add('active');
      
      setTimeout(() => {
        dom.touchIndicator.classList.remove('active');
      }, 200);
    }
    
    function handleInput() {
      // Resume audio context only if not already running
      if (audioContext.state !== 'running') {
        audioContext.resume().catch(e => debugWarn('Audio resume failed:', e));
      }
      
      if (!game.started) {
        startGame();
      } else if (!game.over) {
        game.bird.flap();
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        handleInput();
      }
    });

    document.getElementById('game-container').addEventListener('click', handleInput);
    document.getElementById('game-container').addEventListener('touchstart', (e) => {
      e.preventDefault();
      
      // Show touch feedback at touch point
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        const rect = e.target.getBoundingClientRect();
        showTouchFeedback(touch.clientX - rect.left, touch.clientY - rect.top);
      }
      
      handleInput();
    }, { passive: false }); // passive: false allows preventDefault
    
    // Prevent double-tap zoom on mobile
    document.getElementById('game-container').addEventListener('touchend', (e) => {
      e.preventDefault();
    }, { passive: false });

    // Start menu handlers - use both click and touchstart for mobile reliability
    dom.startMenu.addEventListener('touchstart', (e) => {
      debugLog('=== START MENU TOUCHSTART ===');
      e.preventDefault();
      e.stopPropagation();
      if (audioContext.state !== 'running') {
        audioContext.resume().catch(err => debugWarn('Audio resume failed:', err));
      }
      startGame();
      debugLog('After startGame() - game.started:', game.started, 'game.over:', game.over);
    }, { passive: false });

    dom.startMenu.addEventListener('click', (e) => {
      debugLog('=== START MENU CLICKED ===');
      e.preventDefault();
      e.stopPropagation();
      if (audioContext.state !== 'running') {
        audioContext.resume().catch(err => debugWarn('Audio resume failed:', err));
      }
      startGame();
      debugLog('After startGame() - game.started:', game.started, 'game.over:', game.over);
    });

    // Restart button - use both click and touchend for reliability
    dom.restartButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      debugLog('=== RESTART TOUCHEND ===');
      forceAudioUnlock();
      startGame(); // Changed to consume credit on restart
    }, { passive: false });
    
    dom.restartButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      debugLog('=== RESTART CLICK ===');
      forceAudioUnlock();
      startGame(); // Changed to consume credit on restart
    });
    
    // Admin reset leaderboard button
    const adminResetBtn = document.getElementById('adminResetBtn');
    adminResetBtn.addEventListener('click', async () => {
      const adminToken = prompt("Enter admin token:");
      
      if (!adminToken) {
        return;
      }
      
      if (!confirm("Are you sure you want to reset the entire leaderboard?")) {
        return;
      }
      
      try {
        const res = await fetch("/api/leaderboard/reset", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: adminToken })
        });
        
        if (!res.ok) {
          const data = await res.json();
          console.error("Reset HTTP error", res.status, data);
          
          if (res.status === 403) {
            alert("Invalid admin token");
          } else if (res.status === 500 && data.error === 'admin-token-missing') {
            alert("Admin token not configured on server. Contact administrator.");
          } else {
            alert("Error resetting leaderboard: " + (data.error || "HTTP " + res.status));
          }
          return;
        }
        
        const data = await res.json();
        
        if (data.ok) {
          alert("Leaderboard reset successfully.");
          await loadLeaderboardIntoUI();
        } else {
          console.error("Reset failed", data);
          alert("Error resetting leaderboard: " + (data.error || "Unknown error"));
        }
      } catch (error) {
        console.error("Error resetting leaderboard:", error);
        alert("Error resetting leaderboard: " + error.message);
      }
    });

    // Music mute button
    const musicMuteButton = document.getElementById('musicMuteButton');
    musicMuteButton.addEventListener('click', (e) => {
      e.stopPropagation();
      game.musicMuted = !game.musicMuted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setMusicMuted(game.musicMuted);
      } else if (audioConfig.mode === AudioMode.WEBAUDIO) {
        if (bgMusicGain) {
          bgMusicGain.gain.value = game.musicMuted ? 0 : 0.2;
        }
        if (!game.musicMuted && !bgMusicSource && sounds.background) {
          createBackgroundMusic();
        }
      }
      
      musicMuteButton.classList.toggle('muted', game.musicMuted);
      startMusicBtn.classList.toggle('muted', game.musicMuted);
      gameoverMusicBtn.classList.toggle('muted', game.musicMuted);
      debugLog('Background music', game.musicMuted ? 'muted' : 'unmuted');
    });

    // Sound effects mute button
    const sfxMuteButton = document.getElementById('sfxMuteButton');
    sfxMuteButton.addEventListener('click', (e) => {
      e.stopPropagation();
      game.muted = !game.muted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setSfxMuted(game.muted);
      }
      
      sfxMuteButton.classList.toggle('muted', game.muted);
      startSfxBtn.classList.toggle('muted', game.muted);
      gameoverSfxBtn.classList.toggle('muted', game.muted);
      debugLog('Sound effects', game.muted ? 'muted' : 'unmuted');
    });

    // Menu audio buttons - Start Menu
    const startMusicBtn = document.getElementById('startMusicBtn');
    const startSfxBtn = document.getElementById('startSfxBtn');
    
    startMusicBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      game.musicMuted = !game.musicMuted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setMusicMuted(game.musicMuted);
      } else if (audioConfig.mode === AudioMode.WEBAUDIO) {
        if (!game.musicMuted && !bgMusicSource && sounds.background) {
          createBackgroundMusic();
        } else if (bgMusicGain) {
          bgMusicGain.gain.value = game.musicMuted ? 0 : 0.2;
        }
      }
      
      startMusicBtn.classList.toggle('muted', game.musicMuted);
      gameoverMusicBtn.classList.toggle('muted', game.musicMuted);
      musicMuteButton.classList.toggle('muted', game.musicMuted);
    });
    
    startSfxBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      game.muted = !game.muted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setSfxMuted(game.muted);
      }
      
      startSfxBtn.classList.toggle('muted', game.muted);
      gameoverSfxBtn.classList.toggle('muted', game.muted);
      sfxMuteButton.classList.toggle('muted', game.muted);
    });

    // Menu audio buttons - Game Over Menu
    const gameoverMusicBtn = document.getElementById('gameoverMusicBtn');
    const gameoverSfxBtn = document.getElementById('gameoverSfxBtn');
    
    gameoverMusicBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      game.musicMuted = !game.musicMuted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setMusicMuted(game.musicMuted);
      } else if (audioConfig.mode === AudioMode.WEBAUDIO) {
        if (!game.musicMuted && !bgMusicSource && sounds.background) {
          createBackgroundMusic();
        } else if (bgMusicGain) {
          bgMusicGain.gain.value = game.musicMuted ? 0 : 0.2;
        }
      }
      
      gameoverMusicBtn.classList.toggle('muted', game.musicMuted);
      startMusicBtn.classList.toggle('muted', game.musicMuted);
      musicMuteButton.classList.toggle('muted', game.musicMuted);
    });
    
    gameoverSfxBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      game.muted = !game.muted;
      
      if (audioConfig.mode === AudioMode.HTML5) {
        setSfxMuted(game.muted);
      }
      
      gameoverSfxBtn.classList.toggle('muted', game.muted);
      startSfxBtn.classList.toggle('muted', game.muted);
      sfxMuteButton.classList.toggle('muted', game.muted);
    });

    // ==================== INITIALIZATION ====================
    // Load high scores
    const storedHS = localStorage.getItem('tappyRocketHighScore');
    game.highScore = storedHS ? parseInt(storedHS, 10) : 0;
    if (dom.hudHighScoreDisplay) {
      dom.hudHighScoreDisplay.textContent = game.highScore;
    }

    const storedTbagHS = localStorage.getItem('tappyRocketTbagHighScore');
    game.tbagHighScore = storedTbagHS ? parseInt(storedTbagHS, 10) : 0;

    // PostMessage communication with parent frame
    let parentGameState = null;

    // Listen for messages from parent
    window.addEventListener('message', (event) => {
      // Allow all origins during development, add origin check for production
      // if (event.origin !== 'http://localhost:3000') return;

      const { type, payload } = event.data;
      debugLog('Game received message:', type, payload);

      switch (type) {
        case 'INIT_GAME':
          parentGameState = payload;
          debugLog('Parent game state received:', parentGameState);
          break;
        case 'START_GAME':
          if (!game.started && !game.over) {
            startGame();
          }
          break;
        case 'UPDATE_STATE':
          parentGameState = payload;
          break;
      }
    });

    // Notify parent that game is ready
    function notifyGameReady() {
      window.parent.postMessage({ type: 'GAME_READY' }, '*');
      debugLog('Game ready notification sent to parent');
    }

    // Initialize game after assets load
    initAudioLayer(); // Initialize audio system first
    loadAssets().then(() => {
      // Set bird texture after assets are loaded
      if (game.bird) {
        game.bird.setTexture();
      }
      initGame();
      // Start background music immediately after loading
      createBackgroundMusic();
      // Notify parent frame
      notifyGameReady();
    }).catch(() => {
      // Initialize anyway with fallback graphics
      initGame();
      // Notify parent frame even on error
      notifyGameReady();
    });
    
    // Register Service Worker for PWA with update notification
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(reg => {
            debugLog('Service Worker registered:', reg);
            
            // Check for updates
            reg.addEventListener('updatefound', () => {
              const newWorker = reg.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version available!
                  if (confirm('üéÆ New game version available! Reload to update?')) {
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch(err => console.error('Service Worker registration failed:', err));
      });
    }
  </script>
</body>
</html>


// DEBUG COLLISION





