<!DOCTYPE html>
<html lang="en" data-ui-version="2.8" data-econ-version="1.5">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gruesøme's arcade · Dashboard v2.8</title>
  <script>
    // Canonicalize: dashboard is the only user-facing URL.
    // If a host rewrites unknown paths to index.html, bounce back to '/'.
    (function(){
      try{
        if (window.top !== window.self) return;
        const p = String(location.pathname || '/');
        if (p === '/index.html') return location.replace('/');
        if (p !== '/') return location.replace('/');
      }catch{}
    })();
  </script>
  <!-- built by gruesøme -->
  <!-- SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f -->
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@200;400;600;700;800&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: dark;
      --bg0:#020617;
      --bg1: rgba(2,6,23,0.60);
      --panel: rgba(0,0,0,0.42);
      --panel2: rgba(15,23,42,0.62);
      --border: rgba(255,255,255,0.10);
      --border2: rgba(255,255,255,0.07);
      --text: rgba(229,231,235,0.96);
      --muted: rgba(229,231,235,0.72);
      --dim: rgba(229,231,235,0.55);
      --shadow: 0 22px 60px rgba(0,0,0,0.85);
      --r: 16px;
      --r2: 20px;
      --ease: cubic-bezier(0.16,1,0.3,1);

      /* Accent defaults (overridden per view) */
      --accent: #22d3ee;
      --accent2: rgba(34,211,238,0.30);
      --accent3: rgba(34,211,238,0.16);
      --good:#22c55e;
      --warn:#ffdd55;
      --bad:#ff4444;
    }

    /* Per-view accent theming */
    body[data-view="play"] { --accent:#22d3ee; --accent2:rgba(34,211,238,0.30); --accent3:rgba(34,211,238,0.16);}
    body[data-view="wallet"] { --accent:#a855f7; --accent2:rgba(168,85,247,0.30); --accent3:rgba(168,85,247,0.16);}
    body[data-view="leaderboard"] { --accent:#ffdd55; --accent2:rgba(255,221,85,0.30); --accent3:rgba(255,221,85,0.14);}
    body[data-view="proposals"] { --accent:#22c55e; --accent2:rgba(34,197,94,0.30); --accent3:rgba(34,197,94,0.14);}
    body[data-view="settings"] { --accent:#94a3b8; --accent2:rgba(148,163,184,0.30); --accent3:rgba(148,163,184,0.14);}

    *{box-sizing:border-box}
    html, body{height:100%;margin:0;background:radial-gradient(circle at top, var(--bg0) 0%, var(--bg0) 40%, #000 100%);font-family:'Barlow',system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--text);overflow:hidden;}

    /* 3D scene container */
    #scene{position:fixed;inset:0;z-index:0;}
    canvas{display:block;}

    /* Subtle grain (toggleable) */
    .grain{position:fixed;inset:-40px;z-index:2;pointer-events:none;opacity:0.16;mix-blend-mode:overlay;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.38'/%3E%3C/svg%3E");transform:translateZ(0);animation:grainMove 10s steps(2) infinite;}
    @keyframes grainMove{0%{transform:translate(0,0)} 25%{transform:translate(-18px,12px)} 50%{transform:translate(-8px,-14px)} 75%{transform:translate(12px,-8px)} 100%{transform:translate(0,0)}}
    body[data-grain="0"] .grain{display:none;}

    /* App shell */
    #app{position:fixed;inset:0;z-index:10;display:grid;grid-template-columns: 280px minmax(0,1fr);grid-template-rows: 70px minmax(0,1fr);grid-template-areas:"side top" "side main";}
    aside{grid-area:side;padding:18px 16px;background:rgba(2,6,23,0.82);backdrop-filter:blur(10px);border-right:1px solid rgba(255,255,255,0.06);}
    header{grid-area:top;padding:14px 16px;background:radial-gradient(circle at 20% 0%, var(--accent3) 0%, transparent 55%), rgba(2,6,23,0.62);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between;gap:12px;}
    main{grid-area:main;position:relative;padding:16px;overflow:auto;}

    /* Production: global network banner (sticky) */
    .netBanner{position:sticky;top:0;z-index:60;display:none;margin:0 0 12px;padding:10px 12px;border-radius:16px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.76);backdrop-filter:blur(10px);box-shadow:0 18px 55px rgba(0,0,0,0.55);}
    .netBanner.show{display:block;}
    .netBanner .a{font-weight:900;letter-spacing:0.10em;text-transform:uppercase;font-size:11px;}
    .netBanner .b{margin-top:4px;color:rgba(229,231,235,0.72);font-size:12px;line-height:1.35;}
    .netBanner.bad{border-color:rgba(255,68,68,0.35);background:rgba(255,68,68,0.10);}
    .netBanner.warn{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);}
    .netBanner.good{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);}

    .brand{padding:12px;border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(15,23,42,0.55);box-shadow:0 18px 50px rgba(0,0,0,0.55);}
    .brand .t{font-weight:800;letter-spacing:0.12em;text-transform:uppercase;font-size:14px;}
    .brand .s{margin-top:6px;color:var(--muted);font-size:12px;line-height:1.35;}

    .nav{margin-top:14px;display:flex;flex-direction:column;gap:8px;}
    .nav button{width:100%;text-align:left;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(15,23,42,0.55);color:rgba(229,231,235,0.90);font-size:12px;letter-spacing:0.10em;text-transform:uppercase;padding:10px 12px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:10px;transition:transform 180ms var(--ease), border-color 180ms var(--ease), background 180ms var(--ease);}
    .nav button:hover{transform:translateX(2px);border-color:var(--accent2);background:rgba(15,23,42,0.70);}
    .nav button.active{border-color:rgba(255,255,255,0.14);background:linear-gradient(90deg, var(--accent3), rgba(15,23,42,0.62));}
    .nav .hint{margin-top:6px;color:rgba(229,231,235,0.55);font-size:11px;line-height:1.35;}

    /* Topbar chips */
    .topLeft{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
    h1{margin:0;font-size:14px;font-weight:800;letter-spacing:0.12em;text-transform:uppercase;}
    .sub{margin-top:4px;color:var(--muted);font-size:12px;}

    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:7px 10px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(15,23,42,0.52);color:rgba(229,231,235,0.86);white-space:nowrap;}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(148,163,184,0.85);box-shadow:0 0 0 3px rgba(148,163,184,0.12);}
    .chip.good{border-color:rgba(34,197,94,0.42);background:rgba(22,163,74,0.12);color:rgba(187,247,208,0.95);}
    .chip.good .dot{background:rgba(34,197,94,0.95);box-shadow:0 0 0 3px rgba(34,197,94,0.16),0 0 16px rgba(34,197,94,0.22);}
    .chip.warn{border-color:rgba(255,221,85,0.35);background:rgba(255,221,85,0.10);color:rgba(255,240,196,0.95);}
    .chip.warn .dot{background:rgba(255,221,85,0.95);box-shadow:0 0 0 3px rgba(255,221,85,0.14),0 0 16px rgba(255,221,85,0.20);}
    .chip.bad{border-color:rgba(255,68,68,0.35);background:rgba(255,68,68,0.10);color:rgba(254,202,202,0.95);}
    .chip.bad .dot{background:rgba(255,68,68,0.95);box-shadow:0 0 0 3px rgba(255,68,68,0.12),0 0 16px rgba(255,68,68,0.18);}

    .topRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end;}
    .btn{border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(15,23,42,0.58);color:rgba(229,231,235,0.92);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;padding:10px 12px;cursor:pointer;transition:transform 160ms var(--ease), border-color 160ms var(--ease), background 160ms var(--ease);user-select:none;display:inline-flex;align-items:center;gap:8px;white-space:nowrap;}
    .btn:hover{transform:translateY(-1px);border-color:var(--accent2);background:rgba(15,23,42,0.72);}
    .btn.primary{border-color:rgba(255,255,255,0.14);background:linear-gradient(90deg, var(--accent3), rgba(15,23,42,0.62));}
    .btn.ghost{background:transparent;}

    /* Views */
    .view{display:none;animation:viewIn 260ms var(--ease) both;position:relative;overflow:hidden;}
    .view.active{display:block;}
    .view::before{content:'';position:absolute;inset:0;pointer-events:none;opacity:0.20;mix-blend-mode:screen;filter:saturate(1.15);background:radial-gradient(700px 420px at 30% 0%, rgba(88,101,242,0.22), rgba(0,0,0,0));}
    #view-play::before{background:radial-gradient(700px 420px at 22% 0%, rgba(88,101,242,0.22), rgba(0,0,0,0));}
    #view-wallet::before{background:radial-gradient(700px 420px at 78% 0%, rgba(34,211,238,0.20), rgba(0,0,0,0));}
    #view-leaderboard::before{background:radial-gradient(700px 420px at 50% 0%, rgba(251,191,36,0.18), rgba(0,0,0,0));}
    #view-proposals::before{background:radial-gradient(700px 420px at 30% 0%, rgba(244,114,182,0.18), rgba(0,0,0,0));}
    #view-profile::before{background:radial-gradient(700px 420px at 72% 0%, rgba(167,139,250,0.18), rgba(0,0,0,0));}
    .view > *{position:relative;z-index:1;}
    @keyframes viewIn{from{opacity:0;transform:translateY(6px) scale(0.995);}to{opacity:1;transform:translateY(0) scale(1);}}

    .viewHeader{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:12px;}
    .viewHeader .h{font-size:13px;font-weight:800;letter-spacing:0.14em;text-transform:uppercase;margin:0;}
    .viewHeader .p{margin:6px 0 0;color:var(--muted);font-size:12px;max-width:60ch;}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:6px 10px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.50);color:rgba(229,231,235,0.84);white-space:nowrap;}
    .pill strong{color:rgba(229,231,235,0.95);}

    .grid{display:grid;grid-template-columns: 1.55fr 1fr;gap:14px;align-items:start;}
    .card{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(2,6,23,0.48);backdrop-filter:blur(10px);box-shadow:var(--shadow);overflow:hidden;position:relative;transition:transform .18s ease, border-color .18s ease, box-shadow .18s ease;}
    .card::before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 20% 0%, var(--accent3), transparent 55%);opacity:0.7;pointer-events:none;}
    .card:hover{transform:translateY(-1px);border-color:rgba(255,255,255,0.14);box-shadow:0 18px 55px rgba(0,0,0,0.55);}
    .card:active{transform:translateY(0px);}

    .inner{padding:14px;position:relative;display:flex;flex-direction:column;gap:12px;}
    .card h3{margin:0;font-size:12px;font-weight:800;letter-spacing:0.12em;text-transform:uppercase;}
    .muted{color:var(--muted);font-size:12px;}

    .kv{display:grid;grid-template-columns:140px 1fr;gap:8px 10px;align-items:center;font-size:12px;}
    .k{color:rgba(229,231,235,0.58);letter-spacing:0.08em;text-transform:uppercase;font-size:10px;}
    .v{font-weight:800;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-variant-numeric:tabular-nums;}
    .v small{font-weight:700;color:var(--muted);}

    .split{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .bar{border:1px solid rgba(255,255,255,0.08);border-radius:14px;background:rgba(15,23,42,0.55);overflow:hidden;}
    .bar > div{height:10px;width:0;background:linear-gradient(90deg, var(--accent2), rgba(255,255,255,0.06));transition:width 380ms var(--ease);}

    /* Play view */
    .portal{height:clamp(420px, 72vh, 780px);border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(2,6,23,0.55);overflow:hidden;position:relative;}
    .portal iframe{width:100%;height:100%;border:0;display:block;background:#000;}
    .portalTop{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none;}
    .portalTop .pill{pointer-events:auto;}
    .portalBottom{position:absolute;bottom:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;pointer-events:none;}
    .portalBottom .btn{pointer-events:auto;}

    .playGrid{display:grid;grid-template-columns:1fr;gap:14px;}
    .playLower{display:grid;grid-template-columns:1fr;gap:14px;}


    .gameTiles{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;}
    .gameTile{border:1px solid rgba(255,255,255,0.10);border-radius:16px;background:rgba(15,23,42,0.55);padding:10px;cursor:pointer;display:flex;flex-direction:column;gap:6px;transition:transform 180ms var(--ease), border-color 180ms var(--ease), background 180ms var(--ease);min-height:78px;position:relative;overflow:hidden;}
    .gameTile::before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 20% 0%, var(--accent3), transparent 65%);opacity:0.65;pointer-events:none;}
    .gameTile:hover{transform:translateY(-2px);border-color:var(--accent2);background:rgba(15,23,42,0.70);}
    .gameTile.active{border-color:rgba(255,255,255,0.16);background:linear-gradient(90deg,var(--accent3),rgba(15,23,42,0.62));}
    .gameTile.disabled{opacity:0.55;cursor:not-allowed;transform:none;}
    .gameTile .n{font-weight:900;letter-spacing:0.10em;text-transform:uppercase;font-size:11px;position:relative;}
    .gameTile .d{color:rgba(229,231,235,0.70);font-size:11px;line-height:1.35;position:relative;}
    .gameTile .meta{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;position:relative;margin-top:auto;}
    .gameTile .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.84);}
    .gameTile .badge.live{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .gameTile .badge.soon{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}
    @media (max-width: 980px){.gameTiles{grid-template-columns:1fr;}}


    .txFeed{display:flex;flex-direction:column;gap:8px;}
    .txItem{border:1px solid rgba(255,255,255,0.08);border-radius:14px;background:rgba(15,23,42,0.55);padding:10px 12px;display:flex;justify-content:space-between;gap:12px;align-items:flex-start;}
    .txItem .l{font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:rgba(229,231,235,0.84);}
    .txItem .s{margin-top:4px;color:rgba(229,231,235,0.62);font-size:11px;}
    .txItem .r{text-align:right;font-size:11px;color:rgba(229,231,235,0.72);white-space:nowrap;}
    .txTag{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);}
    .txTag.ok{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .txTag.pend{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}

    /* Wallet view */
    .buyGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    .buyGrid .panel{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:10px;}
    .row{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:baseline;}
    input[type="number"], input[type="text"], textarea, select{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.55);color:var(--text);outline:none;font-family:inherit;}
    input[type="range"]{width:100%;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;}
    .tab{padding:7px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.45);cursor:pointer;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:rgba(229,231,235,0.86);user-select:none;}
    .tab.active{border-color:var(--accent2);background:linear-gradient(90deg,var(--accent3),rgba(2,6,23,0.45));}
    .preset{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:8px;}
    .chipBtn{border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:8px 10px;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.90);cursor:pointer;text-align:center;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;user-select:none;}
    .chipBtn:hover{border-color:var(--accent2);}
    .chipBtn:active{transform:translateY(1px);}


    .tier{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:10px;}
    .tier .name{font-weight:800;letter-spacing:0.10em;text-transform:uppercase;font-size:12px;}
    .tier .price{font-size:18px;font-weight:900;letter-spacing:0.02em;font-variant-numeric:tabular-nums;}
    .tier ul{margin:0;padding-left:18px;color:rgba(229,231,235,0.84);font-size:12px;}
    .tier li{margin:6px 0;}
    .avatarWrap{display:grid;grid-template-columns: 180px 1fr;gap:12px;align-items:start;}
    .avatarCard{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(2,6,23,0.55);padding:12px;}
    .avatarSvg{width:100%;height:auto;border-radius:14px;border:1px solid rgba(255,255,255,0.08);background:rgba(0,0,0,0.25);}
    .pulse{position:relative;}
    .pulse::after{content:"";position:absolute;inset:-6px;border-radius:18px;border:1px solid var(--accent2);box-shadow:0 0 0 3px rgba(255,255,255,0.03), 0 0 22px var(--accent3);opacity:0;animation:pulse 1.6s var(--ease) infinite;}
    @keyframes pulse{0%{opacity:0;transform:scale(0.98);} 40%{opacity:1;} 100%{opacity:0;transform:scale(1.03);}}

    /* Leaderboard */
    table{width:100%;border-collapse:collapse;font-size:12px;}
    th, td{text-align:left;padding:10px 8px;border-bottom:1px solid rgba(255,255,255,0.07);}
    th{color:rgba(229,231,235,0.62);letter-spacing:0.10em;text-transform:uppercase;font-size:10px;}
    tbody tr:hover{background:rgba(255,255,255,0.03);}
    .rank{font-weight:900;font-variant-numeric:tabular-nums;}
    .mono{font-variant-numeric:tabular-nums;}

    /* Proposals */
    textarea{min-height:90px;resize:vertical;}
    .proposal{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:8px;}
    .proposal .top{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;}
    .proposal .title{font-weight:900;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;}
    .proposal .desc{color:rgba(229,231,235,0.78);font-size:12px;line-height:1.4;}
    .tag{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);}
    .tag.good{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .tag.warn{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}

    /* Overlays */
    .overlay{position:fixed;inset:0;z-index:200;display:none;align-items:center;justify-content:center;background:
      radial-gradient(circle at 50% 20%, rgba(34,211,238,0.10) 0%, transparent 60%),
      linear-gradient(180deg, rgba(2,6,23,0.35) 0%, rgba(0,0,0,0.72) 100%);
      backdrop-filter: blur(10px);
      overscroll-behavior:contain;
      overflow:auto;
      padding:
        calc(12px + env(safe-area-inset-top))
        calc(12px + env(safe-area-inset-right))
        calc(12px + env(safe-area-inset-bottom))
        calc(12px + env(safe-area-inset-left));
    }
    .overlay.show{display:flex;}
    /* Modal stays fixed in viewport; content scrolls inside modalBody */
    .modal{width:min(980px, calc(100% - 24px));border:1px solid rgba(255,255,255,0.10);border-radius:24px;background:rgba(2,6,23,0.72);box-shadow:0 30px 90px rgba(0,0,0,0.90);overflow:hidden;animation:modalIn 240ms var(--ease) both;max-height:calc(100vh - 24px);max-height:calc(100dvh - 24px);display:flex;flex-direction:column;margin:auto;}
    @keyframes modalIn{from{transform:translateY(10px) scale(0.99);opacity:0;}to{transform:translateY(0) scale(1);opacity:1;}}
    .modalHead{padding:14px 14px;border-bottom:1px solid rgba(255,255,255,0.06);display:flex;justify-content:space-between;gap:10px;align-items:center;background:radial-gradient(circle at 20% 0%, var(--accent3) 0%, transparent 60%), rgba(2,6,23,0.55);}
    .modalHead .t{font-weight:900;letter-spacing:0.12em;text-transform:uppercase;font-size:12px;}
    .modalBody{padding:14px;display:grid;grid-template-columns: 1.1fr 0.9fr;gap:12px;align-items:start;flex:1;min-height:0;overflow:auto;}
    .modalBody .panel{border:1px solid rgba(255,255,255,0.08);border-radius:18px;background:rgba(15,23,42,0.55);padding:12px;}
    .modalFoot{padding:12px 14px;border-top:1px solid rgba(255,255,255,0.06);display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;background:rgba(2,6,23,0.55);}
    .closeX{border:1px solid rgba(255,255,255,0.10);border-radius:999px;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.92);cursor:pointer;padding:8px 10px;letter-spacing:0.08em;text-transform:uppercase;font-size:11px;}
    .closeX:hover{border-color:var(--accent2);}

    /* When an overlay is open, block interaction + scrolling behind it */
    body.modalOpen #app{pointer-events:none;}
    body.modalOpen main{overflow:hidden !important;}
    body.modalOpen .overlay{pointer-events:auto;}

    #toastHost{position:fixed;right:calc(14px + env(safe-area-inset-right));bottom:calc(14px + env(safe-area-inset-bottom));z-index:220;display:flex;flex-direction:column;gap:8px;pointer-events:none;}
    .toast{border:1px solid rgba(255,255,255,0.10);border-radius:16px;background:rgba(2,6,23,0.82);padding:10px 12px;min-width:240px;box-shadow:0 18px 50px rgba(0,0,0,0.75);pointer-events:none;animation:toastIn 220ms var(--ease) both;}
    .toast .a{font-weight:900;letter-spacing:0.08em;text-transform:uppercase;font-size:11px;}
    .toast .b{margin-top:4px;color:rgba(229,231,235,0.72);font-size:12px;line-height:1.35;}
    @keyframes toastIn{from{transform:translateY(8px) scale(0.99);opacity:0;}to{transform:translateY(0) scale(1);opacity:1;}}

    @media (max-width: 980px) {
      #app{grid-template-columns:1fr;grid-template-rows:70px auto minmax(0,1fr);grid-template-areas:"top" "side" "main";}
      aside{border-right:none;border-bottom:1px solid rgba(255,255,255,0.06);padding:12px 10px;}
      header{padding:12px 10px;}
      main{padding:12px 10px;}
      .brand .s{display:none;}
      .nav{flex-direction:row;gap:8px;flex-wrap:wrap;}
      .nav button{flex:1;min-width:140px;justify-content:center;text-align:center;min-height:44px;}
      .btn{min-height:44px;}
      .grid{grid-template-columns:1fr;}
      .modalBody{grid-template-columns:1fr;}
      .buyGrid{grid-template-columns:1fr;}
      .preset{grid-template-columns:repeat(2,minmax(0,1fr));}
      .avatarWrap{grid-template-columns:1fr;}
      .portal{height:clamp(320px, 60vh, 620px);}

      /* Mobile: simplify header clutter (desktop remains primary) */
      #chipCredits, #chipEpoch{display:none;}
      .topLeft, .topRight{gap:8px;}
      .chip{padding:6px 9px;font-size:10px;}
      header{align-items:flex-start;}
    }

    /* Small mobile phones: keep it simple and touch-friendly */
    @media (max-width: 560px) {
      html, body{overflow:hidden;}
      main{-webkit-overflow-scrolling:touch;}
      .nav button{min-width:110px;padding:10px 10px;}
      .viewHeader{margin-bottom:10px;}
      .viewHeader .p{max-width:unset;}
      .portal{height:clamp(280px, 58vh, 520px);}
      .portalBottom{flex-direction:column;align-items:stretch;gap:8px;}
      .portalBottom .btn{width:100%;justify-content:center;}
      .portalBottom > div{width:100%;}
      .portalBottom > div .btn{flex:1;}
      .gameTile{min-height:66px;padding:9px;}
      .gameTile .d{display:none;}
      #toastHost{left:calc(12px + env(safe-area-inset-left));right:calc(12px + env(safe-area-inset-right));}
      .toast{min-width:unset;width:100%;}
    }

    @media (prefers-reduced-motion: reduce) {
      *{scroll-behavior:auto !important;}
      .grain{animation:none !important;}
      .view{animation:none !important;}
      .btn,.nav button{transition:none !important;}
    }
  
    .hr{height:1px;background:rgba(255,255,255,0.08);margin:12px 0;border-radius:999px;}
    /* v2.8: claim-ready pulse + lottery subtle emphasis */
    @keyframes pulseGlow {
      0%{ box-shadow: 0 0 0 0 rgba(34,211,238,0.00); }
      40%{ box-shadow: 0 0 0 6px rgba(34,211,238,0.12); }
      100%{ box-shadow: 0 0 0 0 rgba(34,211,238,0.00); }
    }
    .pulse { animation: pulseGlow 1.25s ease-in-out infinite; }
    .txFeed .txItem.winner { border-color: rgba(255,221,85,0.22); background: linear-gradient(90deg, rgba(255,221,85,0.10), rgba(15,23,42,0.58)); }

    /* Access gate overlay (Starfield) */
    #accessGateOverlay{position:fixed;inset:0;z-index:9999;background:#000;opacity:1;visibility:visible;pointer-events:auto;will-change:opacity;transition:opacity 720ms var(--ease), visibility 720ms var(--ease);}
    #accessGateOverlay.is-hidden{opacity:0;visibility:hidden;pointer-events:none;}
    #accessGateFrame{width:100vw;height:100vh;border:0;display:block;background:#000;}

    /* When access is granted, dock the gate into the sidebar header slot */
    #accessDock{display:none;position:relative;width:240px;height:80px;border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:#000;overflow:hidden;box-shadow:0 18px 50px rgba(0,0,0,0.55);}
    #accessDock iframe{position:absolute;inset:0;width:100%;height:100%;border:0;display:block;background:#000;}
     /* Keep the docked header crisp: avoid iframe scaling (can look blurry).
       Any size/fit tweaks should happen inside the embedded header page. */
     #accessDockHeaderFrame{left:0;top:0;width:100%;height:100%;transform:translateZ(0) scale(1);transform-origin:50% 50%;will-change:transform;}
    body.hasDockedGate #accessDock{display:block;}

    .sidebarChips{display:flex;flex-direction:column;gap:8px;margin:10px 0 12px;}
    .sidebarChips .chip{white-space:normal;justify-content:flex-start;}

    /* Helps the dock animation feel smoother on some GPUs */
    #accessDock{contain:layout paint;}
    body.hasDockedGate .brand{display:none;}

</style>

  <link rel="prefetch" href="access/header_240x80.html?v=3.4.1" as="document">
</head>
<body data-view="play" data-grain="1">
  <div id="accessGateOverlay" aria-label="Access gate" role="dialog">
    <iframe id="accessGateFrame" title="Access" src="access/" allow="clipboard-read; clipboard-write"></iframe>
  </div>

  <div id="scene" aria-hidden="true"></div>
  <div class="grain" aria-hidden="true"></div>

  <div id="app" role="application" aria-label="Arcade Dashboard">
    <aside>
      <div id="accessDock" aria-label="Access header"></div>
      <div class="sidebarChips" aria-label="Status">
        <span class="chip warn" id="chipWallet"><span class="dot"></span><span id="chipWalletT">Wallet: not connected</span></span>
        <span class="chip warn" id="chipPOH"><span class="dot"></span><span id="chipPOHT">POH: not verified</span></span>
      </div>
      <div class="brand">
        <div class="t">gruesøme's arcade</div>
        <div class="s">Single-page dashboard · access-gated · v2.8<br/>Credits are the universal currency (1 Credit = $0.01).</div>
      </div>

      <div class="nav" aria-label="Navigation">
        <button class="active" data-nav="play"><span>Play</span><span>⟡</span></button>
        <button data-nav="wallet"><span>Wallet</span><span>◈</span></button>
        <button data-nav="leaderboard"><span>Leaderboard</span><span>⌁</span></button>
        <button data-nav="proposals"><span>Suggestions</span><span>✦</span></button>
        <button data-nav="settings"><span>Settings</span><span>⚙</span></button>
        <button data-nav="admin" id="navAdmin" hidden><span>Admin</span><span>⛭</span></button>
        <div class="hint">
          Locked v1.5 numbers: 50/35/10 splits · PRO $2/$25/$100. Game config now loads from arcade-games.json.
        </div>
      </div>
    </aside>

    <header>
      <div class="topLeft">
        <div>
          <h1 id="topTitle">Play</h1>
          <div class="sub" id="topSub">Load economy tied games from the game library.</div>
        </div>
      </div>
      <div class="topRight">
        <span class="chip" id="chipCredits"><span class="dot"></span><span id="chipCreditsT">Credits: 0 paid · 0 promo</span></span>
        <span class="chip" id="chipEpoch"><span class="dot"></span><span id="chipEpochT">Next payout: --:--:--</span></span>
        <button class="btn ghost" id="btnTutorial">Tutorial</button>
      </div>
    </header>

    <main>
      <div id="netBanner" class="netBanner" role="status" aria-live="polite"></div>

      <!-- PLAY -->
      <section class="view active" id="view-play" aria-label="Play view">
        <div class="viewHeader">
          <div>
            <p class="h" id="playTitle">Loading…</p>
            <p class="p" id="playDesc">Loading game details…</p>
          </div>
          <span class="pill"><strong>Auto payouts</strong> · 50% skill · 35% activity · 10% PRO</span>
        </div>

        <div class="playGrid">
          <div class="card">
            <div class="inner">
              <h3>Game Portal</h3>
              <div class="portal" id="portal">
                <!-- built by gruesøme -->
                <!-- sig(b64)=YnVpbHQgYnkgZ3J1ZXPDuG1l -->
                <iframe
                  id="gameFrame"
                  title="Game Portal"
                  src="/games/moonshot/index.html"
                  scrolling="no"
                  sandbox="allow-scripts allow-same-origin allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox"
                  allow="autoplay; fullscreen; gamepad"
                ></iframe>

                <div class="portalTop">
                  <span class="pill" id="pillRunCost">Loading · -- Credits/run</span>
                  <span class="pill" id="pillRunMode">Run type: --</span>
                </div>

                <div class="portalBottom">
                  <button class="btn primary" id="btnClaimPromo">Claim promo (Tx)</button>
                  <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
                    <button class="btn" id="btnFullscreen">Fullscreen</button>
                    <button class="btn" id="btnOpenWallet">Buy Credits</button>
                  </div>
                </div>
              </div>

              <div class="split">
                <div class="bar" title="Skill pool 50%"><div id="barSkill"></div></div>
                <div class="bar" title="Activity pool 35%"><div id="barActivity"></div></div>
              </div>
              <div class="bar" title="PRO boost pool 10%"><div id="barPro"></div></div>

              <div class="muted">
                Tip: transactions exist for a reason — promo claims, payout claims, avatar updates, proposals. No spam clicks.
              </div>
            </div>
          </div>

          <div class="playLower" aria-label="Play details">
            <div class="card">
              <div class="inner">
                <h3>Game Library</h3>
                <div class="muted">Games are modular files loaded by the dashboard. Add/remove via <span class="mono">arcade-games.json</span>.</div>
                <div class="gameTiles" id="gameTiles" aria-label="Game library tiles"></div>
              </div>
            </div>

            <div class="card">
              <div class="inner">
                <h3>Metrics</h3>
                <div class="muted" id="playMetricsHint">This game’s payout-eligible metrics are defined in <span class="mono">arcade-games.json</span>.</div>
                <div class="kv" id="playMetricsKv" aria-label="Game metrics"></div>
              </div>
            </div>

            <div class="card">
              <div class="inner">
                <h3>Economy Snapshot</h3>
                <div class="kv">
                  <div class="k">Paid Credits</div><div class="v" id="statPaid">0</div>
                  <div class="k" id="statPromoLabel">Promo Credits</div><div class="v" id="statPromo">0</div>
                  <div class="k">XP / Level</div><div class="v" id="statXP">0 <small>XP</small> · L1</div>
                  <div class="k">PRO</div><div class="v" id="statPRO">NONE</div>
                  <div class="k">Best Score</div><div class="v" id="statBest">0</div>
                  <div class="k">Tx (24h)</div><div class="v" id="statTx24">0</div>
                </div>

                <div class="muted">
                  Payouts are in mUSD (claim-based). This build is UI-first; transactions are simulated.
                </div>

                <div class="btn" id="btnOpenSuggestions">Suggest a game / feature (Tx)</div>
              </div>
            </div>

            <div class="card">
              <div class="inner">
                <h3>Recent Transactions</h3>
                <div class="txFeed" id="txFeed"></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- WALLET -->
      <section class="view" id="view-wallet" aria-label="Wallet view">
        <div class="viewHeader">
          <div>
            <p class="h">Wallet</p>
            <p class="p">Credits · PRO Membership · Avatar</p>
          </div>
          <span class="pill"><strong>Credit pricing</strong> · 1 Credit = $0.01 · bonus up to 15%</span>
        </div>

        <div id="walletV1Host" aria-label="Wallet panel"></div>

        <!-- Avatar Studio (embedded) -->
        <div class="overlay" id="avatarStudioModal" aria-label="PRO member NFT mint" role="dialog" aria-hidden="true">
          <div class="modal" style="width:min(1400px, calc(100% - 24px));height:min(900px, calc(100vh - 24px));height:min(900px, calc(100dvh - 24px));">
            <div class="modalHead">
              <div class="t">PRO member NFT mint</div>
              <button class="closeX" id="btnAvatarStudioClose" type="button">Close</button>
            </div>
            <div class="modalBody" style="grid-template-columns:1fr;display:flex;flex-direction:column;min-height:0;">
              <div class="panel" style="padding:0;overflow:hidden;flex:1;min-height:0;">
                <iframe id="avatarStudioFrame" title="PRO member NFT mint" style="width:100%;height:100%;border:0;display:block;background:#000;"></iframe>
              </div>
              <div class="muted" style="margin-top:10px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;flex:0 0 auto;">
                <span>Minting is staged (contracts not deployed yet).</span>
                <span>Studio runs in-dashboard.</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- LEADERBOARD -->
      <section class="view" id="view-leaderboard" aria-label="Leaderboard view">
        <div id="lbV2Host" data-ga-lb-host></div>
      </section>

      <!-- PROPOSALS -->
      <section class="view" id="view-proposals" aria-label="Proposals view">
        <div class="viewHeader">
          <div>
            <p class="h">Suggestions + Bounties</p>
            <p class="p">Submit proposals with a gas-paid transaction. If accepted, you earn Credits. Supporters can also earn a small thank-you reward.</p>
          </div>
          <span class="pill"><strong>Anti-spam</strong> · submit requires gas · only accepted work pays</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Submit a Proposal (Tx)</h3>
              <div class="split">
                <div>
                  <label class="muted">Category</label>
                  <select id="propCat">
                    <option value="game">New game</option>
                    <option value="remaster">Remaster</option>
                    <option value="feature">Feature</option>
                  </select>
                </div>
                <div>
                  <label class="muted">Title</label>
                  <input type="text" id="propTitle" placeholder="e.g. Remaster Storm the Blockchain 2 (3D)" />
                </div>
              </div>
              <div>
                <label class="muted">Description</label>
                <textarea id="propDesc" placeholder="What should it be, and why would players love it?"></textarea>
              </div>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn primary" id="btnSubmitProp">Submit (Tx)</button>
              </div>
              <div class="muted">Rewards (preview): accepted proposal = 500 Credits; supporters (on-chain) = 50 Credits (cap 100 supporters).</div>
            </div>
          </div>

          <div class="card">
            <div class="inner">
              <h3>Proposals</h3>
              <div id="propList" style="display:flex;flex-direction:column;gap:10px"></div>

              <h3 style="margin-top:6px">Bounties</h3>
              <div class="proposal">
                <div class="top">
                  <div class="title">Bug report</div>
                  <span class="tag warn">Tx submission</span>
                </div>
                <div class="desc">Submit a reproducible bug. If accepted: <strong>300 Credits</strong>.</div>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn primary" id="btnBugTx">Submit bug (Tx)</button>
                </div>
              </div>
              <div class="proposal">
                <div class="top">
                  <div class="title">Replay review</div>
                  <span class="tag warn">Tx submission</span>
                </div>
                <div class="desc">Submit a suspicious run replay for review. If confirmed: <strong>200 Credits</strong>.</div>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn primary" id="btnReplayTx">Submit replay (Tx)</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="view" id="view-settings" aria-label="Settings view">
        <div class="viewHeader">
          <div>
            <p class="h">Settings</p>
            <p class="p">FX toggles and dev utilities. Dashboard is always access-gated on refresh.</p>
          </div>
          <span class="pill"><strong>UI</strong> · v2.8</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Visual</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnToggleGrain">Toggle grain</button>
                <button class="btn" id="btnResetTutorial">Reset tutorial</button>
              </div>
              <div class="muted">Grain is subtle. Turn off if you want a cleaner UI.</div>
            </div>
          </div>
          <div class="card">
            <div class="inner">
              <h3>Data</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnExport">Export local state</button>
                <button class="btn" id="btnResetAll">Reset everything</button>
              </div>
              <pre id="dump" style="margin:0;white-space:pre-wrap;background:rgba(0,0,0,0.30);border:1px solid rgba(255,255,255,0.06);border-radius:16px;padding:12px;color:rgba(229,231,235,0.86);max-height:320px;overflow:auto;">(state preview)</pre>
            </div>
          </div>
          <div class="card">
            <div class="inner">
              <h3>Pitch Deck</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnOpenDeck">Open deck</button>
              </div>
              <div class="muted">Embeds <span class="mono">/deck/deck.pptx</span> without opening new tabs.</div>
            </div>
          </div>
        </div>
      </section>

      <!-- ADMIN (lazy-loaded bundle) -->
      <section class="view" id="view-admin" aria-label="Admin view">
        <div class="viewHeader">
          <div>
            <p class="h">Admin</p>
            <p class="p">Admin Console v1.0 (restricted to admin wallet).</p>
          </div>
          <span class="pill"><strong>Admin</strong> · v1.0</span>
        </div>
        <div id="adminV1Host"></div>
      </section>
    </main>
  </div>

  <!-- TUTORIAL -->
  <div class="overlay" id="tutorial" aria-label="Tutorial" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:820px">
      <div class="modalHead">
        <div class="t">Quick Tutorial (30s)</div>
        <button class="closeX" id="btnTutSkip">Skip</button>
      </div>
      <div class="modalBody">
        <div class="panel">
          <h3 style="margin:0 0 8px" id="tutTitle">Step</h3>
          <div class="muted" id="tutBody">...</div>
          <div style="height:12px"></div>
          <div class="kv">
            <div class="k">Economy</div><div class="v">1 Credit = $0.01 · Moonshot = 10 Credits/run</div>
            <div class="k">Tx model</div><div class="v">Meaningful actions only</div>
          </div>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 8px">What to do</h3>
          <div class="muted" id="tutHint">...</div>
          <div style="height:12px"></div>
          <button class="btn primary" id="btnTutAction" style="width:100%;justify-content:center">Do it now</button>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted" id="tutProg">1 / 5</span>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn" id="btnTutBack">Back</button>
          <button class="btn primary" id="btnTutNext">Next</button>
        </div>
      </div>
    </div>
  </div>

  <!-- EMBED MODAL (deck, etc) -->
  <div class="overlay" id="embedModal" aria-label="Embedded content" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:980px">
      <div class="modalHead">
        <div class="t" id="embedTitle">Embed</div>
        <button class="closeX" id="btnEmbedClose">Close</button>
      </div>
      <div class="modalBody">
        <div class="panel" style="padding:0">
          <iframe id="embedFrame" title="Embedded" style="width:100%;height:72vh;border:0;border-radius:16px;background:rgba(0,0,0,0.30)"></iframe>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted">Embed is in-page (no new tabs).</span>
        <span class="muted">Press ESC to close.</span>
      </div>
    </div>
  </div>

  <!-- TX CONFIRM MODAL -->
  <div class="overlay" id="txModal" aria-label="Transaction confirmation" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:720px">
      <div class="modalHead">
        <div class="t">Confirm Transaction</div>
        <button class="closeX" id="btnTxCancel">Cancel</button>
      </div>
      <div class="modalBody">
        <div class="panel">
          <h3 style="margin:0 0 8px" id="txTitle">Tx</h3>
          <div class="muted" id="txDesc">...</div>
          <div style="height:12px"></div>
          <div class="kv">
            <div class="k">Platform fee</div><div class="v">0</div>
            <div class="k">Gas</div><div class="v" id="txGas">~0.0000 ETH (estimate)</div>
          </div>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 8px">Result</h3>
          <div class="muted">In this UI-first build, transactions are simulated. Later the wallet will show the real gas + exact calldata.</div>
          <div style="height:12px"></div>
          <div class="muted" id="txPreview">(no changes yet)</div>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted">User pays gas</span>
        <button class="btn primary" id="btnTxConfirm">Confirm (pay gas)</button>
      </div>
    </div>
  </div>

  <div id="toastHost" aria-live="polite" aria-atomic="true"></div>

  <script type="module">
    // built by gruesøme
    // SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f

    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import {
      createGameFrameController,
      standardBridgeMessageTypes,
      validateMessageOrigin
    } from '/_lib/arcadeGameEmbedAdapter.js';
    import { RunCoordinator } from '/_lib/runCoordinator.js';

    // ---------- 3D BACKDROP (subtle, UI-first) ----------
    const sceneHost = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    sceneHost.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 7.5);

    const starGeo = new THREE.BufferGeometry();
    const starCount = 1500;
    const positions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 26 * Math.random();
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2*Math.random()-1);
      positions[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i*3+2] = -r * Math.cos(phi);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.03,
      transparent: true,
      opacity: 0.65,
      depthWrite: false
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    function mkRing(radius, tube, opacity) {
      const geo = new THREE.TorusGeometry(radius, tube, 18, 120);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x22d3ee,
        transparent: true,
        opacity,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(geo, mat);
      return mesh;
    }
    const ringA = mkRing(2.0, 0.020, 0.22);
    const ringB = mkRing(3.0, 0.015, 0.14);
    const ringC = mkRing(4.0, 0.010, 0.10);
    ringGroup.add(ringA, ringB, ringC);
    ringGroup.rotation.x = 0.55;

    const accentColor = new THREE.Color(0x22d3ee);
    function setAccent(hex) {
      accentColor.set(hex);
      [ringA, ringB, ringC].forEach((r, idx) => {
        r.material.color = accentColor;
        r.material.opacity = [0.22, 0.14, 0.10][idx];
      });
    }

    function onResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    let t0 = performance.now();
    let backdropRafId = 0;
    let backdropRunning = true;

    function pauseBackdrop() {
      backdropRunning = false;
      if (backdropRafId) {
        try { cancelAnimationFrame(backdropRafId); } catch {}
      }
      backdropRafId = 0;
    }

    function resumeBackdrop() {
      if (backdropRunning) return;
      backdropRunning = true;
      try { t0 = performance.now(); } catch {}
      backdropRafId = requestAnimationFrame(animate);
    }

    // If the GPU drops our context (e.g., too many contexts overall), stop rendering to avoid log spam.
    try {
      const canvas = renderer && renderer.domElement;
      if (canvas && canvas.addEventListener) {
        canvas.addEventListener('webglcontextlost', (e) => {
          try { e.preventDefault(); } catch {}
          pauseBackdrop();
        }, { passive: false });
        canvas.addEventListener('webglcontextrestored', () => {
          resumeBackdrop();
        }, { passive: true });
      }
    } catch {}

    document.addEventListener('visibilitychange', () => {
      try {
        if (document.hidden) pauseBackdrop();
        else resumeBackdrop();
      } catch {}
    }, { passive: true });

    function animate() {
      if (!backdropRunning) return;
      const t = (performance.now() - t0) * 0.001;
      stars.rotation.y = t * 0.02;
      ringGroup.rotation.y = t * 0.08;
      ringGroup.rotation.z = t * 0.03;
      camera.position.x = Math.sin(t*0.25) * 0.18;
      camera.position.y = Math.cos(t*0.20) * 0.10;
      camera.lookAt(0,0,0);
      renderer.render(scene, camera);
      backdropRafId = requestAnimationFrame(animate);
    }
    animate();

    // Expose to non-module app logic
    window.__arcadeScene = { setAccent };

    // ---------- APP LOGIC ----------
    const ECON = {
      AC_USD: 0.01,
      SPLIT: { skill: 50, activity: 35, pro: 10 },
      EXPO_END_UTC: Date.UTC(2026, 0, 30, 0, 0, 0)
    };

    const MANIFEST_URL = 'arcade-games.json';
    const FALLBACK_CATALOG = {
  "version": "2.6",
  "updatedAtUtc": "2025-12-29T06:49:51Z",
  "bridge": {
    "name": "ArcadeBridge",
    "version": "0.3"
  },
  "defaults": {
    "acUsd": 0.01,
    "maxBonusPct": 0.15,
    "bonusCurveK": 40
  },
  "games": [
    {
      "id": "moonshot",
      "name": "Moonshot",
      "tagline": "Precision flight \u2022 dodge debris \u2022 climb the stars",
      "embedUrl": "/games/moonshot/",
      "status": "live",
      "runCostAC": 10,
      "promoRuns": 5,
      "promoGrantAC": 50,
      "payoutEligible": true,
      "scoreMax": 5000,
      "minDurationMs": 800
    },
    {
      "id": "storm-the-blockchain",
      "name": "Storm the Blockchain (3D Remaster)",
      "tagline": "Classic defense \u2022 rebuilt for the onchain arcade",
      "embedUrl": "/games/stormblockchain/",
      "status": "coming_soon",
      "runCostAC": 0,
      "promoRuns": 0,
      "promoGrantAC": 0,
      "payoutEligible": false,
      "scoreMax": 100000,
      "minDurationMs": 0
    }
  ],
  "meta": {
    "schema": "gruesome-arcade.catalog.v1",
    "signaturePlain": "built by grues\u00f8me",
    "signatureEnc": "SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f"
  }
};

    let CATALOG = null;
    let GAMES = [];
    let currentGameId = 'moonshot';
    let currentGame = null;
    let frameReady = false;

    // ----- Access gate (Starfield) -----
    const accessOverlay = document.getElementById('accessGateOverlay');
    const accessFrame = document.getElementById('accessGateFrame');
    let accessGranted = false;

    // Some gate builds (including star 3.4.1) do not postMessage the parent.
    // Because the gate is same-origin (/access/), we can observe its DOM state instead.
    let T_GATE_WATCH = null;

    const accessDock = document.getElementById('accessDock');
    let dockAnimating = false;

    const HEADER_EMBED_URL = 'access/header_240x80.html?v=3.4.1';

    // Preload a dedicated header iframe in the dock so we can switch instantly
    // without navigating the animated iframe at the end (prevents the "jump").
    let dockHeaderFrame = null;
    let dockHeaderReady = false;

    function ensureDockHeaderFrame(){
      if (!accessDock) return null;
      if (dockHeaderFrame) return dockHeaderFrame;
      try {
        dockHeaderFrame = document.createElement('iframe');
        dockHeaderFrame.id = 'accessDockHeaderFrame';
        dockHeaderFrame.src = HEADER_EMBED_URL;
        dockHeaderFrame.setAttribute('title', 'Access header');
        dockHeaderFrame.setAttribute('aria-hidden', 'true');
        dockHeaderFrame.style.opacity = '0';
        dockHeaderFrame.style.pointerEvents = 'none';
        dockHeaderFrame.style.transition = 'opacity 160ms var(--ease)';
        dockHeaderFrame.addEventListener('load', () => { dockHeaderReady = true; }, { once: true });
        accessDock.appendChild(dockHeaderFrame);
      } catch {
        dockHeaderFrame = null;
      }
      return dockHeaderFrame;
    }

    function showDockHeaderFrame(){
      const f = ensureDockHeaderFrame();
      if (!f) return;
      // If it's already loaded, it will paint instantly; if not, it will paint when ready.
      try { f.style.opacity = '1'; } catch {}
    }

    function hideDockHeaderFrame(){
      if (!dockHeaderFrame) return;
      try { dockHeaderFrame.style.opacity = '0'; } catch {}
    }

    function ensureDockHeaderEmbedLoaded(){
      try {
        // Keep the dock header iframe pointed at the correct header build.
        const f = ensureDockHeaderFrame();
        if (!f) return;
        const current = String(f.getAttribute('src') || f.src || '');
        if (current.includes('access/header_240x80.html')) return;
      } catch {}
      try { if (dockHeaderFrame) dockHeaderFrame.src = HEADER_EMBED_URL; } catch {}
    }

    function showAccessGate(){ accessOverlay?.classList?.remove('is-hidden'); }
    function hideAccessGate(){ accessOverlay?.classList?.add('is-hidden'); }

    function stopAccessGateAudio(){
      // Best-effort: gate is same-origin (/access/), so we can pause any HTMLMediaElements.
      try {
        const doc = accessFrame?.contentDocument;
        const nodes = doc ? Array.from(doc.querySelectorAll('audio,video')) : [];
        nodes.forEach(el => {
          try { el.pause(); } catch {}
          try { el.muted = true; } catch {}
          try { el.volume = 0; } catch {}
          try { el.currentTime = 0; } catch {}
        });
      } catch {}
    }

    function teardownAccessGateFrame(){
      // Strong guarantee: unloading the iframe stops any remaining audio/work.
      try { stopAccessGateAudio(); } catch {}
      try { if (accessFrame) accessFrame.src = 'about:blank'; } catch {}
      try { if (accessFrame) { accessFrame.style.opacity = '0'; accessFrame.style.pointerEvents = 'none'; } } catch {}
    }

    // Smooth path: let the gate animate itself fullscreen, then swap to the docked header.
    function finalizeGateToDock(){
      try { document.body.classList.add('hasDockedGate'); } catch {}
      try { ensureDockHeaderEmbedLoaded(); } catch {}
      try { showDockHeaderFrame(); } catch {}
      // Once the user is in the dashboard, stop all access-gate audio.
      try { teardownAccessGateFrame(); } catch {}
      try { hideAccessGate(); } catch {}

      // Defensive: stop watching the iframe once access is granted.
      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = null;
    }
    function dockAccessGate(){
      if (!accessFrame || !accessDock) {
        try { document.body.classList.add('hasDockedGate'); } catch {}
        try { accessDock?.appendChild?.(accessFrame); } catch {}
        try { hideAccessGate(); } catch {}
        // IMPORTANT: use the dedicated header-only embed. Do not try to shrink the fullscreen gate.
        try { ensureDockHeaderEmbedLoaded(); showDockHeaderFrame(); } catch {}
        return;
      }

      if (dockAnimating) return;
      dockAnimating = true;

      // Measure the current (fullscreen) iframe position.
      const from = accessFrame.getBoundingClientRect();

      // Make dock visible so we can measure its target rect.
      try { document.body.classList.add('hasDockedGate'); } catch {}

      // Ensure header iframe is warming in the background.
      try { ensureDockHeaderEmbedLoaded(); } catch {}

      // Use a FLIP animation (transform translate/scale) for smoother motion.
      // IMPORTANT: avoid end-of-animation "jumps" by ensuring finish() only runs once.
      requestAnimationFrame(() => {
        const to = accessDock.getBoundingClientRect();
        const scaleX = to.width ? (from.width / to.width) : 1;
        const scaleY = to.height ? (from.height / to.height) : 1;
        const dx = from.left - to.left;
        const dy = from.top - to.top;

        const floater = document.createElement('div');
        floater.setAttribute('aria-hidden', 'true');
        floater.style.position = 'fixed';
        floater.style.left = to.left + 'px';
        floater.style.top = to.top + 'px';
        floater.style.width = to.width + 'px';
        floater.style.height = to.height + 'px';
        floater.style.zIndex = '10000';
        floater.style.overflow = 'hidden';
        floater.style.background = '#000';
        floater.style.borderRadius = '0px';
        floater.style.transformOrigin = '0 0';
        floater.style.willChange = 'transform';

        // Set the initial inverted transform BEFORE adding to the DOM to avoid a 1-frame flash.
        floater.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(${scaleX}, ${scaleY})`;
        document.body.appendChild(floater);

        // Move the SAME iframe into the floater for animation (no reload).
        try { floater.appendChild(accessFrame); } catch {}
        try { accessFrame.style.width = '100%'; accessFrame.style.height = '100%'; } catch {}

        // Fade away the overlay background now that the iframe is outside it.
        try { hideAccessGate(); } catch {}

        let finished = false;
        let finishTimer = null;

        const finish = () => {
          if (finished) return;
          finished = true;
          try { if (finishTimer) window.clearTimeout(finishTimer); } catch {}
          try { floater.removeEventListener('transitionend', finish); } catch {}

          try { accessDock.appendChild(accessFrame); } catch {}
          try { accessFrame.style.width = ''; accessFrame.style.height = ''; } catch {}
          // Hide the animated gate iframe in the dock; show the dedicated header iframe instead.
          // This avoids a navigation/paint hitch right at the end of the motion.
          try { accessFrame.style.opacity = '0'; accessFrame.style.pointerEvents = 'none'; } catch {}
          try { floater.remove(); } catch {}
          dockAnimating = false;

          // Once docked, load the provided 240x80 header-only embed.
          // Keep URL stable so it doesn't re-navigate repeatedly.
          try { ensureDockHeaderEmbedLoaded(); showDockHeaderFrame(); } catch {}
        };

        floater.addEventListener('transitionend', finish);
        finishTimer = window.setTimeout(finish, 800);

        requestAnimationFrame(() => {
          floater.style.transition = 'transform 640ms var(--ease)';
          floater.style.transform = 'translate3d(0, 0, 0) scale(1, 1)';
        });
      });
    }

    function onGateEnteredFallback(){
      if (accessGranted) return;

      accessGranted = true;
      finalizeGateToDock();
      try { afterGate(); } catch {}

      // Best-effort: sync with the server session in the background.
      try { refreshSession(true).catch(()=>{}); } catch {}

      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = null;
    }

    function startGateWatch(){
      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = window.setInterval(() => {
        if (accessGranted) return;
        try {
          const body = accessFrame?.contentDocument?.body;
          // Gate collapses into header after ENTER by adding body.is-header
          if (body && body.classList && body.classList.contains('is-header')) {
            onGateEnteredFallback();
          }
        } catch {}
      }, 250);
    }

    function bootAccessGateEveryRefresh(){
      accessGranted = false;
      try { if (accessFrame) accessFrame.src = `access/?v=${Date.now()}`; } catch (e) {}
      // Warm the docked header iframe so the swap is instant.
      try { ensureDockHeaderEmbedLoaded(); } catch {}
      showAccessGate();
      startGateWatch();
    }

    window.addEventListener('message', (ev)=>{
      const m = ev && ev.data;
      if (!m || typeof m !== 'object') return;
      if (m.type === 'GRUESOME_ACCESS_ENTER') {
        // The iframe gate is the only gate. Once it says ENTER, we proceed.
        // Server session/PoH is still used for privileged actions, but we never loop the gate.
        try {
          const d = m.detail || {};
          const addr = d && d.wallet && d.wallet.address ? String(d.wallet.address) : '';
          const pohOk = !!(d && d.poh && d.poh.verified);
          if (addr) lsSet(K.address, addr);
          if (addr) setBool(K.connected, true);
          if (pohOk) setBool(K.poh, true);
        } catch {}

        accessGranted = true;
        finalizeGateToDock();
        try { afterGate(); } catch {}

        // Best-effort: sync with the server session in the background.
        // (No gating/re-opening here.)
        try { refreshSession(true).catch(()=>{}); } catch {}
      }

      // Legacy embedded pages can request in-dashboard navigation (no new tabs).
      if (m.type === 'GRUESOME_NAV') {
        const view = m.view;
        if (typeof view === 'string' && view) setView(view);
      }
    });

    bootAccessGateEveryRefresh();

    const K = {
      connected: 'arcade.session.connected',
      poh: 'arcade.session.pohVerified',
      address: 'arcade.wallet.address',
      paid: 'arcade.credits.paid',
      paidSpent: 'arcade.stats.paidSpent',
      promoBal: (gid)=>`arcade.credits.promo.${gid}`,
      promoClaimed: (gid)=>`arcade.promo.${gid}.claimed`,
      runs: (gid)=>`arcade.runs.${gid}`,
      best: (gid)=>`arcade.stats.${gid}.bestScore`,
      xp: 'arcade.profile.xp',
      level: 'arcade.profile.level',
      proTier: 'arcade.profile.pro.tier',
      proExp: 'arcade.profile.pro.expiresAt',
      avatar: 'arcade.profile.avatar.dna',
      avatarStudio: 'arcade.profile.avatar.studio',
      avatarNick: 'arcade.profile.avatar.nickname',
      avatarHash: 'arcade.profile.avatar.hash',
      avatarPreviewPng: 'arcade.profile.avatar.previewPng',
      avatarLast: 'arcade.profile.avatar.lastEditLevel',
      avatarMinted: 'arcade.wallet.avatar.minted',
      avatarTokenId: 'arcade.wallet.avatar.tokenId',
      avatarExplorerUrl: 'arcade.wallet.avatar.explorerUrl',
      txlog: 'arcade.txlog',
      proposals: 'arcade.proposals',
      tutDone: 'arcade.tutorial.v2.8.done',
      settings: 'arcade.settings',
      selectedGame: 'arcade.ui.selectedGame',
      lbGame: 'arcade.ui.lbGame',
      lbPeriod: 'arcade.ui.lbPeriod'
    };

    // Admin Console (Iteration 4.1)
    // NOTE: Set to your wallet to unlock the Admin tab.
    window.__GA_ADMIN_WALLET__ = '0x3100fF9597B87E791E5bB8C0d57C94336A432089';

    function lsGet(k) { try { return localStorage.getItem(k); } catch { return null; } }
    function lsSet(k, v) { try { localStorage.setItem(k, String(v)); } catch {} }
    function lsDel(k) { try { localStorage.removeItem(k); } catch {} }
    function getInt(k, d=0) { const v = parseInt(lsGet(k)||'',10); return Number.isFinite(v)?v:d; }
    function setInt(k, n) { lsSet(k, String(Math.max(0, Math.floor(Number(n)||0)))); }
    function getBool(k) { return String(lsGet(k)||'0') === '1'; }
    function setBool(k, b) { lsSet(k, b ? '1' : '0'); }

    function now() { return Date.now(); }
    function clamp(n,a,b) { return Math.max(a, Math.min(b, n)); }

    function escapeHtml(s) {
      return String(s == null ? '' : s).replace(/[&<>"']/g, (c) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
      }[c]));
    }

    function shortAddr(addr) {
      const s = String(addr || '');
      if (!s) return '';
      if (!s.startsWith('0x') || s.length < 12) return s;
      return s.slice(0, 6) + '…' + s.slice(-4);
    }

    // Smooth bonus curve for Credits
    function bonusPctForUsd(usd) {
      const maxBonus = 0.15;
      const k = 40;
      const u = Math.max(0, Number(usd)||0);
      const pct = maxBonus * (1 - Math.exp(-u / k));
      return clamp(pct, 0, maxBonus);
    }
    function acOutForUsd(usd) {
      const u = Math.max(0, Number(usd)||0);
      const base = u * 100; // 1 Credit = $0.01
      const pct = bonusPctForUsd(u);
      const total = Math.floor(base * (1 + pct));
      return { baseAC: Math.floor(base), bonusPct: pct, totalAC: total };
    }

    function fmtCredits(n) {
      const x = Math.max(0, Math.floor(Number(n)||0));
      return x + ' ' + (x === 1 ? 'Credit' : 'Credits');
    }
    function fmtCreditsPerRun(n) {
      const x = Math.max(0, Math.floor(Number(n)||0));
      return x + ' ' + (x === 1 ? 'Credit' : 'Credits') + '/run';
    }
    function usdForTargetAC(targetAC) {
      const t = Math.max(1, Math.floor(Number(targetAC)||1));
      let lo = 0;
      let hi = Math.max(0.01, t/100);
      for (let i=0;i<24;i++) {
        if (acOutForUsd(hi).totalAC >= t) break;
        hi *= 2;
        if (hi > 10000) break;
      }
      for (let i=0;i<40;i++) {
        const mid = (lo+hi)/2;
        if (acOutForUsd(mid).totalAC >= t) hi = mid;
        else lo = mid;
      }
      return Math.max(0.01, Math.round(hi*100)/100);
    }

    function levelFromXP(xp) { return Math.max(1, Math.floor((xp||0)/100) + 1); }
    function syncLevel() {
      const xp = getInt(K.xp, 0);
      const lvl = levelFromXP(xp);
      const stored = getInt(K.level, 0);
      if (stored !== lvl) setInt(K.level, lvl);
      return lvl;
    }

    function proActive() {
      const tier = String(lsGet(K.proTier) || 'none');
      if (tier === 'none') return false;
      if (tier === 'lifetime') return true;
      const exp = getInt(K.proExp, 0);
      return exp > now();
    }

    function proLabel() {
      if (!proActive()) return 'NONE';
      return String(lsGet(K.proTier) || 'none').toUpperCase();
    }

    function nextUtcMidnightMs() {
      const d = new Date(now());
      return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()+1, 0,0,0);
    }
    function fmtCountdown(ms) {
      const s = Math.max(0, Math.floor(ms/1000));
      const hh = Math.floor((s%86400)/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      const dd = Math.floor(s/86400);
      const pad = (x)=>String(x).padStart(2,'0');
      return (dd>0? (dd+'d '):'') + pad(hh)+':'+pad(mm)+':'+pad(ss);
    }

    // ----- Toasts -----
    const toastHost = document.getElementById('toastHost');
    function toast(title, body) {
      const el = document.createElement('div');
      el.className = 'toast';
      el.innerHTML = `<div class="a">${title}</div><div class="b">${body||''}</div>`;
      toastHost.appendChild(el);
      setTimeout(()=>{ try{ el.remove(); }catch{} }, 2600);
    }

    // ----- Transaction log (simulated) -----
    function getTxLog() {
      try {
        const arr = JSON.parse(lsGet(K.txlog) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function setTxLog(arr) { lsSet(K.txlog, JSON.stringify(arr.slice(0,80))); }
    function addTx(tx) {
      const arr = getTxLog();
      arr.unshift(tx);
      setTxLog(arr);
    }

    // Lightweight feed entries (used by run start/finish)
    function addFeed(label) {
      addTx({
        id: 'feed_' + Math.random().toString(16).slice(2),
        kind: 'feed',
        label: String(label || ''),
        gasEth: '0.00000',
        status: 'confirmed',
        ts: now(),
      });
    }

    // Tx modal
    const txModal = document.getElementById('txModal');
    const txTitle = document.getElementById('txTitle');
    const txDesc = document.getElementById('txDesc');
    const txGas = document.getElementById('txGas');
    const txPreview = document.getElementById('txPreview');
    const btnTxCancel = document.getElementById('btnTxCancel');
    const btnTxConfirm = document.getElementById('btnTxConfirm');
    let pendingTxAction = null;

    // ----- Overlay manager (sticky, blocking popups) -----
    const OVERLAYS = {
      tutorial: document.getElementById('tutorial'),
      embed: document.getElementById('embedModal'),
      tx: txModal,
    };

    function anyOverlayOpen() {
      try { return !!document.querySelector('.overlay.show'); } catch { return false; }
    }

    function lockBackgroundForOverlay() {
      document.body.classList.add('modalOpen');
    }

    function unlockBackgroundIfNoOverlays() {
      if (!anyOverlayOpen()) document.body.classList.remove('modalOpen');
    }

    function getFocusable(root) {
      if (!root) return [];
      const nodes = root.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      return Array.from(nodes).filter((el) => {
        try {
          if (el.disabled) return false;
          const style = window.getComputedStyle(el);
          if (style.display === 'none' || style.visibility === 'hidden') return false;
          return true;
        } catch { return false; }
      });
    }

    function focusFirstInOverlay(overlayEl) {
      try {
        const focusables = getFocusable(overlayEl);
        if (focusables.length) focusables[0].focus();
      } catch {}
    }

    function showOverlay(overlayEl, { mandatory = false } = {}) {
      if (!overlayEl) return;
      overlayEl.dataset.mandatory = mandatory ? '1' : '';
      overlayEl.classList.add('show');
      overlayEl.setAttribute('aria-hidden', 'false');
      lockBackgroundForOverlay();
      focusFirstInOverlay(overlayEl);
    }

    function hideOverlay(overlayEl, { force = false } = {}) {
      if (!overlayEl) return;
      const mandatory = overlayEl.dataset.mandatory === '1';
      if (mandatory && !force) return;
      overlayEl.classList.remove('show');
      overlayEl.setAttribute('aria-hidden', 'true');
      overlayEl.dataset.mandatory = '';
      unlockBackgroundIfNoOverlays();
    }

    function topOpenOverlay() {
      // Explicit priority order (most blocking / most likely to be open)
      const ids = ['avatarStudioModal', 'txModal', 'embedModal', 'tutorial'];
      for (const id of ids) {
        const el = document.getElementById(id);
        if (el && el.classList.contains('show')) return el;
      }
      return null;
    }

    // Prevent “clicking outside” to dismiss — popups must be closed/used.
    for (const el of document.querySelectorAll('.overlay')) {
      el.addEventListener('click', (e) => {
        if (e.target === el) {
          e.preventDefault();
          e.stopPropagation();
        }
      });
    }

    window.addEventListener('keydown', (e) => {
      const top = topOpenOverlay();
      if (!top) return;

      if (e.key === 'Escape') {
        if (top.dataset.mandatory === '1') return;
        // Route to existing close functions where needed.
        if (top.id === 'txModal') { e.preventDefault(); closeTxConfirm(); return; }
        if (top.id === 'embedModal') { e.preventDefault(); closeEmbed(); return; }
        if (top.id === 'tutorial') { e.preventDefault(); endTutorial(); return; }
        // Avatar Studio stays on-screen until explicitly closed.
        if (top.id === 'avatarStudioModal') { e.preventDefault(); return; }
        return;
      }

      if (e.key === 'Tab') {
        const focusables = getFocusable(top);
        if (!focusables.length) return;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        const active = document.activeElement;
        if (e.shiftKey) {
          if (active === first || !top.contains(active)) {
            e.preventDefault();
            last.focus();
          }
        } else {
          if (active === last) {
            e.preventDefault();
            first.focus();
          }
        }
      }
    });

    function openTxConfirm({ title, desc, gasEth, preview, onConfirm }) {
      pendingTxAction = onConfirm || null;
      txTitle.textContent = title || 'Transaction';
      txDesc.textContent = desc || '';
      txGas.textContent = gasEth ? `~${gasEth} ETH (estimate)` : '~0.0000 ETH (estimate)';
      txPreview.textContent = preview || '';
      showOverlay(txModal);
    }
    function closeTxConfirm() {
      pendingTxAction = null;
      hideOverlay(txModal);
    }
    btnTxCancel.addEventListener('click', closeTxConfirm);
    btnTxConfirm.addEventListener('click', ()=>{
      const fn = pendingTxAction;
      closeTxConfirm();
      if (typeof fn === 'function') fn();
    });

    function simulateTx({ kind, label, gasEth='0.00005', apply }) {
      const id = '0x' + Math.random().toString(16).slice(2).padEnd(64,'0').slice(0,64);
      const tx = { id, kind, label, gasEth, status:'pending', ts: now() };
      addTx(tx);
      renderTxFeed();
      toast('Tx submitted', label);
      setTimeout(()=>{
        tx.status = 'confirmed';
        tx.confirmedTs = now();
        const arr = getTxLog().map(x => x.id === tx.id ? tx : x);
        setTxLog(arr);
        try { apply && Promise.resolve(apply(tx)).catch(()=>{}); } catch {}
        renderAll();
        renderTxFeed();
        toast('Tx confirmed', label);
      }, 900 + Math.random()*700);
      return tx;
    }

      // ----- Session state (server + local mirror) -----
    const SESSION = { status:'init', authenticated:false, pohVerified:false, address:'' };

    // Detect whether /api is actually being served (static `serve` does not).
    const API_CAPS = { available: true };

    function isLocalhostHost() {
      return /^(localhost|127\.0\.0\.1|::1)$/i.test(location.hostname);
    }

    function isApiPath(u) {
      return typeof u === 'string' && u.startsWith('/api/');
    }

    function randAddr() {
      const hex = '0123456789abcdef';
      let s = '0x';
      for (let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
      return s;
    }

    const UI_CAPS = {
      mobile: window.matchMedia && window.matchMedia('(max-width: 980px)').matches,
      reducedMotion: window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
    };

    function updateUiCaps() {
      try {
        UI_CAPS.mobile = window.matchMedia && window.matchMedia('(max-width: 980px)').matches;
        UI_CAPS.reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      } catch {}
    }

    async function apiJson(url, opts) {
      const started = now();
      try {
        const timeoutMs = (opts && Number.isFinite(opts.timeoutMs)) ? Math.max(1000, Math.floor(opts.timeoutMs)) : (UI_CAPS.mobile ? 6500 : 9000);
        const ctrl = (window.AbortController) ? new AbortController() : null;
        const to = ctrl ? window.setTimeout(() => { try { ctrl.abort(); } catch {} }, timeoutMs) : null;

        const res = await fetch(url, {
          method: (opts && opts.method) || 'GET',
          headers: { 'content-type': 'application/json', ...(opts && opts.headers ? opts.headers : {}) },
          body: opts && opts.body ? JSON.stringify(opts.body) : undefined,
          credentials: 'include',
          signal: ctrl ? ctrl.signal : undefined
        });

        if (to) window.clearTimeout(to);

        // If we got a response at all, the server is reachable.
        API_STATE.online = true;
        API_STATE.lastOk = now();
        API_STATE.lastErr = '';

        const text = await res.text();
        let data = {};
        try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: String(text||'') }; }

        // Some endpoints may return a 200 with an explicit error payload (e.g. missing Redis config).
        // Treat these as logical errors so callers continue to use existing catch/fallback paths.
        if (res.ok && data && data.ok === false && data.error) {
          const err = new Error(String(data.error));
          err.status = 503;
          err.data = data;
          throw err;
        }

        if (!res.ok) {
          const err = new Error((data && data.error) ? String(data.error) : ('HTTP_' + res.status));
          err.status = res.status;
          err.data = data;

          // Local static dev server: treat /api 404s as "API not present" and stop trying.
          if (res.status === 404 && isApiPath(url) && isLocalhostHost()) {
            API_CAPS.available = false;
            API_STATE.online = false;
            API_STATE.lastErr = 'api_not_served';
          }

          // Only ping telemetry for server problems / throttling.
          if (API_CAPS.available && !document.hidden && (res.status >= 500 || res.status === 429)) {
            sendTelemetry('api_http_error', {
              url, status: res.status,
              error: err.message,
              ms: Math.round(now() - started)
            });
          }
          throw err;
        }
        return data;
      } catch (e) {
        // HTTP errors are handled above; don't misclassify them as network failures.
        if (e && typeof e.status === 'number') throw e;

        // Network error / CORS / offline
        API_STATE.online = false;
        API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
        if (API_CAPS.available && !document.hidden) {
          sendTelemetry('api_network_error', {
            url,
            error: API_STATE.lastErr,
            ms: Math.round(now() - started)
          });
        }
        throw e;
      }
    }

    function mirrorSessionToLocal(s) {
      setBool(K.connected, !!s.authenticated);
      setBool(K.poh, !!s.pohVerified);
      if (s.address) lsSet(K.address, String(s.address));
      else lsDel(K.address);
    }

    const API_STATE = { online:true, lastOk:0, lastErr:'' };

    // Production: global network banner
    const netBanner = document.getElementById('netBanner');
    function setNetBanner(kind, title, body) {
      if (!netBanner) return;
      if (!kind) {
        netBanner.className = 'netBanner';
        netBanner.innerHTML = '';
        return;
      }
      netBanner.className = 'netBanner show ' + String(kind);
      netBanner.innerHTML = `<div class="a">${String(title||'Status')}</div><div class="b">${String(body||'')}</div>`;
    }

    function renderNetBanner() {
      // Hide while iframe gate is visible (avoid UI noise under the gate).
      try {
        if (accessOverlay && !accessOverlay.classList.contains('is-hidden')) {
          setNetBanner(null);
          return;
        }
      } catch {}

      if (!API_CAPS.available && isLocalhostHost()) {
        setNetBanner('warn', 'API not served', 'Run `npm run preview` for full-stack mode. Static `npm run dev` does not serve /api/*.' );
        return;
      }

      if (SESSION && SESSION.status === 'loading') {
        setNetBanner('warn', 'Checking session', 'Connecting to server…');
        return;
      }

      if (!API_STATE.online) {
        const msg = API_STATE.lastErr ? String(API_STATE.lastErr) : 'offline';
        setNetBanner('bad', 'Server offline', `Some features disabled. (${msg})`);
        return;
      }

      if (SESSION && SESSION.status === 'ok' && SESSION.authenticated && !SESSION.pohVerified) {
        setNetBanner('warn', 'PoH required', 'Complete PoH in Linea Hub, then refresh session in the access gate.');
        return;
      }

      setNetBanner(null);
    }

    // Lightweight client telemetry (writes to /api/telemetry; no web3 yet)
    const TELEMETRY_STATE = {
      budget: 8,
      sent: 0,
      lastTs: 0
    };

    function sendTelemetry(type, payload) {
      try {
        if (!API_CAPS.available) return;
        if (!type) return;
        if (TELEMETRY_STATE.sent >= TELEMETRY_STATE.budget) return;
        const nowTs = Date.now();
        if (nowTs - TELEMETRY_STATE.lastTs < 400) return; // small anti-burst
        TELEMETRY_STATE.lastTs = nowTs;

        const body = {
          type,
          message: (payload && payload.message) ? String(payload.message) : '',
          url: (payload && payload.url) ? String(payload.url) : location.href,
          view: (document.body && document.body.dataset && document.body.dataset.view) ? document.body.dataset.view : '',
          uiVersion: document.documentElement.getAttribute('data-ui-version') || '2.8',
          gameId: currentGameId || '',
          extra: payload || undefined
        };

        TELEMETRY_STATE.sent++;

        // Prefer sendBeacon (non-blocking)
        if (navigator.sendBeacon) {
          const blob = new Blob([JSON.stringify(body)], { type: 'application/json' });
          navigator.sendBeacon('/api/telemetry', blob);
          return;
        }

        // Fallback
        fetch('/api/telemetry', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body),
          credentials: 'include',
          keepalive: true
        }).catch(()=>{});
      } catch {}
    }

    // Global error listeners (best-effort)
    window.addEventListener('error', (ev) => {
      try {
        const msg = ev && ev.message ? String(ev.message) : 'error';
        const src = ev && ev.filename ? String(ev.filename) : '';
        sendTelemetry('client_error', { message: msg, src, line: ev.lineno, col: ev.colno, stack: (ev.error && ev.error.stack) ? String(ev.error.stack) : '' });
      } catch {}
    });

    window.addEventListener('unhandledrejection', (ev) => {
      try {
        const r = ev && ev.reason;
        const msg = r ? (r.message || String(r)) : 'unhandledrejection';
        const stack = (r && r.stack) ? String(r.stack) : '';
        sendTelemetry('client_rejection', { message: String(msg), stack });
      } catch {}
    });

    const LB_CACHE = { key:'', ts:0, loading:false, entries:null, you:null, err:'' };
    const PROP_CACHE = { ts:0, loading:false, list:null, err:'' };
    const EPOCH_CACHE = { ts:0, loading:false, data:null, err:'' };

    function applyServerState(st) {
      if (!st) return;
      if (st.address) lsSet(K.address, String(st.address));
      if (st.paidAC != null) setInt(K.paid, Math.max(0, Math.floor(Number(st.paidAC)||0)));
      if (st.xp != null) setInt(K.xp, Math.max(0, Math.floor(Number(st.xp)||0)));
      if (st.level != null) setInt(K.level, Math.max(1, Math.floor(Number(st.level)||0)));
      if (st.proTier) lsSet(K.proTier, String(st.proTier));
      if (st.proExp != null) lsSet(K.proExp, String(st.proExp));

      if (st.promoAC && typeof st.promoAC === 'object') {
        for (const [gid, v] of Object.entries(st.promoAC)) {
          setInt(K.promoBal(gid), Math.max(0, Math.floor(Number(v||0))));
        }
      }
      if (st.best && typeof st.best === 'object') {
        for (const [gid, v] of Object.entries(st.best)) {
          setInt(K.best(gid), Math.max(0, Math.floor(Number(v||0))));
        }
      }
    }

    async function refreshLedger() {
      try {
        const st = await apiJson('/api/ledger/balance');
        API_STATE.online = true;
        API_STATE.lastOk = now();
        API_STATE.lastErr = '';
        applyServerState(st);
        return st;
      } catch (e) {
        API_STATE.online = false;
        API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
        return null;
      }
    }

    async function serverBuyAC(usd) {
      return apiJson('/api/ledger/buy', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { usd }
      });
    }
    async function serverProfilePatch(patch) {
      return apiJson('/api/ledger/profile', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: patch||{}
      });
    }
    async function serverClaimPromo(gameId) {
      return apiJson('/api/promo/claim', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId }
      });
    }
    async function serverRunStart(gameId) {
      return apiJson('/api/run/start', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId }
      });
    }
    async function serverRunSubmit(payload) {
      return apiJson('/api/run/submit', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: payload||{}
      });
    }

    async function refreshLeaderboard(gameId, period) {
      const key = String(gameId) + '|' + String(period);
      if (LB_CACHE.loading) return;
      const stale = (!LB_CACHE.ts) || (now() - LB_CACHE.ts > 15000) || (LB_CACHE.key !== key);
      if (!stale) return;
      LB_CACHE.loading = true;
      LB_CACHE.err = '';
      try {
        const url = '/api/leaderboard/top?gameId=' + encodeURIComponent(gameId) + '&period=' + encodeURIComponent(period) + '&eligible=1';
        const data = await apiJson(url);
        LB_CACHE.key = key;
        LB_CACHE.ts = now();
        LB_CACHE.entries = (data && Array.isArray(data.entries)) ? data.entries : [];
        LB_CACHE.you = data ? data.you : null;
        API_STATE.online = true;
        API_STATE.lastOk = now();
        renderLocalLB();
      } catch (e) {
        LB_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        LB_CACHE.loading = false;
      }
    }

    async function refreshProposals() {
      if (PROP_CACHE.loading) return;
      const stale = (!PROP_CACHE.ts) || (now() - PROP_CACHE.ts > 20000);
      if (!stale) return;
      PROP_CACHE.loading = true;
      PROP_CACHE.err = '';
      try {
        const data = await apiJson('/api/proposals/list?limit=20');
        PROP_CACHE.ts = now();
        PROP_CACHE.list = (data && Array.isArray(data.proposals)) ? data.proposals : [];
        API_STATE.online = true;
        API_STATE.lastOk = now();
        renderProposals();
      } catch (e) {
        PROP_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        PROP_CACHE.loading = false;
      }
    }



    async function refreshEpochStatus(force=false) {
      if (EPOCH_CACHE.loading) return;
      const stale = force || (!EPOCH_CACHE.ts) || (now() - EPOCH_CACHE.ts > 20000);
      if (!stale) return;
      EPOCH_CACHE.loading = true;
      EPOCH_CACHE.err = '';
      try {
        const data = await apiJson('/api/epoch/status');
        EPOCH_CACHE.data = data;
        EPOCH_CACHE.ts = now();
        API_STATE.online = true;
        API_STATE.lastOk = now();
      } catch (e) {
        EPOCH_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        EPOCH_CACHE.loading = false;
      }
    }

    async function serverEpochClaim(ymd) {
      return apiJson('/api/epoch/claim', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { ymd: ymd||'' }
      });
    }

    async function serverMintBadge(gameId) {
      return apiJson('/api/badge/mint', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId: String(gameId||'') }
      });
    }

    async function refreshSession(silent=false) {
      SESSION.status = 'loading';
      try {
        const s = await apiJson('/api/session');
        SESSION.status = 'ok';
        SESSION.authenticated = !!s.authenticated;
        SESSION.pohVerified = !!s.pohVerified;
        SESSION.address = String(s.address || '');
        mirrorSessionToLocal(SESSION);
        if (SESSION.authenticated) { await refreshLedger(); await refreshEpochStatus(true); }
      } catch (e) {
        // Offline fallback: use local demo state
        SESSION.status = 'offline';
        SESSION.authenticated = getBool(K.connected);
        SESSION.pohVerified = getBool(K.poh);
        SESSION.address = lsGet(K.address) || '';
        API_STATE.online = false;
      }
      renderAll();
      return SESSION;
    }

    // ----- Adaptive timers (mobile-simple + background tab throttling) -----
    let T_EPOCH = null;
    let T_RENDER = null;
    let T_EPOCH_POLL = null;
    function stopTimers() {
      try { if (T_EPOCH) clearInterval(T_EPOCH); } catch {}
      try { if (T_RENDER) clearInterval(T_RENDER); } catch {}
      try { if (T_EPOCH_POLL) clearInterval(T_EPOCH_POLL); } catch {}
      T_EPOCH = T_RENDER = T_EPOCH_POLL = null;
    }

    function startTimers() {
      const hidden = !!document.hidden;
      const mobile = !!UI_CAPS.mobile;

      const epochTickMs = hidden ? 5000 : (mobile ? 1000 : 250);
      const renderTickMs = hidden ? 15000 : (mobile ? 4000 : 2500);
      const epochPollMs = hidden ? 60000 : (mobile ? 30000 : 20000);

      T_EPOCH = setInterval(()=>{ renderEpoch(); renderExpoCountdown(); }, epochTickMs);
      T_RENDER = setInterval(()=>{ renderAll(); renderNetBanner(); }, renderTickMs);
      T_EPOCH_POLL = setInterval(()=>{ if (API_CAPS.available && SESSION.authenticated) refreshEpochStatus(); }, epochPollMs);
    }

    function restartTimers() {
      stopTimers();
      startTimers();
    }

    async function afterGate() {
      if (!getBool(K.tutDone)) {
        setTimeout(()=>startTutorial(), 450);
      }
      await refreshLedger();
      refreshProposals();
      // best-effort warm caches for visible views
      try { refreshLeaderboard(getLbGameId(), getLbPeriod()); } catch {}
      syncToGame();
      renderAll();
    }

// ----- Navigation -----
    const navBtns = Array.from(document.querySelectorAll('.nav button[data-nav]'));
    const views = {
      play: document.getElementById('view-play'),
      wallet: document.getElementById('view-wallet'),
      leaderboard: document.getElementById('view-leaderboard'),
      proposals: document.getElementById('view-proposals'),
      settings: document.getElementById('view-settings'),
      admin: document.getElementById('view-admin')
    };
    const topTitle = document.getElementById('topTitle');
    const topSub = document.getElementById('topSub');

    function normalizeAddr(a) {
      return String(a || '').trim().toLowerCase();
    }

    function isAdminSession() {
      const admin = normalizeAddr(window.__GA_ADMIN_WALLET__);
      if (!admin) return false;
      const addr = normalizeAddr((SESSION && SESSION.address) ? SESSION.address : (lsGet(K.address) || ''));
      return !!(addr && admin && addr === admin);
    }

    function updateAdminNavVisibility() {
      const btn = document.getElementById('navAdmin');
      if (!btn) return;
      const ok = isAdminSession();
      btn.hidden = !ok;
      if (!ok && document.body.dataset.view === 'admin') {
        try { setView('play'); } catch {}
      }
    }

    function setView(name) {
      if (name === 'admin' && !isAdminSession()) {
        try { toast('Admin', 'Not authorized for Admin Console.'); } catch {}
        name = 'play';
      }
      document.body.dataset.view = name;
      navBtns.forEach(b => b.classList.toggle('active', b.dataset.nav === name));
      Object.entries(views).forEach(([k, el]) => el.classList.toggle('active', k === name));
      topTitle.textContent = name.charAt(0).toUpperCase()+name.slice(1);
      topSub.textContent = (name === 'play') ? ((currentGame && currentGame.name) ? (currentGame.name + ' · ' + (currentGame.tagline||'')) : 'Choose a game to play.')
        : (name === 'wallet') ? 'Wallet UI v1.0 (authoritative).'
        : (name === 'leaderboard') ? 'Ranks, payouts, and daily epochs.'
        : (name === 'proposals') ? 'Pay gas to submit ideas. Earn if accepted.'
        : (name === 'admin') ? 'Admin Console v1.0 (restricted).'
        : 'Preferences + utilities.';

      // Wallet view loads its UI on demand (keeps other tabs untouched)
      if (name === 'wallet') {
        try { ensureWalletV1Loaded(); } catch {}
        try { startAvatarPromoRotation(); } catch {}
      } else {
        try { stopAvatarPromoRotation(); } catch {}

        // Reduce background work: if the Avatar Studio iframe isn't visible, unload it.
        try {
          const modal = document.getElementById('avatarStudioModal');
          const open = !!(modal && modal.classList.contains('show'));
          if (!open) {
            const f = document.getElementById('avatarStudioFrame');
            const src = f ? String(f.getAttribute('src') || '') : '';
            if (f && src && src !== 'about:blank') f.setAttribute('src', 'about:blank');
          }
        } catch {}
      }

      // Ensure only one WebGL-heavy iframe is active: if we leave Play,
      // unload the game iframe; if we return to Play, restore it.
      try {
        if (typeof gameFrame !== 'undefined' && gameFrame) {
          const src = String(gameFrame.getAttribute('src') || '');
          if (name !== 'play') {
            if (gameController) {
              gameController.unmount();
            } else {
              if (src && src !== 'about:blank') gameFrame.setAttribute('src', 'about:blank');
            }
          } else {
            if (gameController) {
              const g = currentGame || gameById(currentGameId);
              if (g) {
                gameController.mount({
                  id: g.id,
                  title: g.name,
                  url: g.embedUrl,
                  defaultMetric: g.defaultMetric,
                  metrics: (Array.isArray(g.metrics) ? g.metrics.map(m => String(m.id)) : []),
                  runTypePolicy: g.runTypePolicy,
                  sandboxPolicy: g.sandboxPolicy,
                  allowList: g.allowList
                });
              }
            } else {
              if (!src || src === 'about:blank') {
                const next = (currentGame && currentGame.embedUrl) ? String(currentGame.embedUrl) : '/games/moonshot/';
                gameFrame.setAttribute('src', next);
              }
            }
          }
        }
      } catch {}

      // Leaderboard v2 loader
      if (name === 'leaderboard') {
        try { ensureLeaderboardV2Loaded(); } catch {}
      }

      // Admin v1 loader
      if (name === 'admin') {
        try { ensureAdminV1Loaded(); } catch {}
      }

      // Update 3D accent
      const cssAccent = getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#22d3ee';
      try { window.__arcadeScene && window.__arcadeScene.setAccent(cssAccent); } catch {}
    }
    navBtns.forEach(btn => btn.addEventListener('click', ()=>setView(btn.dataset.nav)));

    // ----- Leaderboard v2 (drop-in bundle) -----
    let GA_LB_V2_LOADED = false;

    function gaFetchText(url) {
      return fetch(url, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error('HTTP_' + r.status);
        return r.text();
      });
    }

    function gaLoadCssOnce(href, id) {
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    }

    function gaLoadScriptOnce(src, id) {
      return new Promise((resolve, reject) => {
        if (document.getElementById(id)) return resolve();
        const s = document.createElement('script');
        s.id = id;
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('script_load_failed'));
        document.head.appendChild(s);
      });
    }

    // ----- Admin Console v1 (drop-in bundle) -----
    let GA_ADMIN_V1_LOADED = false;

    async function ensureAdminV1Loaded() {
      const host = document.getElementById('adminV1Host');
      if (!host) return;

      if (GA_ADMIN_V1_LOADED) {
        // Admin bundle handles its own connect/refresh.
        return;
      }
      GA_ADMIN_V1_LOADED = true;

      gaLoadCssOnce('/gruesome-arcade-admin-ui-v1.0/admin.css?v=1.0', 'ga-admin-v1-css');
      const html = await gaFetchText('/gruesome-arcade-admin-ui-v1.0/admin-panel.html?v=1.0');
      host.innerHTML = html;
      await gaLoadScriptOnce('/gruesome-arcade-admin-ui-v1.0/admin.js?v=1.0', 'ga-admin-v1-js');
    }

    async function serverWeekClaim(yw) {
      return apiJson('/api/week/claim', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: { yw }
      });
    }

    function getEpochForLbV2() {
      const d = (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : {};
      const nextPayoutAt = (() => {
        try {
          if (d && d.nextPayoutAt != null) {
            const x = Number(d.nextPayoutAt);
            if (Number.isFinite(x) && x > 0) return x;
          }
          if (d && d.nextDailyPayoutAt != null) {
            const x = Number(d.nextDailyPayoutAt);
            if (Number.isFinite(x) && x > 0) return x;
          }
        } catch {}
        try { return nextUtcMidnightMs(); } catch {}
        return 0;
      })();

      const dayUsd = (() => {
        try {
          if (d && typeof d.claimable === 'number') return Number(d.claimable) || 0;
          if (d && typeof d.dayClaimable === 'number') return Number(d.dayClaimable) || 0;
          if (d && d.claimable && d.claimable.record) return Number(d.claimable.record.totalUsd || 0) || 0;
        } catch {}
        return 0;
      })();

      const weekUsd = (() => {
        try {
          if (d && typeof d.weekClaimable === 'number') return Number(d.weekClaimable) || 0;
          if (d && d.weekClaimable && d.weekClaimable.record) return Number(d.weekClaimable.record.totalUsd || 0) || 0;
        } catch {}
        return 0;
      })();

      return {
        nextPayoutAt,
        nextDailyPayoutAt: nextPayoutAt,
        claimable: Math.max(0, Number(dayUsd || 0)),
        dayClaimable: Math.max(0, Number(dayUsd || 0)),
        weekClaimable: Math.max(0, Number(weekUsd || 0)),
        todayTickets: (d && Number.isFinite(d.todayTickets)) ? Math.max(0, Math.floor(Number(d.todayTickets))) : 0,
        weekActivity: (d && Number.isFinite(d.weekActivity)) ? Math.max(0, Math.floor(Number(d.weekActivity))) : 0,
      };
    }

    async function ensureLeaderboardV2Loaded() {
      if (GA_LB_V2_LOADED) {
        try { window.__GA_LB_V2__ && window.__GA_LB_V2__.onShow && window.__GA_LB_V2__.onShow(); } catch {}
        return;
      }
      GA_LB_V2_LOADED = true;

      // Adapter surface consumed by /public/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.js
      window.__ARCADE_LB_ADAPTER__ = {
        version: '2.0',
        apiJson,
        toast,
        shortAddr,
        openWallet: () => setView('wallet'),
        getSession: () => ({
          connected: !!(SESSION && SESSION.authenticated),
          address: (SESSION && SESSION.address) ? SESSION.address : (lsGet(K.address) || null),
          pohVerified: (SESSION && typeof SESSION.pohVerified === 'boolean') ? SESSION.pohVerified : getBool(K.poh),
        }),
        getEpoch: () => getEpochForLbV2(),
        getCatalog: async () => (CATALOG || null),
        claimDaily: async () => {
          try {
            const e = (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : null;
            const ymd = e && e.lastSettledYmd ? String(e.lastSettledYmd) : (e && e.claimable && e.claimable.record ? String(e.claimable.record.ymd || '') : '');
            const amt = Number(getEpochForLbV2().claimable || 0) || 0;
            const claimed = !!(e && e.claimable && typeof e.claimable.claimed === 'boolean' ? e.claimable.claimed : false);

            if (!SESSION.authenticated) return toast('Connect wallet', 'Required to claim.');
            if (!SESSION.pohVerified) return toast('PoH required', 'Verify Proof of Humanity to claim payouts.');
            if (!ymd) return toast('Claim', 'No settled day available yet.');
            if (amt <= 0) return toast('No claimable rewards', 'Play more to earn rewards.');
            if (claimed) return toast('Already claimed', 'This day is already claimed.');

            openTxConfirm({
              title: 'Claim daily payout',
              desc: `Claim ${amt.toFixed(2)} mUSD from the last settled day. (User pays gas)`,
              gasEth: '0.00006',
              preview: `Writes: daily claim (${ymd}) · Server records claim + audit.`,
              onConfirm: () => {
                simulateTx({
                  kind: 'claim',
                  label: `Claim ${amt.toFixed(2)} mUSD`,
                  gasEth: '0.00006',
                  apply: async () => {
                    try {
                      await serverEpochClaim(ymd);
                      await refreshEpochStatus(true);
                      await refreshLedger();
                      try { window.__GA_LB_V2__ && window.__GA_LB_V2__.refresh && window.__GA_LB_V2__.refresh(); } catch {}
                    } catch (err) {
                      toast('Claim failed', (err && err.message) ? String(err.message) : 'server error');
                    }
                  }
                });
              }
            });
          } catch (err) {
            toast('Claim', 'Failed to claim daily.');
          }
        },
        claimWeekly: async () => {
          try {
            const e = (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : null;
            const yw = e && e.lastSettledYw ? String(e.lastSettledYw) : (e && e.weekClaimable && e.weekClaimable.record ? String(e.weekClaimable.record.yw || '') : '');
            const amt = Number(getEpochForLbV2().weekClaimable || 0) || 0;
            const claimed = !!(e && e.weekClaimable && typeof e.weekClaimable.claimed === 'boolean' ? e.weekClaimable.claimed : false);

            if (!SESSION.authenticated) return toast('Connect wallet', 'Required to claim.');
            if (!SESSION.pohVerified) return toast('PoH required', 'Verify Proof of Humanity to claim payouts.');
            if (!yw) return toast('Claim', 'No settled week available yet.');
            if (amt <= 0) return toast('No claimable rewards', 'Play more to earn rewards.');
            if (claimed) return toast('Already claimed', 'This week is already claimed.');

            openTxConfirm({
              title: 'Claim weekly payout',
              desc: `Claim ${amt.toFixed(2)} mUSD from the last settled week. (User pays gas)`,
              gasEth: '0.00006',
              preview: `Writes: weekly claim (${yw}) · Server records claim + audit.`,
              onConfirm: () => {
                simulateTx({
                  kind: 'claim',
                  label: `Claim ${amt.toFixed(2)} mUSD`,
                  gasEth: '0.00006',
                  apply: async () => {
                    try {
                      await serverWeekClaim(yw);
                      await refreshEpochStatus(true);
                      await refreshLedger();
                      try { window.__GA_LB_V2__ && window.__GA_LB_V2__.refresh && window.__GA_LB_V2__.refresh(); } catch {}
                    } catch (err) {
                      toast('Claim failed', (err && err.message) ? String(err.message) : 'server error');
                    }
                  }
                });
              }
            });
          } catch (err) {
            toast('Claim', 'Failed to claim weekly.');
          }
        },
      };

      // Warm caches so v2 can render payouts quickly.
      try { await refreshEpochStatus(true); } catch {}

      gaLoadCssOnce('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.css', 'ga-lb-v2-css');

      const host = document.getElementById('lbV2Host');
      if (!host) return;

      try {
        host.innerHTML = await gaFetchText('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard-panel.html');
      } catch (e) {
        host.innerHTML = '<div class="card"><div class="mini muted">Failed to load Leaderboard UI bundle.</div></div>';
        return;
      }

      try {
        await gaLoadScriptOnce('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.js', 'ga-lb-v2-js');
      } catch (e) {
        host.innerHTML = '<div class="card"><div class="mini muted">Failed to load Leaderboard UI script.</div></div>';
        return;
      }

      try { window.__GA_LB_V2__ && window.__GA_LB_V2__.onShow && window.__GA_LB_V2__.onShow(); } catch {}
    }

    // ----- Top chips -----
    const chipWallet = document.getElementById('chipWallet');
    const chipWalletT = document.getElementById('chipWalletT');
    const chipPOH = document.getElementById('chipPOH');
    const chipPOHT = document.getElementById('chipPOHT');
    const chipCreditsT = document.getElementById('chipCreditsT');
    const chipEpochT = document.getElementById('chipEpochT');

    function renderTopChips() {
      const connected = getBool(K.connected);
      const poh = getBool(K.poh);
      const addr = lsGet(K.address) || '0x…';
      chipWallet.className = 'chip ' + (connected ? 'good' : 'warn');
      chipWalletT.textContent = connected ? ('Wallet: ' + addr.slice(0,6) + '…' + addr.slice(-4)) : 'Wallet: not connected';
      chipPOH.className = 'chip ' + (poh ? 'good' : 'warn');
      chipPOHT.textContent = poh ? 'POH: verified' : 'POH: not verified';

      const paid = getInt(K.paid, 0);
      const promo = getInt(K.promoBal(currentGameId), 0);
      const g = (currentGame && currentGame.name) ? currentGame.name : currentGameId;
      chipCreditsT.textContent = `Credits: ${paid} paid · ${promo} promo (${g})`;
    }

    function renderEpoch() {
      const ms = nextUtcMidnightMs() - now();
      const countdown = fmtCountdown(ms);

      // Append claim hint if available
      let hint = '';
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;
      if (rec && !claimed) {
        const amt = Number(rec.totalUsd || 0);
        if (amt > 0) hint = ` · Claim ${amt.toFixed(2)} mUSD`;
      }

      chipEpochT.textContent = 'Next payout: ' + countdown + hint;
      const el = document.getElementById('lbEpoch');
      if (el) el.textContent = countdown;
    }

    // ----- Bars (50/35/10) -----
    const barSkill = document.getElementById('barSkill');
    const barActivity = document.getElementById('barActivity');
    const barPro = document.getElementById('barPro');

    // Leaderboard + rewards refs (avoid relying on implicit window.id globals)
    const lbSkillPts = document.getElementById('lbSkillPts');
    const lbActPts = document.getElementById('lbActPts');
    const lbProBoost = document.getElementById('lbProBoost');
    const lbTickets = document.getElementById('lbTickets');
    const lbLottery = document.getElementById('lbLottery');
    const lbWinners = document.getElementById('lbWinners');
    const lbClaim = document.getElementById('lbClaim');
    const lbNextEst = document.getElementById('lbNextEst');
    const btnClaimPayout = document.getElementById('btnClaimPayout');
    const btnMintBadge = document.getElementById('btnMintBadge');

    function renderSplitBars() {
      barSkill.style.width = ECON.SPLIT.skill + '%';
      barActivity.style.width = ECON.SPLIT.activity + '%';
      barPro.style.width = ECON.SPLIT.pro + '%';
    }

    // ----- Play view actions + Game Library -----
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnClaimPromo = document.getElementById('btnClaimPromo');
    const btnOpenWallet = document.getElementById('btnOpenWallet');
    const btnOpenSuggestions = document.getElementById('btnOpenSuggestions');
    const gameFrame = document.getElementById('gameFrame');
    const gameTiles = document.getElementById('gameTiles');

    function suppressGameFrameScrollbars() {
      if (!gameFrame) return;
      try {
        const doc = gameFrame.contentDocument;
        if (!doc) return;
        doc.documentElement.style.overflow = 'hidden';
        if (doc.body) doc.body.style.overflow = 'hidden';
      } catch {}
    }

    try { gameFrame?.addEventListener('load', suppressGameFrameScrollbars); } catch {}

    const playTitle = document.getElementById('playTitle');
    const playDesc = document.getElementById('playDesc');
    const pillRunCost = document.getElementById('pillRunCost');
    const playMetricsKv = document.getElementById('playMetricsKv');
    const playMetricsHint = document.getElementById('playMetricsHint');

    btnOpenWallet.addEventListener('click', ()=>setView('wallet'));
    btnOpenSuggestions.addEventListener('click', ()=>setView('proposals'));
    btnFullscreen.addEventListener('click', ()=>{
      const portal = document.getElementById('portal');
      if (!document.fullscreenElement) portal.requestFullscreen?.();
      else document.exitFullscreen?.();
    });

    async function loadCatalog() {
      try {
        const res = await fetch(MANIFEST_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('manifest not ok');
        CATALOG = await res.json();
      } catch (e) {
        CATALOG = FALLBACK_CATALOG;
      }
      function normalizeMetric(m) {
        if (!m || typeof m !== 'object') return null;
        const id = String(m.id || m.metricId || m.key || '').trim();
        if (!id) return null;
        return {
          id,
          label: (m.label != null) ? String(m.label) : id,
          kind: (m.kind != null) ? String(m.kind) : undefined,
          direction: (m.direction != null) ? String(m.direction) : (m.dir != null ? String(m.dir) : undefined),
          unit: (m.unit != null) ? String(m.unit) : undefined,
          eligible: (m.eligible === false) ? false : true,
          payoutEligible: (m.payoutEligible === false) ? false : true,
          minDurationMs: (m.minDurationMs != null) ? Number(m.minDurationMs) : undefined,
          scoreMax: (m.scoreMax != null) ? Number(m.scoreMax) : undefined
        };
      }

      function normalizeGameEntry(g) {
        if (!g || typeof g !== 'object') return null;
        const id = String(g.id || g.gameId || '').trim();
        if (!id) return null;

        const runCostAC = Number(g.runCostAC || 0);
        const metrics = Array.isArray(g.metrics) ? g.metrics.map(normalizeMetric).filter(Boolean) : [];
        const defaultMetric = String(g.defaultMetric || g.defaultMetricId || (metrics[0] ? metrics[0].id : 'score') || 'score');

        const embedUrl = String(g.embedUrl || g.url || g.path || (`/games/${id}/`));

        const runTypePolicy = (g.runTypePolicy != null)
          ? String(g.runTypePolicy)
          : (runCostAC > 0 ? 'paid' : 'free');

        const sandboxPolicy = (g.sandboxPolicy != null) ? String(g.sandboxPolicy) : 'strict';

        const allowList = Array.isArray(g.allowList) ? g.allowList.map(String) : undefined;

        return {
          ...g,
          id,
          name: String(g.name || g.title || id),
          tagline: (g.tagline != null) ? String(g.tagline) : '',
          status: String(g.status || 'live'),
          embedUrl,
          runCostAC,
          defaultMetric,
          metrics,
          runTypePolicy,
          sandboxPolicy,
          allowList
        };
      }

      GAMES = Array.isArray(CATALOG?.games) ? CATALOG.games.map(normalizeGameEntry).filter(Boolean) : [];
      if (!GAMES.length) GAMES = (FALLBACK_CATALOG.games || []).map(normalizeGameEntry).filter(Boolean);
      return CATALOG;
    }

    function gameById(id) {
      const gid = String(id || '');
      return (GAMES || []).find(g => g.id === gid || String(g.gameId || '') === gid) || null;
    }

    function clampGameId(id) {
      if (gameById(id)) return id;
      const firstLive = (GAMES||[]).find(g => g.status === 'live') || (GAMES||[])[0];
      return firstLive ? firstLive.id : 'moonshot';
    }

    function renderGameTiles() {
      if (!gameTiles) return;
      gameTiles.innerHTML = '';
      (GAMES||[]).forEach(g => {
        const isActive = g.id === currentGameId;
        const disabled = g.status !== 'live';
        const el = document.createElement('div');
        el.className = 'gameTile' + (isActive ? ' active' : '') + (disabled ? ' disabled' : '');
        el.innerHTML = `
          <div class="n">${g.name}</div>
          <div class="d">${g.tagline || ''}</div>
          <div class="meta">
            <span class="badge ${disabled ? 'soon':'live'}">${disabled ? 'coming soon' : 'live'}</span>
            <span class="badge">${disabled ? '—' : fmtCreditsPerRun(g.runCostAC)}</span>
          </div>
        `;
        el.addEventListener('click', ()=>{
          if (disabled) {
            toast('Coming soon', 'This game is not live yet.');
            return;
          }
          selectGame(g.id);
        });
        gameTiles.appendChild(el);
      });
    }

    function setPlayCopy() {
      const g = currentGame;
      if (!g) {
        playTitle.textContent = 'Choose a game';
        playDesc.textContent = 'Select a live game from the library.';
        pillRunCost.textContent = 'Loading · -- Credits/run';
        btnClaimPromo.textContent = 'Claim promo (Tx)';
        if (playMetricsKv) playMetricsKv.textContent = '';
        if (playMetricsHint) playMetricsHint.textContent = 'Select a game to view its metrics.';
        return;
      }
      playTitle.textContent = g.name;
      const promoLine = (g.promoRuns && g.promoRuns > 0) ? (`Promo: first ${g.promoRuns} runs free (claim is gas-paid later).`) : 'No promo currently.';
      playDesc.textContent = `Run cost: ${fmtCredits(g.runCostAC)} ($${(g.runCostAC*ECON.AC_USD).toFixed(2)}). ${promoLine}`;
      pillRunCost.textContent = `${g.name} · ${fmtCreditsPerRun(g.runCostAC)}`;
      const claimed = getBool(K.promoClaimed(currentGameId));
      btnClaimPromo.textContent = claimed ? 'Promo claimed' : 'Claim promo (Tx)';
      btnClaimPromo.disabled = claimed || !(g.promoRuns > 0);

      // Metrics block
      try {
        if (playMetricsKv) {
          playMetricsKv.textContent = '';

          const addRow = (k, v) => {
            const kk = document.createElement('div');
            kk.className = 'k';
            kk.textContent = String(k);

            const vv = document.createElement('div');
            vv.className = 'v';
            vv.textContent = String(v);

            playMetricsKv.appendChild(kk);
            playMetricsKv.appendChild(vv);
          };

          const metrics = Array.isArray(g.metrics) ? g.metrics : [];
          const defaultMetric = g.defaultMetric ? String(g.defaultMetric) : '';
          const usesCreditsInRun = (g.usesCreditsInRun != null) ? !!g.usesCreditsInRun : (Number(g.runCostAC || 0) > 0);

          const eligible = metrics.filter(m => m && m.eligible !== false);
          const defaultLabel = metrics.find(m => m && String(m.id) === defaultMetric)?.label || defaultMetric || '—';

          addRow('Run uses Credits', usesCreditsInRun ? 'Yes' : 'No');
          addRow('Default metric', defaultLabel || '—');
          addRow('Eligible metrics', eligible.length ? eligible.map(m => m.label || m.id).join(', ') : '—');

          if (metrics.length) {
            addRow('All metrics', metrics.map(m => {
              const label = m.label || m.id || 'metric';
              const kind = m.kind ? String(m.kind) : '';
              const dir = m.direction ? String(m.direction) : '';
              const unit = m.unit ? String(m.unit) : '';
              const tag = [kind, dir, unit].filter(Boolean).join(' · ');
              const elig = (m.eligible === false) ? 'ineligible' : 'eligible';
              return tag ? `${label} (${tag}, ${elig})` : `${label} (${elig})`;
            }).join(' | '));
          }
        }

        if (playMetricsHint) playMetricsHint.textContent = 'Metrics are read from the game catalog.';
      } catch {
        try {
          if (playMetricsHint) playMetricsHint.textContent = 'Metrics unavailable.';
          if (playMetricsKv) playMetricsKv.textContent = '';
        } catch {}
      }
    }

    function selectGame(id) {
      currentGameId = clampGameId(id);
      currentGame = gameById(currentGameId);
      lsSet(K.selectedGame, currentGameId);

      frameReady = false;
      try {
        if (currentGame && gameController) {
          gameController.mount({
            id: currentGame.id,
            title: currentGame.name,
            url: currentGame.embedUrl,
            defaultMetric: currentGame.defaultMetric,
            metrics: (Array.isArray(currentGame.metrics) ? currentGame.metrics.map(m => String(m.id)) : []),
            runTypePolicy: currentGame.runTypePolicy,
            sandboxPolicy: currentGame.sandboxPolicy,
            allowList: currentGame.allowList
          });
        } else if (gameFrame && currentGame) {
          gameFrame.src = currentGame.embedUrl;
        }
      } catch {}
      suppressGameFrameScrollbars();

      renderGameTiles();
      setPlayCopy();
      renderAll();

      // Reset run-mode pill until the game reports a run.
      const pill = document.getElementById('pillRunMode');
      if (pill) pill.textContent = 'Run type: --';
    }

    function claimPromoTx(gameId) {
      const g = gameById(gameId);
      if (!g || !(g.promoRuns > 0)) {
        toast('No promo', 'This game has no promo right now.');
        return;
      }
      if (getBool(K.promoClaimed(gameId))) {
        toast('Promo already claimed', 'You already claimed the promo for this game.');
        return;
      }
      openTxConfirm({
        title: `Claim Promo · ${g.name}`,
        desc: `Claim ${g.promoRuns} free runs (adds ${Math.max(0, Math.floor(Number(g.promoGrantAC)||0))} promo Credits for ${g.name}).`,
        gasEth: '0.00004',
        preview: `Writes: ${K.promoClaimed(gameId)}=1, +${g.promoGrantAC} to ${K.promoBal(gameId)}`,
        onConfirm: ()=>{
          simulateTx({
            kind:'promo-claim',
            label:`Claim ${g.promoRuns} free runs · ${g.name}`,
            gasEth:'0.00004',
            apply: async ()=>{
              // Server-authoritative promo claim (idempotent)
              try{
                const r = await serverClaimPromo(gameId);
                setBool(K.promoClaimed(gameId), true);
                if (r && r.promoAC!=null) setInt(K.promoBal(gameId), r.promoAC);
              } catch {
                setBool(K.promoClaimed(gameId), true);
                setInt(K.promoBal(gameId), getInt(K.promoBal(gameId),0) + Number(g.promoGrantAC||0));
              }
              syncToGame();
              sendToGame('ARCADE:PROMO_CLAIMED', { gameId, promoAC: getInt(K.promoBal(gameId),0) });
            }
          });
        }
      });
    }

    btnClaimPromo.addEventListener('click', ()=>claimPromoTx(currentGameId));

    // Leaderboard game select options (populated after catalog load)
    const lbGameSelect = document.getElementById('lbGameSelect');
    function getLbGameId() {
      try {
        const v = (lbGameSelect && lbGameSelect.value) ? String(lbGameSelect.value) : String(lsGet(K.lbGame) || currentGameId);
        return clampGameId(v);
      } catch {
        return currentGameId;
      }
    }
    function getLbPeriod() {
      try { return String(lsGet(K.lbPeriod) || 'daily'); } catch { return 'daily'; }
    }
    function populateLbSelect() {
      if (!lbGameSelect) return;
      lbGameSelect.innerHTML = '';
      (GAMES||[]).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g.id;
        opt.textContent = g.name;
        lbGameSelect.appendChild(opt);
      });
      const saved = lsGet(K.lbGame) || currentGameId;
      lbGameSelect.value = clampGameId(saved);
    }
    lbGameSelect?.addEventListener('change', ()=>{
      lsSet(K.lbGame, lbGameSelect.value);
      renderAll();
    });

    // ----- Wallet UI v1.0 (authoritative) -----
    const WALLET_V1 = { loaded:false, loading:false };

    function ensureStylesheetOnce(id, href) {
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    }

    function loadScriptOnce(id, src) {
      return new Promise((resolve, reject) => {
        if (document.getElementById(id)) return resolve(true);
        const s = document.createElement('script');
        s.id = id;
        s.src = src;
        s.async = true;
        s.onload = () => resolve(true);
        s.onerror = () => reject(new Error('Failed to load ' + src));
        document.body.appendChild(s);
      });
    }

    function mkTxHash() {
      const hex = '0123456789abcdef';
      let out = '0x';
      for (let i=0;i<64;i++) out += hex[(Math.random()*16)|0];
      return out;
    }

    function sumPromoCreditsAllGames() {
      try {
        const list = Array.isArray(GAMES) && GAMES.length ? GAMES : [];
        if (list.length) return list.reduce((sum, g) => sum + getInt(K.promoBal(g.id), 0), 0);
      } catch {}
      try {
        let sum = 0;
        for (let i=0;i<localStorage.length;i++) {
          const k = localStorage.key(i);
          if (k && k.startsWith('arcade.credits.promo.')) sum += parseInt(localStorage.getItem(k) || '0', 10) || 0;
        }
        return sum;
      } catch {
        return getInt(K.promoBal(currentGameId), 0);
      }
    }

    const STUDIO = {
      channel: 'GRUESOME_ARCADE_V1',
      frameUrl: '/avatar_studio/',
      requestSeq: 0,
      ready: false,
      pendingMint: null,
    };

    let AVATAR_PROMO_PREVIEW_PNG = null;
    let T_AVATAR_PROMO = 0;

    const avatarStudioModal = document.getElementById('avatarStudioModal');
    const btnAvatarStudioClose = document.getElementById('btnAvatarStudioClose');
    const avatarStudioFrame = document.getElementById('avatarStudioFrame');

    function isAvatarStudioOpen(){
      try { return !!(avatarStudioModal && avatarStudioModal.classList.contains('show')); } catch { return false; }
    }

    function ensureAvatarStudioFrameLoaded(){
      if (!avatarStudioFrame) return false;
      const src = String(avatarStudioFrame.getAttribute('src') || '');
      if (src && src !== 'about:blank') return true;
      try {
        avatarStudioFrame.setAttribute('src', STUDIO.frameUrl);
        avatarStudioFrame.addEventListener('load', () => {
          STUDIO.ready = true;
          try { studioInit(); } catch {}
        }, { once: true });
        return true;
      } catch {
        return false;
      }
    }

    function shouldRotateAvatarPromoPreview(){
      try{
        if (document.body.dataset.view !== 'wallet') return false;
        if (isAvatarStudioOpen()) return false;
        if (getBool(K.avatarMinted)) return false;

        // If they already have a draft, don't override it with marketing previews.
        const hasDraft = (() => {
          try {
            const raw = lsGet(K.avatarStudio);
            return !!(raw && String(raw).length > 2);
          } catch {
            return false;
          }
        })();
        if (hasDraft) return false;

        return true;
      } catch {
        return false;
      }
    }

    function requestAvatarPromoPreview(){
      if (!shouldRotateAvatarPromoPreview()) return;
      ensureAvatarStudioFrameLoaded();
      studioSend('GA_STUDIO_REQUEST_RANDOM_PREVIEW', {});
    }

    function stopAvatarPromoRotation(){
      if (T_AVATAR_PROMO) clearInterval(T_AVATAR_PROMO);
      T_AVATAR_PROMO = 0;
    }

    function startAvatarPromoRotation(){
      stopAvatarPromoRotation();
      if (!shouldRotateAvatarPromoPreview()) return;
      ensureAvatarStudioFrameLoaded();
      requestAvatarPromoPreview();
      T_AVATAR_PROMO = setInterval(() => {
        if (!shouldRotateAvatarPromoPreview()) return stopAvatarPromoRotation();
        requestAvatarPromoPreview();
      }, 3000);
    }

    function studioSend(type, payload) {
      const f = avatarStudioFrame;
      if (!f || !f.contentWindow) return false;
      const msg = { channel: STUDIO.channel, type, requestId: String(++STUDIO.requestSeq), payload: payload || {} };
      try { f.contentWindow.postMessage(msg, window.location.origin); } catch { return false; }
      return true;
    }

    function studioInit() {
      const address = String(lsGet(K.address) || '');
      const minted = getBool(K.avatarMinted);
      const tokenId = minted ? String(lsGet(K.avatarTokenId) || '') : '';
      const nickname = String(lsGet(K.avatarNick) || '');
      const linea = {
        chainId: 59144,
        chainIdHex: '0xe708',
        chainName: 'Linea',
        rpcUrl: 'https://rpc.linea.build',
        explorer: 'https://lineascan.build',
      };
      const studioState = (()=>{ try { return JSON.parse(lsGet(K.avatarStudio) || 'null'); } catch { return null; } })();
      studioSend('GA_STUDIO_INIT', { address, proActive: proActive(), minted, tokenId, nickname, studioState, linea });
      studioSend('GA_STUDIO_REQUEST_SNAPSHOT', {});
    }

    function openAvatarStudioModal() {
      if (!avatarStudioModal) return;
      stopAvatarPromoRotation();
      showOverlay(avatarStudioModal);

      ensureAvatarStudioFrameLoaded();

      try { studioInit(); } catch {}
    }

    function closeAvatarStudioModal() {
      if (!avatarStudioModal) return;
      hideOverlay(avatarStudioModal);
      // Resume rotating promo preview only if we're still on wallet and still eligible.
      startAvatarPromoRotation();
    }

    function handleStudioMessage(m, ev) {
      if (!m || m.channel !== STUDIO.channel) return;
      if (ev && ev.origin && ev.origin !== window.location.origin) return;

      if (m.type === 'GA_STUDIO_READY') {
        STUDIO.ready = true;
        try { studioInit(); } catch {}
        return;
      }

      if (m.type === 'GA_STUDIO_SNAPSHOT') {
        const p = m.payload || {};
        try {
          if (p.nickname != null) lsSet(K.avatarNick, String(p.nickname || ''));
          if (p.hash != null) lsSet(K.avatarHash, String(p.hash || ''));
          if (p.previewPng != null) lsSet(K.avatarPreviewPng, String(p.previewPng || ''));
          if (p.studioState != null) lsSet(K.avatarStudio, JSON.stringify(p.studioState));
          if (typeof p.minted === 'boolean') setBool(K.avatarMinted, p.minted);
          if (p.minted && p.tokenId != null) lsSet(K.avatarTokenId, String(p.tokenId || ''));
          if (p.minted && p.explorerUrl != null) lsSet(K.avatarExplorerUrl, String(p.explorerUrl || '#'));
        } catch {}
        return;
      }

      if (m.type === 'GA_STUDIO_RANDOM_PREVIEW') {
        const p = m.payload || {};
        try {
          const png = p.previewPng != null ? String(p.previewPng || '') : '';
          AVATAR_PROMO_PREVIEW_PNG = png ? png : null;
        } catch {
          AVATAR_PROMO_PREVIEW_PNG = null;
        }
        return;
      }

      if (m.type === 'GA_STUDIO_REQUEST_MINT') {
        const payload = m.payload || {};
        mintAvatarLineaFacade(payload).then((r)=>{
          studioSend('GA_STUDIO_MINT_RESULT', r);
        }).catch((e)=>{
          studioSend('GA_STUDIO_MINT_RESULT', { ok:false, error: String(e && e.message ? e.message : e) });
        });
        return;
      }

      if (m.type === 'GA_STUDIO_MINT_RESULT') {
        const r = m.payload || {};
        const pending = STUDIO.pendingMint;
        STUDIO.pendingMint = null;
        if (pending && typeof pending.resolve === 'function') pending.resolve(r);
        return;
      }
    }

    btnAvatarStudioClose?.addEventListener('click', closeAvatarStudioModal);
    // Dismissal (ESC / click-outside) is handled by the overlay manager.

    async function ensureLineaWallet() {
      const eth = window.ethereum;
      if (!eth || !eth.request) return false;
      const want = '0xe708';
      let current = null;
      try { current = await eth.request({ method: 'eth_chainId' }); } catch {}
      if (String(current || '').toLowerCase() === want) return true;

      try {
        await eth.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: want }] });
        return true;
      } catch {
        try {
          await eth.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: want,
              chainName: 'Linea',
              nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
              rpcUrls: ['https://rpc.linea.build'],
              blockExplorerUrls: ['https://lineascan.build'],
            }],
          });
          await eth.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: want }] });
          return true;
        } catch {
          return false;
        }
      }
    }

    async function mintAvatarLineaFacade(payload) {
      if (!proActive()) {
        return { ok:false, error:'PRO (Studio $2+) is required to mint an avatar.' };
      }

      try { await ensureLineaWallet(); } catch {}

      return await new Promise((resolve) => {
        openTxConfirm({
          title: 'Mint Avatar (Linea)',
          desc: 'Mint your avatar on Linea. (Staged — simulated tx until contracts are finalized.)',
          gasEth: '0.00006',
          preview: 'Writes: avatar minted flags + tokenId (mock).',
          onConfirm: ()=>{
            const txHash = mkTxHash();
            const tokenId = String(Math.floor(100000 + Math.random()*900000));
            const explorerUrl = '#';
            simulateTx({
              kind:'avatar-mint',
              label:'Mint avatar',
              gasEth:'0.00006',
              apply: async ()=>{
                setBool(K.avatarMinted, true);
                lsSet(K.avatarTokenId, tokenId);
                lsSet(K.avatarExplorerUrl, explorerUrl);
                resolve({ ok:true, txHash, tokenId, explorerUrl, payload: payload || {} });
              }
            });
          }
        });
      });
    }

    function buyCreditsTx({ usd, minTotalCredits }, modeLabel='usd') {
      const safeUsd = clamp(Number(usd||0), 0.01, 100000);
      const minCredits = Math.max(1, Math.floor(Number(minTotalCredits || 0)));
      const label = `Buy ${fmtCredits(minCredits)}`;
      return new Promise((resolve) => {
        openTxConfirm({
          title: 'Buy Credits',
          desc: `Pay $${safeUsd.toFixed(2)} equivalent to receive ${fmtCredits(minCredits)}. (Simulated tx in this build.)`,
          gasEth: '0.00006',
          preview: `Mode: ${modeLabel} · Adds +${minCredits} to ${K.paid}.`,
          onConfirm: ()=>{
            const txHash = mkTxHash();
            simulateTx({
              kind:'buy-ac',
              label,
              gasEth:'0.00006',
              apply: async ()=>{
                try{
                  const r = await serverBuyAC(safeUsd);
                  if (r && r.paidAC!=null) setInt(K.paid, r.paidAC);
                  else setInt(K.paid, getInt(K.paid,0) + minCredits);
                } catch {
                  setInt(K.paid, getInt(K.paid,0) + minCredits);
                }
                try { await refreshLedger(); } catch {}
                renderTopChips();
                syncToGame();
                resolve({ txHash });
              }
            });
          }
        });
      });
    }

    function activateProTx(tier) {
      const price = (tier===1) ? 2 : (tier===2) ? 25 : 100;
      const mapped = (tier===1) ? 'mini' : (tier===2) ? 'prime' : 'lifetime';
      const label = (mapped==='lifetime') ? 'Activate PRO Lifetime' : `Activate PRO ${mapped}`;
      return new Promise((resolve) => {
        openTxConfirm({
          title: 'Activate PRO',
          desc: `Activate tier ${tier} for $${price}. (Simulated tx in this build.)`,
          gasEth: '0.00007',
          preview: `Writes: ${K.proTier}=${mapped}, updates expiry (monthly) or lifetime.`,
          onConfirm: ()=>{
            const txHash = mkTxHash();
            simulateTx({
              kind:'pro',
              label,
              gasEth:'0.00007',
              apply: async ()=>{
                lsSet(K.proTier, mapped);
                if (mapped === 'lifetime') setInt(K.proExp, 0);
                else setInt(K.proExp, now() + 30*24*3600*1000);
                try{ await serverProfilePatch({ proTier: mapped, proExp: String(getInt(K.proExp,0)) }); } catch {}
                renderTopChips();
                resolve({ txHash });
              }
            });
          }
        });
      });
    }

    function mintAvatarTx(payload) {
      return mintAvatarLineaFacade(payload || {});
    }

    function buildWalletAdapter() {
      return {
        connect: async () => {
          if (getBool(K.connected) && (lsGet(K.address) || '')) {
            return { address: String(lsGet(K.address) || ''), chainId: null, chainName: 'Connected' };
          }
          try { bootAccessGateEveryRefresh(); } catch {}

          // Poll local session state (gate posts a message which sets localStorage)
          const start = now();
          while (now() - start < 60000) {
            if (getBool(K.connected) && (lsGet(K.address) || '')) break;
            await new Promise(r => setTimeout(r, 250));
          }
          try { await refreshSession(true); } catch {}
          const address = String(lsGet(K.address) || '');
          if (!address) throw new Error('Wallet connection was rejected or timed out.');
          return { address, chainId: null, chainName: 'Connected' };
        },

        getSnapshot: async (_address) => {
          try { await refreshSession(true); } catch {}

          const address = String(lsGet(K.address) || '');
          const paidCredits = getInt(K.paid, 0);
          const promoCredits = sumPromoCreditsAllGames();
          const pohVerified = getBool(K.poh) || !!(SESSION && SESSION.pohVerified);

          let expiresAt = null;
          const tierStr = String(lsGet(K.proTier) || 'none');
          const tier = (tierStr === 'mini') ? 1 : (tierStr === 'prime') ? 2 : (tierStr === 'lifetime') ? 3 : 0;
          if (tierStr !== 'none' && tierStr !== 'lifetime') {
            const ms = getInt(K.proExp, 0);
            expiresAt = ms > 0 ? ms : null;
          }
          const membership = { tier, expiresAt, active: proActive() };

          const minted = getBool(K.avatarMinted);
          const tokenId = minted ? String(lsGet(K.avatarTokenId) || '') : null;
          const explorerUrl = minted ? String(lsGet(K.avatarExplorerUrl) || '#') : null;
          const nickname = String(lsGet(K.avatarNick) || '') || null;
          const hash = String(lsGet(K.avatarHash) || '') || null;
          const previewPng = String(lsGet(K.avatarPreviewPng) || '') || null;
          const hasDraft = (() => {
            try {
              const raw = lsGet(K.avatarStudio);
              return !!(raw && String(raw).length > 2);
            } catch {
              return false;
            }
          })();

          const promoPreviewPng = (!minted && !previewPng && !hasDraft) ? (AVATAR_PROMO_PREVIEW_PNG || null) : null;

          const nextPayoutAt = (()=>{
            try {
              const d = EPOCH_CACHE && EPOCH_CACHE.data ? EPOCH_CACHE.data : null;
              if (d && d.nextPayoutAt != null) {
                const x = Number(d.nextPayoutAt);
                if (Number.isFinite(x) && x > 0) return x;
              }
            } catch {}
            return nextUtcMidnightMs();
          })();

          const epochData = (()=>{
            try { return (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : null; } catch { return null; }
          })();
          const todayTickets = (()=>{
            const x = epochData ? Number(epochData.todayTickets) : NaN;
            return Number.isFinite(x) ? Math.max(0, Math.floor(x)) : 0;
          })();
          const lotteryTicketsEligible = (epochData && typeof epochData.lotteryTicketsEligible === 'boolean')
            ? epochData.lotteryTicketsEligible
            : null;

          return {
            pohVerified,
            paidCredits,
            promoCredits,
            nextPayoutAt,
            gpToday: 0,
            todayTickets,
            lotteryTicketsEligible,
            membership,
            avatar: { minted, tokenId, explorerUrl, nickname, hash, previewPng, promoPreviewPng, hasDraft },
            ethUsd: 2300,
          };
        },

        quoteEthForUsd: async (usd) => {
          const ethUsd = 2300;
          const u = Math.max(0, Number(usd) || 0);
          const ethAmount = ethUsd > 0 ? (u / ethUsd) : 0;
          return { ethUsd, ethAmount };
        },

        buyCredits: async (payload) => {
          const p = payload || {};
          return buyCreditsTx({ usd: p.usd, minTotalCredits: p.minTotalCredits }, p.mode || 'usd');
        },

        activateMembership: async (tier) => {
          return activateProTx(Number(tier) || 0);
        },

        openAvatarStudio: async () => {
          setView('wallet');
          openAvatarStudioModal();
          return {};
        },

        openEmbed: async (title, url) => {
          try { openEmbed(String(title || 'Embed'), String(url || 'about:blank')); } catch {}
          return {};
        },

        mintAvatar: async () => {
          setView('wallet');
          openAvatarStudioModal();

          if (!STUDIO.ready) {
            return mintAvatarTx({ source: 'wallet_fallback' });
          }

          return await new Promise((resolve) => {
            STUDIO.pendingMint = { resolve };
            const sent = studioSend('GA_STUDIO_REQUEST_MINT', { source: 'wallet' });
            if (!sent) {
              STUDIO.pendingMint = null;
              resolve(mintAvatarTx({ source: 'wallet_fallback' }));
            }
          });
        },
      };
    }

    async function ensureWalletV1Loaded() {
      if (WALLET_V1.loaded || WALLET_V1.loading) return;
      WALLET_V1.loading = true;
      const host = document.getElementById('walletV1Host');
      if (!host) { WALLET_V1.loading = false; return; }

      // Adapter must exist before wallet.js initializes.
      try {
        const adapter = buildWalletAdapter();
        window.__ARCADE_WALLET_ADAPTER__ = adapter;
        window.ARCADE_WALLET_ADAPTER = adapter;
      } catch {}

      // Styles (scoped under .ga-wallet)
      try { ensureStylesheetOnce('gaWalletFonts', 'https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Inter:wght@300;400;600;700&display=swap'); } catch {}
      try { ensureStylesheetOnce('gaWalletCss', '/gruesome-arcade-wallet-ui-v1.0/wallet.css'); } catch {}

      // Markup
      try {
        const r = await fetch('/gruesome-arcade-wallet-ui-v1.0/wallet-panel.html', { cache: 'no-store' });
        if (!r.ok) throw new Error('wallet panel not ok');
        host.innerHTML = await r.text();
      } catch (e) {
        host.innerHTML = '<div class="card"><div class="inner"><h3>Wallet failed to load</h3><div class="muted">Could not load wallet-panel.html. Check that /public/gruesome-arcade-wallet-ui-v1.0/ is being served.</div></div></div>';
        WALLET_V1.loading = false;
        return;
      }

      // Behavior
      try {
        await loadScriptOnce('gaWalletJs', '/gruesome-arcade-wallet-ui-v1.0/wallet.js');
      } catch (e) {
        toast('Wallet error', 'Failed to load wallet.js');
      }

      WALLET_V1.loaded = true;
      WALLET_V1.loading = false;
    }


    // ----- Rewards actions -----
    if (btnClaimPayout) btnClaimPayout.addEventListener('click', ()=>{
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;
      const amt = rec ? Number(rec.totalUsd || 0) : 0;

      if (!SESSION.authenticated) return toast('Connect wallet', 'Required to claim.');
      if (!SESSION.pohVerified) return toast('PoH required', 'Verify Proof of Humanity to claim payouts.');
      if (!rec || amt <= 0) return toast('No claimable rewards', 'Play more to earn rewards.');
      if (claimed) return toast('Already claimed', 'This epoch is already claimed.');

      openTxConfirm({
        title: 'Claim mUSD payout',
        desc: `Claim ${amt.toFixed(2)} mUSD from the last settled epoch. (User pays gas)`,
        gasEth: '0.00006',
        preview: `Writes: epoch claim (${rec.ymd || ''}) · Server records claim + audit.`,
        onConfirm: ()=>{
          simulateTx({
            kind:'claim',
            label:`Claim ${amt.toFixed(2)} mUSD`,
            gasEth:'0.00006',
            apply: async ()=>{
              try{
                await serverEpochClaim(rec.ymd || '');
                await refreshEpochStatus(true);
                await refreshLedger();
              } catch(e){
                toast('Claim failed', (e&&e.message)?String(e.message):'server error');
              }
            }
          });
        }
      });
    });

    if (btnMintBadge) btnMintBadge.addEventListener('click', ()=>{
      if (!SESSION.authenticated) return toast('Connect wallet', 'Required to mint.');
      openTxConfirm({
        title: 'Mint daily badge',
        desc: 'Mint a daily badge. Grants small XP + promo Credits. (User pays gas)',
        gasEth: '0.00005',
        preview: `Writes: daily badge minted · Grants: +3 XP, +2 promo Credits (${currentGameId}).`,
        onConfirm: ()=>{
          simulateTx({
            kind:'badge',
            label:'Mint daily badge',
            gasEth:'0.00005',
            apply: async ()=>{
              try{
                await serverMintBadge(currentGameId);
                await refreshEpochStatus(true);
                await refreshLedger();
              } catch(e){
                toast('Mint failed', (e&&e.message)?String(e.message):'server error');
              }
            }
          });
        }
      });
    });



    const expoLeft = document.getElementById('expoLeft');
    function renderExpoCountdown() {
      if (!expoLeft) return;
      const ms = ECON.EXPO_END_UTC - now();
      expoLeft.textContent = fmtCountdown(ms);
    }

    // ----- Avatar (legacy studio modal, invoked via adapter) -----
    const avBg = document.getElementById('avBg');
    const avAcc = document.getElementById('avAcc');
    const avEyes = document.getElementById('avEyes');
    const avMouth = document.getElementById('avMouth');
    const btnAvRandom = document.getElementById('btnAvRandom');
    const btnAvSave = document.getElementById('btnAvSave');
    const avatarSvgHost = document.getElementById('avatarSvgHost');
    const avatarEdits = document.getElementById('avatarEdits');
    const avatarProReq = document.getElementById('avatarProReq');
    const avatarLast = document.getElementById('avatarLast');
    const avatarLvl = document.getElementById('avatarLvl');
    const avatarCard = document.getElementById('avatarCard');

    const BG = {
      nebula: ['#050b1a','#0ea5e9','#22d3ee'],
      void: ['#000000','#111827','#334155'],
      aurora: ['#03151a','#22c55e','#22d3ee'],
      mars: ['#120608','#f97316','#ffdd55']
    };

    function getAvatarDNA() {
      try {
        const d = JSON.parse(lsGet(K.avatar) || 'null');
        if (d && typeof d === 'object') return d;
      } catch {}
      return { bg:'nebula', acc:'antenna', eyes:'dots', mouth:'smile' };
    }
    function setAvatarDNA(d) { lsSet(K.avatar, JSON.stringify(d)); }

    function svgRect(x,y,w,h,fill) {
      return `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${fill}"/>`;
    }
    function renderAvatarSvg(dna) {
      const size = 16;
      const [bg0,bg1,bg2] = BG[dna.bg] || BG.nebula;

      const skin = 'rgba(229,231,235,0.92)';
      const outline = 'rgba(0,0,0,0.55)';
      const accent = getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#22d3ee';

      const head = [
        [4,4,8,8], // main
        [5,3,6,1],
        [5,12,6,1]
      ];

      let rects = '';
      rects += svgRect(0,0,size,size,bg0);
      rects += svgRect(0,0,size,6,bg1);
      rects += svgRect(0,6,size,10,bg0);
      rects += svgRect(0,10,size,6,bg2);

      head.forEach(([x,y,w,h])=>{ rects += svgRect(x,y,w,h,skin); });
      rects += svgRect(4,4,8,1,outline);
      rects += svgRect(4,11,8,1,outline);
      rects += svgRect(4,4,1,8,outline);
      rects += svgRect(11,4,1,8,outline);

      if (dna.eyes === 'dots') {
        rects += svgRect(6,7,1,1,'#0b1220');
        rects += svgRect(9,7,1,1,'#0b1220');
      } else if (dna.eyes === 'angry') {
        rects += svgRect(6,7,2,1,'#0b1220');
        rects += svgRect(8,6,1,1,'#0b1220');
        rects += svgRect(9,7,2,1,'#0b1220');
        rects += svgRect(9,6,1,1,'#0b1220');
      } else {
        rects += svgRect(6,7,1,1,accent);
        rects += svgRect(9,7,1,1,accent);
        rects += svgRect(5,6,1,1,'rgba(34,211,238,0.25)');
        rects += svgRect(10,6,1,1,'rgba(34,211,238,0.25)');
      }

      if (dna.mouth === 'smile') {
        rects += svgRect(7,9,2,1,'#0b1220');
        rects += svgRect(6,8,1,1,'#0b1220');
        rects += svgRect(9,8,1,1,'#0b1220');
      } else if (dna.mouth === 'flat') {
        rects += svgRect(6,9,4,1,'#0b1220');
      } else {
        rects += svgRect(6,9,4,1,'#0b1220');
        rects += svgRect(6,10,1,1,'#0b1220');
        rects += svgRect(9,10,1,1,'#0b1220');
      }

      if (dna.acc === 'antenna') {
        rects += svgRect(8,2,1,2,accent);
        rects += svgRect(7,1,3,1,accent);
      } else if (dna.acc === 'visor') {
        rects += svgRect(5,6,6,3,'rgba(34,211,238,0.25)');
        rects += svgRect(5,6,6,1,'rgba(34,211,238,0.45)');
      } else if (dna.acc === 'cap') {
        rects += svgRect(4,3,8,2,'rgba(15,23,42,0.90)');
        rects += svgRect(5,2,6,1,'rgba(15,23,42,0.90)');
      }

      const svg = `
        <svg class="avatarSvg" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
          ${rects}
        </svg>
      `;
      return svg;
    }

    function renderAvatar() {
      if (!avatarSvgHost || !avBg || !avAcc || !avEyes || !avMouth) return;
      const dna = getAvatarDNA();
      avatarSvgHost.innerHTML = renderAvatarSvg(dna);

      avBg.value = dna.bg;
      avAcc.value = dna.acc;
      avEyes.value = dna.eyes;
      avMouth.value = dna.mouth;

      const lvl = syncLevel();
      const last = getInt(K.avatarLast, 0);
      const edits = Math.max(0, lvl - last);

      avatarEdits.textContent = String(edits);
      avatarLast.textContent = String(last);
      avatarLvl.textContent = String(lvl);
      avatarProReq.textContent = proActive() ? 'ACTIVE' : 'NOT ACTIVE';
      avatarCard.classList.toggle('pulse', !proActive() || edits === 0);
    }

    function randomChoice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
    btnAvRandom?.addEventListener('click', ()=>{
      const dna = getAvatarDNA();
      dna.bg = randomChoice(Object.keys(BG));
      dna.acc = randomChoice(['none','antenna','visor','cap']);
      dna.eyes = randomChoice(['dots','angry','glow']);
      dna.mouth = randomChoice(['smile','flat','grin']);
      setAvatarDNA(dna);
      renderAvatar();
    });

    function saveAvatarTx() {
      if (!proActive()) {
        toast('PRO required', 'Activate PRO to unlock avatar edits.');
        return;
      }
      const lvl = syncLevel();
      const last = getInt(K.avatarLast, 0);
      const edits = Math.max(0, lvl - last);
      if (edits <= 0) {
        toast('No edits available', 'You unlock 1 avatar edit each time you level up.');
        return;
      }

      const dna = {
        bg: avBg.value,
        acc: avAcc.value,
        eyes: avEyes.value,
        mouth: avMouth.value
      };
      openTxConfirm({
        title: 'Update Avatar',
        desc: 'Update your 8-bit avatar. In the final build this writes to your soulbound NFT.' ,
        gasEth: '0.00005',
        preview: `Consumes 1 edit. Writes: ${K.avatar}, ${K.avatarLast}=${lvl}`,
        onConfirm: ()=>{
          simulateTx({
            kind:'avatar',
            label:'Update avatar',
            gasEth:'0.00005',
            apply: ()=>{
              setAvatarDNA(dna);
              setInt(K.avatarLast, lvl);
            }
          });
        }
      });
    }
    btnAvSave?.addEventListener('click', saveAvatarTx);
    [avBg,avAcc,avEyes,avMouth].forEach(el => el && el.addEventListener('change', renderAvatar));

    // ----- Leaderboard (local, multi-game) -----
    const lbLocal = document.getElementById('lbLocal');
    const lbTitle = document.getElementById('lbTitle');

    function cutoffForPeriod(period) {
      const t = now();
      if (period === 'daily') {
        const d = new Date(t);
        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0,0,0);
      }
      if (period === 'weekly') return t - 7*24*3600*1000;
      return 0;
    }

    function runsFor(gameId, period) {
      const cutoff = cutoffForPeriod(period);
      const arr = getRuns(gameId);
      return (arr||[]).filter(r => Number(r.ts||0) >= cutoff);
    }

    function seedRand(seed) {
      let x = 0;
      for (let i=0;i<seed.length;i++) x = (x*31 + seed.charCodeAt(i)) >>> 0;
      return function() {
        x ^= x << 13; x >>>= 0;
        x ^= x >> 17; x >>>= 0;
        x ^= x << 5;  x >>>= 0;
        return (x >>> 0) / 4294967296;
      };
    }

    function renderLocalLB() {
      // Legacy leaderboard elements are removed when v2 is enabled.
      if (!lbLocal || !lbTitle) return;

      const gameId = getLbGameId();
      const period = getLbPeriod();
      const g = gameById(gameId);

      // Best-effort warm cache (async)
      try { refreshLeaderboard(gameId, period); } catch {}

      const key = String(gameId) + '|' + String(period);
      const haveLive = !!(API_STATE.online && SESSION.status === 'ok' && LB_CACHE.entries && LB_CACHE.key === key);

      // Header line
      lbTitle.textContent = `${g ? g.name : gameId} · ${period.charAt(0).toUpperCase()+period.slice(1)} · ${haveLive ? 'Global' : 'Local'}`;

      // Build entries
      let entries = [];
      const meAddr = (SESSION.address || lsGet(K.address) || '').toLowerCase();

      if (haveLive) {
        entries = (LB_CACHE.entries||[]).slice(0, 12).map((e, idx) => ({
          rank: e.rank || (idx+1),
          address: String(e.address||e.member||''),
          name: shortAddr(String(e.address||e.member||'')),
          best: Number(e.score||0),
          runs: '—',
          xp: '—',
          me: meAddr && String(e.address||e.member||'').toLowerCase() === meAddr
        }));

        // If you're not in top, append your row if known
        if (LB_CACHE.you && meAddr && !entries.some(x=>x.me)) {
          entries.push({
            rank: LB_CACHE.you.rank || '—',
            address: meAddr,
            name: shortAddr(meAddr),
            best: Number(LB_CACHE.you.score||0),
            runs: runsFor(gameId, period).length,
            xp: getInt(K.xp, 0),
            me: true
          });
        }
      } else {
        // Local fallback leaderboard (seeded)
        const myRuns = runsFor(gameId, period);
        const myBest = bestFromRuns(myRuns);
        const myXp = getInt(K.xp, 0);

        const r = seedRand((meAddr||'guest') + '|' + gameId + '|' + period);
        const bots = [];
        for (let i=0;i<9;i++) {
          const addr = '0x' + Math.floor(r()*0xffffffffffffff).toString(16).padStart(14,'0') + Math.floor(r()*0xffff).toString(16).padStart(4,'0');
          const bBest = Math.max(0, Math.floor(myBest * (0.65 + r()*0.7) + r()*12));
          bots.push({
            address: addr,
            name: shortAddr(addr),
            best: bBest,
            runs: Math.floor(r()*18),
            xp: Math.floor(10 + Math.log10(bBest+1)*40 + r()*200),
            me: false
          });
        }

        entries = [{ address: meAddr||'guest', name: meAddr?shortAddr(meAddr):'Guest', best: myBest, runs: myRuns.length, xp: myXp, me: true }].concat(bots);
        entries.sort((a,b)=>b.best - a.best);
        entries = entries.map((e, idx)=>({ ...e, rank: idx+1 }));
      }

      // Render table
      lbLocal.innerHTML = entries.map(e=>`
        <tr class="${e.me ? 'row-me' : ''}">
          <td class="num">${e.rank}</td>
          <td><span class="addr">${escapeHtml(e.name)}</span></td>
          <td class="num">${fmtInt(e.best)}</td>
          <td class="num">${(e.runs==='—') ? '<span class="muted">—</span>' : fmtInt(e.runs)}</td>
          <td class="num">${(e.xp==='—') ? '<span class="muted">—</span>' : fmtInt(e.xp)}</td>
        </tr>
      `).join('');

      lbMe.textContent = entries.find(e=>e.me)?.rank ? `Your rank: ${entries.find(e=>e.me).rank}` : 'Your rank: —';
    }



    function computeActivityPoints(gameId, period) {
      // Local preview only. Server is authoritative (paid-only activity = Credits spent on paid runs).
      const paidSpent = getInt(K.paidSpent, 0);
      const paidRuns = runsFor(gameId, period).filter(x => x.runType === 'paid').length;
      return Math.max(0, Math.floor((paidSpent * 1.0) + (paidRuns * 2)));
    }

    function computeSkillPoints(gameId, period) {
      const r = runsFor(gameId, period);
      const best = bestFromRuns(r);
      return Math.max(0, Math.floor(best / 25));
    }

    function renderPayoutPreview() {
      const period = String(lsGet(K.lbPeriod) || 'daily');
      const gameId = clampGameId(String(lsGet(K.lbGame) || currentGameId));

      const sp = computeSkillPoints(gameId, period);
      const ap = computeActivityPoints(gameId, period);
      const pb = proActive() ? Math.floor(ap * 0.15) : 0;

      if (lbSkillPts) lbSkillPts.textContent = String(sp);
      if (lbActPts) lbActPts.textContent = String(ap);
      if (lbProBoost) lbProBoost.textContent = String(pb);
      // Lottery tickets (today): prefer server-derived tickets (paid-only activity), fallback to local estimate.
      const serverTickets = (EPOCH_CACHE && EPOCH_CACHE.data && Number.isFinite(EPOCH_CACHE.data.todayTickets)) ? Number(EPOCH_CACHE.data.todayTickets) : null;
      const tickets = (serverTickets != null) ? Math.max(0, Math.floor(serverTickets)) : Math.max(0, Math.floor(Math.sqrt(Math.max(0, ap))));
      if (lbTickets) {
        const eligible = !!(EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.lotteryTicketsEligible);
        if (!eligible) lbTickets.innerHTML = String(tickets) + ' <small>(PRO required)</small>';
        else lbTickets.textContent = String(tickets);
      }


      const estNext = (sp*0.002) + (ap*0.0012) + (pb*0.0008);
      if (lbNextEst) lbNextEst.textContent = estNext.toFixed(2) + ' mUSD';

      // Prefer server-settled claimable rewards (last settled epoch)
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;

      if (rec && lbClaim) {
        const amt = Number(rec.totalUsd || 0);
        const lotUsd = Math.max(0, Number(rec.lotteryCents || 0) / 100);
        if (lbLottery) lbLottery.innerHTML = lotUsd.toFixed(2) + ' mUSD <small>(' + (lotUsd > 0 ? 'won' : 'settled') + ')</small>';

        lbClaim.innerHTML = amt.toFixed(2) + ' mUSD <small>(' + (claimed ? 'claimed' : 'ready') + ')</small>';
        if (btnClaimPayout) {
          btnClaimPayout.disabled = claimed || amt <= 0 || !SESSION.authenticated || !SESSION.pohVerified;
          btnClaimPayout.classList.toggle('pulse', (!btnClaimPayout.disabled && amt > 0));
        }

        // Last lottery winners (yesterday’s settled epoch)
        const w = (EPOCH_CACHE && EPOCH_CACHE.data && Array.isArray(EPOCH_CACHE.data.lastLotteryWinners)) ? EPOCH_CACHE.data.lastLotteryWinners : [];
        if (lbWinners) {
          if (!w.length) {
            lbWinners.innerHTML = '<div class="mini muted">No winners yet.</div>';
          } else {
            lbWinners.innerHTML = w.slice(0, 8).map((x, i) => `
              <div class="txItem winner">
                <div class="l">#${i + 1}</div>
                <div class="m">${escapeHtml(shortAddr(x.address || ''))}</div>
                <div class="r"><span class="pill" style="background:rgba(255,221,85,.12);border-color:rgba(255,221,85,.18)">${Number(x.prizeUsd || 0).toFixed(2)} mUSD</span></div>
              </div>
            `).join('');
          }
        }
      } else {
        if (lbClaim) lbClaim.innerHTML = '0.00 mUSD <small>(settled)</small>';
        if (lbLottery) lbLottery.innerHTML = '0.00 mUSD <small>(settled)</small>';
        if (lbWinners) lbWinners.innerHTML = '<div class="mini muted">No winners yet.</div>';
        if (btnClaimPayout) btnClaimPayout.disabled = true;
      }
    }

    // Period tab clicks
    const lbTabs = Array.from(document.querySelectorAll('#view-leaderboard .tabs .tab'));
    lbTabs.forEach(t => t.addEventListener('click', ()=>{
      lsSet(K.lbPeriod, t.dataset.period || 'daily');
      renderAll();
    }));

    // ----- Proposals -----
    const propCat = document.getElementById('propCat');
    const propTitle = document.getElementById('propTitle');
    const propDesc = document.getElementById('propDesc');
    const btnSubmitProp = document.getElementById('btnSubmitProp');
    const propList = document.getElementById('propList');
    const btnBugTx = document.getElementById('btnBugTx');
    const btnReplayTx = document.getElementById('btnReplayTx');

    function getProposals() {
      try {
        const arr = JSON.parse(lsGet(K.proposals) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function setProposals(arr) { lsSet(K.proposals, JSON.stringify(arr.slice(0,60))); }

    function renderProposals() {
      // Best-effort load from server (Redis). Local fallback stays available.
      try { refreshProposals(); } catch {}

      const canSupport = getBool(K.connected) && getBool(K.poh);

      const arrRaw = (PROP_CACHE.list && PROP_CACHE.list.length) ? PROP_CACHE.list : getProposals();
      const arr = (arrRaw||[]).map(x => ({
        id: x.id || ('p_' + Math.random().toString(16).slice(2)),
        kind: x.kind || 'feature',
        title: x.title || 'Untitled',
        desc: (x.detail || x.desc || '').trim(),
        ts: x.ts || new Date().toISOString(),
        address: x.address || '',
        status: x.status || 'submitted',
        supporters: Number(x.supporters||0),
        rewardAC: Number(x.rewardAC||50),
        claimed: !!x.claimed,
        supportedByYou: !!x.supportedByYou
      }));

      if (!arr.length) {
        propList.innerHTML = `<div class="card"><div class="muted">No proposals yet.</div>${PROP_CACHE.err?`<div class="mini muted" style="margin-top:8px">Server: ${escapeHtml(PROP_CACHE.err)}</div>`:''}</div>`;
        return;
      }

      propList.innerHTML = arr.map(p => `
        <div class="card" style="margin-bottom:10px">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px">
            <div>
              <div class="mini muted">${escapeHtml(p.kind.toUpperCase())} · <span class="addr">${escapeHtml(shortAddr(p.address||'anon'))}</span> · ${escapeHtml(new Date(p.ts).toLocaleString())}</div>
              <div style="font-weight:800;margin-top:4px">${escapeHtml(p.title)}</div>
            </div>
            <div class="pill" style="background:rgba(255,255,255,.08)">${escapeHtml(p.status)}</div>
          </div>
          <div class="mini" style="margin-top:8px">${escapeHtml(p.desc||'')}</div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
            <div class="mini muted">Supporters: ${fmtInt(p.supporters)} · Reward: ${fmtCredits(p.rewardAC)}</div>
            <div style="display:flex;gap:8px">
              <button class="btn primary" data-act="support" data-id="${escapeHtml(p.id)}" ${(!canSupport || p.supportedByYou) ? "disabled" : ""}>${p.supportedByYou ? "Supported ✓" : "Support (Tx)"}</button>
              <button class="btn" data-act="claim" data-id="${escapeHtml(p.id)}" disabled>Claim (soon)</button>
            </div>
          </div>
        </div>
      `).join('');

      // Wire handlers (server now records supports; claiming rewards stays disabled until admin acceptance is implemented).
      Array.from(propList.querySelectorAll('button[data-act]')).forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-id');
          const act = btn.getAttribute('data-act');
          if (act === 'support') supportProposalTx(id);
          if (act === 'claim') claimProposalTx(id);
        });
      });
    }



    function submitProposalTx() {
      const title = String(propTitle.value||'').trim();
      const desc = String(propDesc.value||'').trim();
      const cat = String(propCat.value||'feature');
      if (title.length < 6 || desc.length < 10) {
        toast('More detail needed', 'Add a longer title and description.');
        return;
      }
      openTxConfirm({
        title:'Submit proposal',
        desc:'Submit an idea. If accepted, you earn Credits. This is gas-paid to prevent spam.',
        gasEth:'0.00005',
        preview:'Writes a proposal hash on-chain (final build). For now: server ledger + Redis.',
        onConfirm: ()=>{
          simulateTx({
            kind:'proposal',
            label:'Submit proposal (Tx)',
            gasEth:'0.00005',
            apply: async ()=>{
              // Prefer server (Redis); fallback to local if offline.
              try {
                const data = await apiJson('/api/proposals/submit', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ kind:cat, title, detail:desc })
                });
                API_STATE.online = true;
                API_STATE.lastOk = now();
                API_STATE.lastErr = '';
                propTitle.value='';
                propDesc.value='';
                PROP_CACHE.ts = 0;
                await refreshProposals();
                toast('Proposal submitted', 'It is now visible in the public list.');
              } catch (e) {
                API_STATE.online = false;
                API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
                // local fallback
                const arr = getProposals();
                const p = {
                  id: 'p_' + Math.random().toString(16).slice(2),
                  kind: cat,
                  title,
                  desc,
                  status: 'submitted',
                  supporters: 0,
                  claimed: false,
                  createdAt: now()
                };
                arr.unshift(p);
                setProposals(arr);
                propTitle.value='';
                propDesc.value='';
                toast('Saved locally', 'Server offline — will sync when available.');
              }
              renderProposals();
            }
          });
        }
      });
    }
    btnSubmitProp.addEventListener('click', submitProposalTx);

    function supportProposalTx(id) {
      if (!id) return;
      if (!getBool(K.connected)) {
        toast('Connect first', 'You need to connect (and pass the gate) to support proposals.');
        return;
      }
      openTxConfirm({
        title:'Support proposal',
        desc:'Signal demand for this idea. Gas-paid to prevent vote spam. Supporters may earn Credits if it ships.',
        gasEth:'0.00003',
        preview:'Adds your address to the support set (final build = onchain vote).',
        onConfirm: ()=>{
          simulateTx({
            kind:'support',
            label:'Support proposal (Tx)',
            gasEth:'0.00003',
            apply: async ()=>{
              try {
                const r = await apiJson('/api/proposals/support', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ id })
                });
                API_STATE.online = true;
                API_STATE.lastOk = now();
                API_STATE.lastErr = '';
                if (r && r.alreadySupported) {
                  toast('Already supported', 'You have already supported this proposal.');
                } else {
                  toast('Support recorded', 'Thanks — this increases priority.');
                }
                PROP_CACHE.ts = 0;
                await refreshProposals();
              } catch (e) {
                API_STATE.online = false;
                API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
                // local fallback (best effort)
                const arr = getProposals();
                const p = arr.find(x => x.id === id);
                if (p) p.supporters = Number(p.supporters||0) + 1;
                setProposals(arr);
                toast('Saved locally', 'Server offline — your support will sync later.');
              }
              renderProposals();
            }
          });
        }
      });
    }

    function claimProposalTx(id) {
      toast('Not available yet', 'Claiming proposal rewards will be enabled after admin acceptance + payout ledger.');
    }



    function bountyTx(kind, rewardAC) {
      openTxConfirm({
        title:'Submit bounty',
        desc:'Submit this bounty. If accepted, you earn Credits.',
        gasEth:'0.00005',
        preview:`If accepted: +${fmtCredits(rewardAC)}`,
        onConfirm: ()=>{
          simulateTx({
            kind,
            label:'Submit bounty',
            gasEth:'0.00005',
            apply: ()=>{}
          });
        }
      });
    }
    btnBugTx.addEventListener('click', ()=>bountyTx('bug', 300));
    btnReplayTx.addEventListener('click', ()=>bountyTx('replay', 200));

    // ----- TX Feed rendering -----
    const txFeed = document.getElementById('txFeed');
    function renderTxFeed() {
      const arr = getTxLog().slice(0,6);
      if (!arr.length) {
        txFeed.innerHTML = '<div class="muted">No transactions yet. Claim promo, buy Credits, or submit a proposal.</div>';
        return;
      }
      txFeed.innerHTML = '';
      arr.forEach(tx => {
        const el = document.createElement('div');
        el.className = 'txItem';
        const tag = (tx.status === 'confirmed') ? '<span class="txTag ok">confirmed</span>' : '<span class="txTag pend">pending</span>';
        const time = new Date(tx.ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        el.innerHTML = `
          <div>
            <div class="l">${tx.label}</div>
            <div class="s">${tx.kind} · ${tag}</div>
          </div>
          <div class="r">
            <div>${time}</div>
            <div class="mono">${tx.gasEth} ETH</div>
          </div>
        `;
        txFeed.appendChild(el);
      });
    }

    // ----- Sync stats -----
    const statPaid = document.getElementById('statPaid');
    const statPromoLabel = document.getElementById('statPromoLabel');
    const statPromo = document.getElementById('statPromo');
    const statXP = document.getElementById('statXP');
    const statPRO = document.getElementById('statPRO');
    const statBest = document.getElementById('statBest');
    const statTx24 = document.getElementById('statTx24');
    const pillRunMode = document.getElementById('pillRunMode');

    function tx24hCount() {
      const cutoff = now() - 24*3600*1000;
      return getTxLog().filter(tx => tx.ts >= cutoff).length;
    }

    function getRuns(gameId) {
      try {
        const arr = JSON.parse(lsGet(K.runs(gameId)) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }

    function setRuns(gameId, arr) {
      try { lsSet(K.runs(gameId), JSON.stringify((arr||[]).slice(0,200))); } catch {}
    }

    function bestFromRuns(runs) {
      return (runs||[]).reduce((m,r)=>Math.max(m, Number(r.score||0)), 0);
    }

    function bestByGame() {
      const out = {};
      (GAMES||[]).forEach(g => {
        const b = getInt(K.best(g.id), 0);
        out[g.id] = b;
      });
      return out;
    }

    function renderStats() {
      const paid = getInt(K.paid, 0);
      const promo = getInt(K.promoBal(currentGameId), 0);
      const xp = getInt(K.xp, 0);
      const lvl = syncLevel();
      const best = getInt(K.best(currentGameId), 0);

      statPaid.textContent = String(paid);
      statPromo.textContent = String(promo);
      statPromoLabel.textContent = `Promo Credits (${(currentGame && currentGame.name) ? currentGame.name : currentGameId})`;
      statXP.textContent = `${xp} XP · L${lvl}`;
      statPRO.textContent = proLabel();
      statBest.textContent = String(best);
      statTx24.textContent = String(tx24hCount());
    }

    // ----- Universal Game Embed Adapter + RunCoordinator -----
    const activeRun = { runId:'', gameId:'', runType:'', startedAt:0, costAC:0 };
    let gameController = null;
    let runCoordinator = null;

    let lastBridgeMessage = null;
    let lastBridgeError = null;
    let lastMetricsSubmission = null;

    function isDevMode() {
      try {
        return (
          location.hostname === 'localhost' ||
          location.hostname === '127.0.0.1' ||
          location.search.includes('dev=1')
        );
      } catch {
        return false;
      }
    }

    function isSimulateArcade() {
      try { return isDevMode() && getBool('ga.simulateArcade'); } catch { return false; }
    }

    function expectedGameOrigin() {
      try {
        if (!currentGame || !currentGame.embedUrl) return '';
        return new URL(String(currentGame.embedUrl), window.location.origin).origin;
      } catch {
        return '';
      }
    }

    function sendToGame(type, payload) {
      try {
        if (gameController) return gameController.send(String(type || ''), payload || {});
      } catch {}
      try { gameFrame?.contentWindow?.postMessage(Object.assign({ type }, payload||{}), '*'); } catch {}
      return false;
    }

    function syncToGame() {
      try {
        if (gameController) return gameController.sync();
      } catch {}
      return false;
    }

    function addOffchain(label) {
      addTx({
        id: 'off_' + Math.random().toString(16).slice(2),
        kind: 'offchain',
        label,
        gasEth: '0.00000',
        status: 'confirmed',
        ts: now()
      });
    }

    async function requestRunImpl({ gameId, desiredRunType }) {
      const g = gameById(gameId);
      if (!g) return { granted: false, payload: { gameId, reason: 'unknown_game' } };

      if (activeRun.runId) return { granted: false, payload: { gameId, reason: 'run_in_progress' } };

      // Prefer server-authoritative run start (deducts promo/paid Credits in Redis).
      try {
        const r = await serverRunStart(gameId);
        if (r && r.runId) {
          activeRun.runId = r.runId;
          activeRun.gameId = gameId;
          activeRun.runType = r.runType || String(desiredRunType || 'free') || 'free';
          activeRun.startedAt = r.startedAt || new Date().toISOString();
          activeRun.costAC = Number(r.costAC||0);

          if (r.paidAC != null) setInt(K.paid, r.paidAC);
          if (r.promoAC != null) setInt(K.promoBal(gameId), r.promoAC);

          addFeed(`Run started: ${g.name} (${activeRun.runType}) · -${fmtCredits(activeRun.costAC)}`);
          renderTopChips(); syncToGame();

          return {
            granted: true,
            payload: {
              gameId,
              runId: activeRun.runId,
              runType: activeRun.runType,
              cost: { paidAC: 0, promoAC: 0 },
              costAC: activeRun.costAC,
              promoAC: getInt(K.promoBal(gameId),0),
              paidAC: getInt(K.paid,0)
            }
          };
        }
      } catch (e) {
        // fall through to offline/local flow
      }

      // Offline/local fallback (keeps play working if APIs are unavailable).
      const cost = Number(g.runCostAC||0);
      const promoBal0 = getInt(K.promoBal(gameId), 0);
      const paid0 = getInt(K.paid, 0);

      let runType = 'free';
      let usedPromo = 0;
      let usedPaid = 0;

      const policy = String(g.runTypePolicy || (cost > 0 ? 'paid' : 'free'));

      if (policy === 'free') {
        runType = 'free';
      } else if (policy === 'promoOnly') {
        if (cost > 0 && promoBal0 < cost) return { granted: false, payload: { gameId, reason: 'no_funds' } };
        runType = 'promo';
        usedPromo = Math.max(0, cost);
        setInt(K.promoBal(gameId), Math.max(0, promoBal0 - usedPromo));
      } else {
        // default: paid (promo-first, then paid)
        if (cost > 0) {
          if (promoBal0 >= cost) {
            runType = 'promo';
            usedPromo = cost;
            setInt(K.promoBal(gameId), promoBal0 - cost);
          } else {
            if (paid0 < cost) return { granted: false, payload: { gameId, reason: 'no_funds' } };
            runType = 'paid';
            usedPaid = cost;
            setInt(K.paid, paid0 - cost);
            setInt(K.paidSpent, getInt(K.paidSpent,0) + cost);
          }
        }
      }

      const runId = 'run_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(36);
      activeRun.runId = runId;
      activeRun.gameId = gameId;
      activeRun.runType = runType;
      activeRun.startedAt = new Date().toISOString();
      activeRun.costAC = cost;

      addFeed(`Run started (offline): ${g.name} (${runType}) · -${fmtCredits(cost)}`);
      renderTopChips(); syncToGame();

      return {
        granted: true,
        payload: {
          gameId,
          runId,
          runType,
          cost: { paidAC: usedPaid, promoAC: usedPromo },
          costAC: cost,
          promoAC: getInt(K.promoBal(gameId),0),
          paidAC: getInt(K.paid,0)
        }
      };
    }

    async function grantRun(gameId) {
      const r = await requestRunImpl({ gameId, desiredRunType: 'paid' });
      if (!r.granted) {
        if (r?.payload?.reason === 'no_funds') toast('Not enough Credits', 'Buy more Credits or claim promo if available.');
        else if (r?.payload?.reason === 'run_in_progress') toast('Finish the current run first.');
        return;
      }
      sendToGame(standardBridgeMessageTypes.RUN_GRANTED, r.payload);
    }

    async function recordRunResultV2({ gameId, runId, durationMs, metrics, metricId, metricValue }) {
      const g = gameById(gameId);
      if (!g) return;

      const dur = Math.max(0, Math.floor(Number(durationMs||0)));

      let primaryMetricId = String(metricId || g.defaultMetric || 'score');
      let primaryMetricValue = Number(metricValue);

      if (!Number.isFinite(primaryMetricValue)) {
        try {
          if (metrics && typeof metrics === 'object') {
            const v1 = metrics[primaryMetricId];
            const v2 = metrics['score'];
            const pick = (v1 != null) ? v1 : v2;
            primaryMetricValue = Number(pick);
          }
        } catch {}
      }
      if (!Number.isFinite(primaryMetricValue)) primaryMetricValue = 0;

      const s = Math.max(0, Math.floor(primaryMetricValue));

      let xpEarned = 0;
      let bestLocal = Math.max(getInt(K.best(gameId),0), s);

      // Prefer server-authoritative submit (updates XP/level/best + Redis leaderboards).
      let usedServer = false;
      try{
        const r = await serverRunSubmit({ gameId, runId, score: s, durationMs: dur, metricId: primaryMetricId, metricValue: s, metrics: metrics || undefined });
        if (r && r.state){
          applyServerState(r.state);
          xpEarned = Number(r.xpEarned||0);
          bestLocal = Math.max(bestLocal, Number(((r.state.best||{})[gameId])||0));
          usedServer = true;
        }
      } catch(e){
        // Offline/local fallback
        xpEarned = calcXpEarned(s, activeRun.runType || 'free');
        bestLocal = Math.max(bestLocal, s);
        setInt(K.best(gameId), bestLocal);
        setInt(K.xp, getInt(K.xp,0) + xpEarned);
        syncLevel();
      }

      // Local history (UI convenience)
      const runs = getRuns(gameId);
      runs.unshift({
        ts: new Date().toISOString(),
        runId,
        score: s,
        durationMs: dur,
        runType: activeRun.runType || 'free',
        costAC: Number(activeRun.costAC||0),
        xp: xpEarned,
        bestAfter: Math.max(getInt(K.best(gameId),0), bestLocal),
        synced: usedServer,
        metricId: primaryMetricId,
        metrics: metrics || null
      });
      setRuns(gameId, runs.slice(0, 20));

      lastMetricsSubmission = {
        ts: new Date().toISOString(),
        gameId,
        runId,
        metricId: primaryMetricId,
        metricValue: s,
        durationMs: dur,
        usedServer
      };

      addFeed(`Run complete: ${g.name} · ${primaryMetricId} ${s} · +${xpEarned} XP`);
      renderAll();
      syncToGame();

      sendToGame('ARCADE:RUN_RECORDED', {
        gameId,
        runId,
        score: s,
        durationMs: dur,
        xpEarned,
        best: Math.max(getInt(K.best(gameId),0), bestLocal)
      });

      // Clear active run
      activeRun.runId = '';
      activeRun.gameId = '';
      activeRun.runType = '';
      activeRun.costAC = 0;
      activeRun.startedAt = '';

      return { ok: true };
    }

    async function completeRunImpl({ gameId, runId, durationMs, metrics, metricId, metricValue }) {
      return await recordRunResultV2({ gameId, runId, durationMs, metrics, metricId, metricValue });
    }

    async function recordRunResult(gameId, runId, score, durationMs) {
      const g = gameById(gameId);
      const metricId = (g && g.defaultMetric) ? String(g.defaultMetric) : 'score';
      return await recordRunResultV2({ gameId, runId, durationMs, metrics: { [metricId]: Number(score||0) }, metricId, metricValue: Number(score||0) });
    }

    function ensureGameAdapterOnce() {
      if (gameController && runCoordinator) return;
      if (!gameFrame) return;

      runCoordinator = new RunCoordinator({
        isSimulateMode: () => isSimulateArcade(),
        isWalletConnected: () => !!lsGet(K.address),
        isPohRequired: () => getBool('ga.requirePoh'),
        isPohVerified: () => getBool(K.poh),
        requestRunImpl,
        completeRunImpl
      });

      gameController = createGameFrameController({
        iframe: gameFrame,
        game: { id: currentGameId, title: 'game', url: '/games/moonshot/' },
        getSyncPayload: () => {
          const sim = isSimulateArcade();
          const address = sim ? '0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF' : (lsGet(K.address) || '');
          const paid = sim ? 9999 : getInt(K.paid, 0);
          const promo = sim ? 9999 : getInt(K.promoBal(currentGameId), 0);
          return {
            address,
            credits: { paid, promo },
            membership: proLabel() || null,
            avatar: null
          };
        },
        onReady: () => {
          frameReady = true;
          syncToGame();
          try { updateEmbedDebug(); } catch {}
        },
        onRequestRun: async (req) => {
          try {
            const g = gameById(req.gameId);
            const desiredRunType = (g && g.usesCreditsInRun === false) ? 'free' : String(req.desiredRunType || 'paid');
            const res = await runCoordinator.requestRun({ gameId: req.gameId, desiredRunType });
            if (res && res.granted) gameController.send(standardBridgeMessageTypes.RUN_GRANTED, res.payload);
            else gameController.send(standardBridgeMessageTypes.RUN_DENIED, res.payload);
            try { updateEmbedDebug(); } catch {}
          } catch (e) {
            gameController.send(standardBridgeMessageTypes.RUN_DENIED, { gameId: req.gameId, reason: 'error' });
          }
        },
        onRunResult: async (res) => {
          // Back-compat: if the game reports legacy score, treat as metricValue.
          const gid = String(res.gameId || currentGameId || '');
          const rid = String(res.runId || activeRun.runId || ('run_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(36)));

          let metricId = String(res.metricId || (currentGame && currentGame.defaultMetric) || 'score');
          let metricValue = res.metricValue;
          if (metricValue == null && res.legacyScore != null) metricValue = res.legacyScore;

          await runCoordinator.completeRun({
            gameId: gid,
            runId: rid,
            durationMs: Number(res.durationMs || 0),
            metrics: res.metrics || null,
            metricId,
            metricValue
          });
          try { updateEmbedDebug(); } catch {}
        },
        onError: (err) => {
          lastBridgeError = err;
          try { updateEmbedDebug(); } catch {}
        }
      });

      // Configure controller immediately for the currently selected game.
      try {
        const g = currentGame || gameById(currentGameId);
        if (g) {
          gameController.mount({
            id: g.id,
            title: g.name,
            url: g.embedUrl,
            defaultMetric: g.defaultMetric,
            metrics: (Array.isArray(g.metrics) ? g.metrics.map(m => String(m.id)) : []),
            runTypePolicy: g.runTypePolicy,
            sandboxPolicy: g.sandboxPolicy,
            allowList: g.allowList
          });
        }
      } catch {}

      try { updateEmbedDebug(); } catch {}
    }

    let embedDebugEl = null;
    function ensureEmbedDebugPanel() {
      if (!isDevMode()) return;
      if (embedDebugEl) return;
      const portal = document.getElementById('portal');
      if (!portal) return;

      embedDebugEl = document.createElement('div');
      embedDebugEl.id = 'gaEmbedDebug';
      embedDebugEl.style.position = 'absolute';
      embedDebugEl.style.right = '10px';
      embedDebugEl.style.bottom = '10px';
      embedDebugEl.style.maxWidth = '420px';
      embedDebugEl.style.zIndex = '40';
      embedDebugEl.style.background = 'rgba(2,6,23,0.72)';
      embedDebugEl.style.border = '1px solid rgba(255,255,255,0.10)';
      embedDebugEl.style.borderRadius = '16px';
      embedDebugEl.style.backdropFilter = 'blur(10px)';
      embedDebugEl.style.padding = '10px 12px';
      embedDebugEl.style.fontSize = '11px';
      embedDebugEl.style.color = 'rgba(229,231,235,0.86)';

      embedDebugEl.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;margin-bottom:8px;">
          <div style="font-weight:900;letter-spacing:0.12em;text-transform:uppercase;">Embed Debug</div>
          <label style="display:flex;align-items:center;gap:8px;letter-spacing:0.08em;text-transform:uppercase;">
            <input id="gaSimToggle" type="checkbox" style="transform:translateY(1px);" />
            Simulate Arcade
          </label>
        </div>
        <div class="muted" style="margin-bottom:6px;">Shows last bridge message/error and run state.</div>
        <pre id="gaEmbedDebugPre" style="margin:0;white-space:pre-wrap;word-break:break-word;color:rgba(229,231,235,0.80);"></pre>
      `;
      portal.appendChild(embedDebugEl);

      const t = embedDebugEl.querySelector('#gaSimToggle');
      if (t) {
        t.checked = isSimulateArcade();
        t.addEventListener('change', () => {
          setBool('ga.simulateArcade', !!t.checked);
          syncToGame();
          updateEmbedDebug();
        });
      }
    }

    function updateEmbedDebug() {
      ensureEmbedDebugPanel();
      if (!embedDebugEl) return;
      const pre = embedDebugEl.querySelector('#gaEmbedDebugPre');
      if (!pre) return;
      const st = gameController ? gameController.getState() : null;
      const out = {
        view: String(document.body?.dataset?.view || ''),
        simulate: isSimulateArcade(),
        expectedOrigin: expectedGameOrigin(),
        controller: st,
        activeRun,
        lastMessage: lastBridgeMessage,
        lastError: lastBridgeError,
        lastMetricsSubmission
      };
      pre.textContent = JSON.stringify(out, null, 2);
    }

    // ----- Game iframe bridge (postMessage)
    window.addEventListener('message', (ev) => {
      const data = ev && ev.data;
      if (!data || typeof data !== 'object') return;

      const m = data;

      if (m.channel === 'GRUESOME_ARCADE_V1' && typeof m.type === 'string' && m.type.startsWith('GA_STUDIO_')) {
        try { handleStudioMessage(m, ev); } catch {}
        return;
      }
      const type = String(data.type || '');
      const isArcade = type.startsWith('ARCADE:');
      const isLegacyScore = (type === 'SCORE_SUBMIT');
      if (!isArcade && !isLegacyScore) return;

      ensureGameAdapterOnce();

      // Only trust messages from the active game iframe (defense-in-depth).
      try {
        if (gameFrame && gameFrame.contentWindow && ev.source !== gameFrame.contentWindow) return;
      } catch {}

      // Strict origin validation for legacy messages as well.
      const expected = expectedGameOrigin();
      if (expected && !validateMessageOrigin(ev.origin, [expected])) {
        lastBridgeError = { code: 'origin_rejected', details: { got: ev.origin, expected } };
        try { updateEmbedDebug(); } catch {}
        return;
      }

      lastBridgeMessage = { ts: new Date().toISOString(), type, origin: ev.origin };
      try { updateEmbedDebug(); } catch {}

      // Route standard ARCADE:* messages through the centralized adapter.
      // Keep legacy promo request handled by the existing code path.
      if (isArcade && type !== 'ARCADE:REQUEST_PROMO' && gameController) {
        try {
          const handled = gameController.handleMessageEvent(ev);
          if (handled) return;
        } catch (e) {
          lastBridgeError = { code: 'adapter_error', details: String(e && e.message || e) };
          try { updateEmbedDebug(); } catch {}
          return;
        }
      }

      const payload = data.payload || {};

      // Compatibility: Moonshot 3D reports legacy SCORE_SUBMIT. Translate it into a run result.
      if (type === 'SCORE_SUBMIT') {
        const gid = String(payload.gameId || currentGameId || '');
        const score = Number(payload.score || 0);
        let durationMs = 0;
        try {
          const t0 = activeRun.startedAt ? Date.parse(String(activeRun.startedAt)) : NaN;
          if (Number.isFinite(t0)) durationMs = Math.max(0, Date.now() - t0);
        } catch {}

        // If we somehow got a score without a granted run, still record it as a free/offline run.
        const runId = activeRun.runId || ('run_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(36));
        recordRunResult(gid, String(runId), score, durationMs);
        return;
      }

      if (type === 'ARCADE:READY') {
        syncToGame();
        return;
      }
      if (type === 'ARCADE:REQUEST_PROMO') {
        const gid = String(payload.gameId || currentGameId || '');
        if (gid) claimPromoTx(gid);
        return;
      }
      if (type === 'ARCADE:REQUEST_RUN') {
        const gid = String(payload.gameId || currentGameId || '');
        if (gid) grantRun(gid);
        return;
      }
      if (type === 'ARCADE:RUN_RESULT') {
        const gid = String(payload.gameId || currentGameId || '');
        recordRunResult(gid, String(payload.runId||''), Number(payload.score||0), Number(payload.durationMs||0));
        return;
      }
    });



    function clearPulse() {
      document.querySelectorAll('.pulse').forEach(el=>{
        if (el.id === 'avatarCard') return;
        el.classList.remove('pulse');
      });
    }
    function applyPulse(id) {
      clearPulse();
      const el = document.getElementById(id);
      if (el) el.classList.add('pulse');
    }

    function renderTutorial() {
      const s = steps[tutIdx];
      tutTitle.textContent = s.title;
      tutBody.textContent = s.body;
      tutHint.textContent = s.hint;
      tutProg.textContent = (tutIdx+1) + ' / ' + steps.length;
      btnTutBack.disabled = tutIdx === 0;
      btnTutNext.textContent = (tutIdx === steps.length-1) ? 'Finish' : 'Next';
      btnTutAction.textContent = s.actionText || 'Do it now';

      setView(s.view);
      if (s.pulseId) applyPulse(s.pulseId); else clearPulse();
    }

    function startTutorial() {
      showOverlay(tutorial);
      tutIdx = 0;
      renderTutorial();
    }
    function endTutorial() {
      hideOverlay(tutorial);
      clearPulse();
      setBool(K.tutDone, true);
    }
    btnTutorial.addEventListener('click', startTutorial);
    btnTutSkip.addEventListener('click', endTutorial);
    btnTutBack.addEventListener('click', ()=>{ tutIdx = Math.max(0, tutIdx-1); renderTutorial(); });
    btnTutNext.addEventListener('click', ()=>{
      if (tutIdx >= steps.length-1) { endTutorial(); return; }
      tutIdx += 1; renderTutorial();
    });
    btnTutAction.addEventListener('click', ()=>{
      const s = steps[tutIdx];
      try { s.action && s.action(); } catch {}
    });

    // ----- Settings -----
    const btnToggleGrain = document.getElementById('btnToggleGrain');
    const btnResetTutorial = document.getElementById('btnResetTutorial');
    const btnResetAll = document.getElementById('btnResetAll');
    const btnExport = document.getElementById('btnExport');
    const dump = document.getElementById('dump');
    const btnOpenDeck = document.getElementById('btnOpenDeck');

    const embedModal = document.getElementById('embedModal');
    const embedTitle = document.getElementById('embedTitle');
    const embedFrame = document.getElementById('embedFrame');
    const btnEmbedClose = document.getElementById('btnEmbedClose');

    btnToggleGrain.addEventListener('click', ()=>{
      document.body.dataset.grain = (document.body.dataset.grain === '1') ? '0' : '1';
      toast('FX updated', 'Grain toggled.');
    });
    btnResetTutorial.addEventListener('click', ()=>{
      setBool(K.tutDone, false);
      toast('Tutorial reset', 'Open Tutorial to run it again.');
    });
    btnExport.addEventListener('click', ()=>{
      const state = exportState();
      navigator.clipboard?.writeText(JSON.stringify(state, null, 2));
      dump.textContent = JSON.stringify(state, null, 2);
      toast('Exported', 'State copied to clipboard (if allowed).');
    });
    btnResetAll.addEventListener('click', ()=>{
      openTxConfirm({
        title:'Reset everything',
        desc:'Clears local state. (No chain)',
        gasEth:'0.00000',
        preview:'Clears localStorage keys under arcade.*',
        onConfirm: ()=>{
          for (const k of Object.keys(localStorage)) {
            if (k.startsWith('arcade.')) localStorage.removeItem(k);
          }
          location.reload();
        }
      });
    });

    function openEmbed(title, url) {
      if (!embedModal) return;
      embedTitle.textContent = title || 'Embed';
      try { embedFrame.srcdoc = ''; } catch {}
      embedFrame.src = url || 'about:blank';
      showOverlay(embedModal);
    }

    function openEmbedHtml(title, html) {
      if (!embedModal) return;
      embedTitle.textContent = title || 'Embed';
      embedFrame.src = 'about:blank';
      try { embedFrame.srcdoc = String(html || ''); } catch {}
      showOverlay(embedModal);
    }
    function closeEmbed() {
      if (!embedModal) return;
      hideOverlay(embedModal);
      try { embedFrame.srcdoc = ''; } catch {}
      embedFrame.src = 'about:blank';
    }
    btnEmbedClose?.addEventListener('click', closeEmbed);
    // ESC handling is centralized in the overlay manager.

    btnOpenDeck?.addEventListener('click', ()=>{
      const isLocal = /^(localhost|127\.0\.0\.1)$/i.test(location.hostname);
      const deckAbs = location.origin + '/deck/deck.pptx';
      if (isLocal) {
        openEmbedHtml('Pitch deck', `<!doctype html>
<meta charset="utf-8" />
<div style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; padding:16px; line-height:1.45; color:#e9e9e9;">
  <div style="font-size:14px; font-weight:700; margin-bottom:10px;">Pitch deck</div>
  <div style="font-size:13px; opacity:.9;">Local preview of <code>.pptx</code> in an iframe usually downloads instead of rendering.</div>
  <div style="height:12px"></div>
  <a href="/deck/deck.pptx" download style="display:inline-block; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); color:#fff; text-decoration:none;">Download deck.pptx</a>
  <div style="height:10px"></div>
  <div style="font-size:12px; opacity:.75;">On the deployed site, this button opens an embedded Office preview.</div>
</div>`);
        return;
      }
      const viewer = 'https://view.officeapps.live.com/op/embed.aspx?src=' + encodeURIComponent(deckAbs);
      openEmbed('Pitch deck', viewer);
    });

    function exportState() {
      const out = {};
      for (const k of Object.keys(localStorage)) {
        if (k.startsWith('arcade.')) out[k] = localStorage.getItem(k);
      }
      return out;
    }

    // ----- Global render loop -----
    function renderAll() {
      updateAdminNavVisibility();
      renderTopChips();
      renderSplitBars();
      renderStats();
      renderTxFeed();
      renderLocalLB();
      renderPayoutPreview();
      renderProposals();
      renderAvatar();
      renderExpoCountdown();
      dump.textContent = JSON.stringify(exportState(), null, 2);
      setPlayCopy();
      syncToGame();
    }

    // Init
    (async function init() {
      await loadCatalog();
      renderGameTiles();
      populateLbSelect();

      // Restore selected game
      const saved = lsGet(K.selectedGame) || currentGameId;
      selectGame(saved);

      // Default LB selections
      if (!lsGet(K.lbPeriod)) lsSet(K.lbPeriod, 'daily');
      if (!lsGet(K.lbGame)) lsSet(K.lbGame, currentGameId);

      setView('play');
      renderAll();
      // Primary gate is the starfield iframe overlay (runs every refresh).
      // Keep the in-dashboard gate as a fallback only.

      updateUiCaps();
      restartTimers();
    })();


    // timers (adaptive)
    window.addEventListener('visibilitychange', ()=>{
      try { renderNetBanner(); } catch {}
      restartTimers();
    });
    window.addEventListener('resize', ()=>{
      updateUiCaps();
      restartTimers();
    }, { passive:true });
  </script>
</body>
</html>
