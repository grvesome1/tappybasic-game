<!DOCTYPE html>
<html lang="en" data-ui-version="2.8" data-econ-version="1.5">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gruesøme's arcade · Dashboard v2.8</title>
  <!-- built by gruesøme -->
  <!-- SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f -->
  <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@200;400;600;700;800&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: dark;
      --bg0:#020617;
      --bg1: rgba(2,6,23,0.60);
      --panel: rgba(0,0,0,0.42);
      --panel2: rgba(15,23,42,0.62);
      --border: rgba(255,255,255,0.10);
      --border2: rgba(255,255,255,0.07);
      --text: rgba(229,231,235,0.96);
      --muted: rgba(229,231,235,0.72);
      --dim: rgba(229,231,235,0.55);
      --shadow: 0 22px 60px rgba(0,0,0,0.85);
      --r: 16px;
      --r2: 20px;
      --ease: cubic-bezier(0.16,1,0.3,1);

      /* Accent defaults (overridden per view) */
      --accent: #22d3ee;
      --accent2: rgba(34,211,238,0.30);
      --accent3: rgba(34,211,238,0.16);
      --good:#22c55e;
      --warn:#ffdd55;
      --bad:#ff4444;
    }

    /* Per-view accent theming */
    body[data-view="play"] { --accent:#22d3ee; --accent2:rgba(34,211,238,0.30); --accent3:rgba(34,211,238,0.16);}
    body[data-view="wallet"] { --accent:#a855f7; --accent2:rgba(168,85,247,0.30); --accent3:rgba(168,85,247,0.16);}
    body[data-view="leaderboard"] { --accent:#ffdd55; --accent2:rgba(255,221,85,0.30); --accent3:rgba(255,221,85,0.14);}
    body[data-view="proposals"] { --accent:#22c55e; --accent2:rgba(34,197,94,0.30); --accent3:rgba(34,197,94,0.14);}
    body[data-view="settings"] { --accent:#94a3b8; --accent2:rgba(148,163,184,0.30); --accent3:rgba(148,163,184,0.14);}

    *{box-sizing:border-box}
    html, body{height:100%;margin:0;background:radial-gradient(circle at top, var(--bg0) 0%, var(--bg0) 40%, #000 100%);font-family:'Barlow',system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:var(--text);overflow:hidden;}

    /* 3D scene container */
    #scene{position:fixed;inset:0;z-index:0;}
    canvas{display:block;}

    /* Subtle grain (toggleable) */
    .grain{position:fixed;inset:-40px;z-index:2;pointer-events:none;opacity:0.16;mix-blend-mode:overlay;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.38'/%3E%3C/svg%3E");transform:translateZ(0);animation:grainMove 10s steps(2) infinite;}
    @keyframes grainMove{0%{transform:translate(0,0)} 25%{transform:translate(-18px,12px)} 50%{transform:translate(-8px,-14px)} 75%{transform:translate(12px,-8px)} 100%{transform:translate(0,0)}}
    body[data-grain="0"] .grain{display:none;}

    /* App shell */
    #app{position:fixed;inset:0;z-index:10;display:grid;grid-template-columns: 280px minmax(0,1fr);grid-template-rows: 70px minmax(0,1fr);grid-template-areas:"side top" "side main";}
    aside{grid-area:side;padding:18px 16px;background:rgba(2,6,23,0.82);backdrop-filter:blur(10px);border-right:1px solid rgba(255,255,255,0.06);}
    header{grid-area:top;padding:14px 16px;background:radial-gradient(circle at 20% 0%, var(--accent3) 0%, transparent 55%), rgba(2,6,23,0.62);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between;gap:12px;}
    main{grid-area:main;position:relative;padding:16px;overflow:auto;}

    /* Production: global network banner (sticky) */
    .netBanner{position:sticky;top:0;z-index:60;display:none;margin:0 0 12px;padding:10px 12px;border-radius:16px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.76);backdrop-filter:blur(10px);box-shadow:0 18px 55px rgba(0,0,0,0.55);}
    .netBanner.show{display:block;}
    .netBanner .a{font-weight:900;letter-spacing:0.10em;text-transform:uppercase;font-size:11px;}
    .netBanner .b{margin-top:4px;color:rgba(229,231,235,0.72);font-size:12px;line-height:1.35;}
    .netBanner.bad{border-color:rgba(255,68,68,0.35);background:rgba(255,68,68,0.10);}
    .netBanner.warn{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);}
    .netBanner.good{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);}

    .brand{padding:12px;border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(15,23,42,0.55);box-shadow:0 18px 50px rgba(0,0,0,0.55);}
    .brand .t{font-weight:800;letter-spacing:0.12em;text-transform:uppercase;font-size:14px;}
    .brand .s{margin-top:6px;color:var(--muted);font-size:12px;line-height:1.35;}

    .nav{margin-top:14px;display:flex;flex-direction:column;gap:8px;}
    .nav button{width:100%;text-align:left;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(15,23,42,0.55);color:rgba(229,231,235,0.90);font-size:12px;letter-spacing:0.10em;text-transform:uppercase;padding:10px 12px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;gap:10px;transition:transform 180ms var(--ease), border-color 180ms var(--ease), background 180ms var(--ease);}
    .nav button:hover{transform:translateX(2px);border-color:var(--accent2);background:rgba(15,23,42,0.70);}
    .nav button.active{border-color:rgba(255,255,255,0.14);background:linear-gradient(90deg, var(--accent3), rgba(15,23,42,0.62));}
    .nav .hint{margin-top:6px;color:rgba(229,231,235,0.55);font-size:11px;line-height:1.35;}

    /* Topbar chips */
    .topLeft{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
    h1{margin:0;font-size:14px;font-weight:800;letter-spacing:0.12em;text-transform:uppercase;}
    .sub{margin-top:4px;color:var(--muted);font-size:12px;}

    .chip{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:7px 10px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(15,23,42,0.52);color:rgba(229,231,235,0.86);white-space:nowrap;}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(148,163,184,0.85);box-shadow:0 0 0 3px rgba(148,163,184,0.12);}
    .chip.good{border-color:rgba(34,197,94,0.42);background:rgba(22,163,74,0.12);color:rgba(187,247,208,0.95);}
    .chip.good .dot{background:rgba(34,197,94,0.95);box-shadow:0 0 0 3px rgba(34,197,94,0.16),0 0 16px rgba(34,197,94,0.22);}
    .chip.warn{border-color:rgba(255,221,85,0.35);background:rgba(255,221,85,0.10);color:rgba(255,240,196,0.95);}
    .chip.warn .dot{background:rgba(255,221,85,0.95);box-shadow:0 0 0 3px rgba(255,221,85,0.14),0 0 16px rgba(255,221,85,0.20);}
    .chip.bad{border-color:rgba(255,68,68,0.35);background:rgba(255,68,68,0.10);color:rgba(254,202,202,0.95);}
    .chip.bad .dot{background:rgba(255,68,68,0.95);box-shadow:0 0 0 3px rgba(255,68,68,0.12),0 0 16px rgba(255,68,68,0.18);}

    .topRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end;}
    .btn{border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(15,23,42,0.58);color:rgba(229,231,235,0.92);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;padding:10px 12px;cursor:pointer;transition:transform 160ms var(--ease), border-color 160ms var(--ease), background 160ms var(--ease);user-select:none;display:inline-flex;align-items:center;gap:8px;white-space:nowrap;}
    .btn:hover{transform:translateY(-1px);border-color:var(--accent2);background:rgba(15,23,42,0.72);}
    .btn.primary{border-color:rgba(255,255,255,0.14);background:linear-gradient(90deg, var(--accent3), rgba(15,23,42,0.62));}
    .btn.ghost{background:transparent;}

    /* Views */
    .view{display:none;animation:viewIn 260ms var(--ease) both;position:relative;overflow:hidden;}
    .view.active{display:block;}
    .view::before{content:'';position:absolute;inset:0;pointer-events:none;opacity:0.20;mix-blend-mode:screen;filter:saturate(1.15);background:radial-gradient(700px 420px at 30% 0%, rgba(88,101,242,0.22), rgba(0,0,0,0));}
    #view-play::before{background:radial-gradient(700px 420px at 22% 0%, rgba(88,101,242,0.22), rgba(0,0,0,0));}
    #view-wallet::before{background:radial-gradient(700px 420px at 78% 0%, rgba(34,211,238,0.20), rgba(0,0,0,0));}
    #view-leaderboard::before{background:radial-gradient(700px 420px at 50% 0%, rgba(251,191,36,0.18), rgba(0,0,0,0));}
    #view-proposals::before{background:radial-gradient(700px 420px at 30% 0%, rgba(244,114,182,0.18), rgba(0,0,0,0));}
    #view-profile::before{background:radial-gradient(700px 420px at 72% 0%, rgba(167,139,250,0.18), rgba(0,0,0,0));}
    .view > *{position:relative;z-index:1;}
    @keyframes viewIn{from{opacity:0;transform:translateY(6px) scale(0.995);}to{opacity:1;transform:translateY(0) scale(1);}}

    .viewHeader{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:12px;}
    .viewHeader .h{font-size:13px;font-weight:800;letter-spacing:0.14em;text-transform:uppercase;margin:0;}
    .viewHeader .p{margin:6px 0 0;color:var(--muted);font-size:12px;max-width:60ch;}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:6px 10px;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.50);color:rgba(229,231,235,0.84);white-space:nowrap;}
    .pill strong{color:rgba(229,231,235,0.95);}

    .grid{display:grid;grid-template-columns: 1.55fr 1fr;gap:14px;align-items:start;}
    .card{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(2,6,23,0.48);backdrop-filter:blur(10px);box-shadow:var(--shadow);overflow:hidden;position:relative;transition:transform .18s ease, border-color .18s ease, box-shadow .18s ease;}
    .card::before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 20% 0%, var(--accent3), transparent 55%);opacity:0.7;pointer-events:none;}
    .card:hover{transform:translateY(-1px);border-color:rgba(255,255,255,0.14);box-shadow:0 18px 55px rgba(0,0,0,0.55);}
    .card:active{transform:translateY(0px);}

    .inner{padding:14px;position:relative;display:flex;flex-direction:column;gap:12px;}
    .card h3{margin:0;font-size:12px;font-weight:800;letter-spacing:0.12em;text-transform:uppercase;}
    .muted{color:var(--muted);font-size:12px;}

    .kv{display:grid;grid-template-columns:140px 1fr;gap:8px 10px;align-items:center;font-size:12px;}
    .k{color:rgba(229,231,235,0.58);letter-spacing:0.08em;text-transform:uppercase;font-size:10px;}
    .v{font-weight:800;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-variant-numeric:tabular-nums;}
    .v small{font-weight:700;color:var(--muted);}

    .split{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .bar{border:1px solid rgba(255,255,255,0.08);border-radius:14px;background:rgba(15,23,42,0.55);overflow:hidden;}
    .bar > div{height:10px;width:0;background:linear-gradient(90deg, var(--accent2), rgba(255,255,255,0.06));transition:width 380ms var(--ease);}

    /* Play view */
    .portal{height:540px;min-height:420px;border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:rgba(2,6,23,0.55);overflow:hidden;position:relative;}
    .portal iframe{width:100%;height:100%;border:0;display:block;background:#000;}
    .portalTop{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;pointer-events:none;}
    .portalTop .pill{pointer-events:auto;}
    .portalBottom{position:absolute;bottom:10px;left:10px;right:10px;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;pointer-events:none;}
    .portalBottom .btn{pointer-events:auto;}


    .gameTiles{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;}
    .gameTile{border:1px solid rgba(255,255,255,0.10);border-radius:16px;background:rgba(15,23,42,0.55);padding:10px;cursor:pointer;display:flex;flex-direction:column;gap:6px;transition:transform 180ms var(--ease), border-color 180ms var(--ease), background 180ms var(--ease);min-height:78px;position:relative;overflow:hidden;}
    .gameTile::before{content:"";position:absolute;inset:0;background:radial-gradient(circle at 20% 0%, var(--accent3), transparent 65%);opacity:0.65;pointer-events:none;}
    .gameTile:hover{transform:translateY(-2px);border-color:var(--accent2);background:rgba(15,23,42,0.70);}
    .gameTile.active{border-color:rgba(255,255,255,0.16);background:linear-gradient(90deg,var(--accent3),rgba(15,23,42,0.62));}
    .gameTile.disabled{opacity:0.55;cursor:not-allowed;transform:none;}
    .gameTile .n{font-weight:900;letter-spacing:0.10em;text-transform:uppercase;font-size:11px;position:relative;}
    .gameTile .d{color:rgba(229,231,235,0.70);font-size:11px;line-height:1.35;position:relative;}
    .gameTile .meta{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;position:relative;margin-top:auto;}
    .gameTile .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.84);}
    .gameTile .badge.live{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .gameTile .badge.soon{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}
    @media (max-width: 980px){.gameTiles{grid-template-columns:1fr;}}


    .txFeed{display:flex;flex-direction:column;gap:8px;}
    .txItem{border:1px solid rgba(255,255,255,0.08);border-radius:14px;background:rgba(15,23,42,0.55);padding:10px 12px;display:flex;justify-content:space-between;gap:12px;align-items:flex-start;}
    .txItem .l{font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:rgba(229,231,235,0.84);}
    .txItem .s{margin-top:4px;color:rgba(229,231,235,0.62);font-size:11px;}
    .txItem .r{text-align:right;font-size:11px;color:rgba(229,231,235,0.72);white-space:nowrap;}
    .txTag{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);}
    .txTag.ok{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .txTag.pend{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}

    /* Wallet view */
    .buyGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    .buyGrid .panel{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:10px;}
    .row{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:baseline;}
    input[type="number"], input[type="text"], textarea, select{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.55);color:var(--text);outline:none;font-family:inherit;}
    input[type="range"]{width:100%;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;}
    .tab{padding:7px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(2,6,23,0.45);cursor:pointer;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;color:rgba(229,231,235,0.86);user-select:none;}
    .tab.active{border-color:var(--accent2);background:linear-gradient(90deg,var(--accent3),rgba(2,6,23,0.45));}
    .preset{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:8px;}
    .chipBtn{border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:8px 10px;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.90);cursor:pointer;text-align:center;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;user-select:none;}
    .chipBtn:hover{border-color:var(--accent2);}
    .chipBtn:active{transform:translateY(1px);}

    .tier{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:10px;}
    .tier .name{font-weight:800;letter-spacing:0.10em;text-transform:uppercase;font-size:12px;}
    .tier .price{font-size:18px;font-weight:900;letter-spacing:0.02em;font-variant-numeric:tabular-nums;}
    .tier ul{margin:0;padding-left:18px;color:rgba(229,231,235,0.84);font-size:12px;}
    .tier li{margin:6px 0;}
    .avatarWrap{display:grid;grid-template-columns: 180px 1fr;gap:12px;align-items:start;}
    .avatarCard{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(2,6,23,0.55);padding:12px;}
    .avatarSvg{width:100%;height:auto;border-radius:14px;border:1px solid rgba(255,255,255,0.08);background:rgba(0,0,0,0.25);}
    .pulse{position:relative;}
    .pulse::after{content:"";position:absolute;inset:-6px;border-radius:18px;border:1px solid var(--accent2);box-shadow:0 0 0 3px rgba(255,255,255,0.03), 0 0 22px var(--accent3);opacity:0;animation:pulse 1.6s var(--ease) infinite;}
    @keyframes pulse{0%{opacity:0;transform:scale(0.98);} 40%{opacity:1;} 100%{opacity:0;transform:scale(1.03);}}

    /* Leaderboard */
    table{width:100%;border-collapse:collapse;font-size:12px;}
    th, td{text-align:left;padding:10px 8px;border-bottom:1px solid rgba(255,255,255,0.07);}
    th{color:rgba(229,231,235,0.62);letter-spacing:0.10em;text-transform:uppercase;font-size:10px;}
    tbody tr:hover{background:rgba(255,255,255,0.03);}
    .rank{font-weight:900;font-variant-numeric:tabular-nums;}
    .mono{font-variant-numeric:tabular-nums;}

    /* Proposals */
    textarea{min-height:90px;resize:vertical;}
    .proposal{border:1px solid rgba(255,255,255,0.08);border-radius:var(--r);background:rgba(15,23,42,0.55);padding:12px;display:flex;flex-direction:column;gap:8px;}
    .proposal .top{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center;}
    .proposal .title{font-weight:900;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;}
    .proposal .desc{color:rgba(229,231,235,0.78);font-size:12px;line-height:1.4;}
    .tag{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,0.10);border-radius:999px;padding:5px 8px;font-size:10px;letter-spacing:0.08em;text-transform:uppercase;background:rgba(2,6,23,0.45);}
    .tag.good{border-color:rgba(34,197,94,0.35);background:rgba(22,163,74,0.10);color:rgba(187,247,208,0.95);}
    .tag.warn{border-color:rgba(255,221,85,0.28);background:rgba(255,221,85,0.08);color:rgba(255,240,196,0.95);}

    /* Overlays */
    .overlay{position:fixed;inset:0;z-index:200;display:none;align-items:center;justify-content:center;background:
      radial-gradient(circle at 50% 20%, rgba(34,211,238,0.10) 0%, transparent 60%),
      linear-gradient(180deg, rgba(2,6,23,0.35) 0%, rgba(0,0,0,0.72) 100%);
      backdrop-filter: blur(10px);
    }
    .overlay.show{display:flex;}
    .modal{width:min(980px, calc(100% - 24px));border:1px solid rgba(255,255,255,0.10);border-radius:24px;background:rgba(2,6,23,0.72);box-shadow:0 30px 90px rgba(0,0,0,0.90);overflow:hidden;animation:modalIn 240ms var(--ease) both;}
    @keyframes modalIn{from{transform:translateY(10px) scale(0.99);opacity:0;}to{transform:translateY(0) scale(1);opacity:1;}}
    .modalHead{padding:14px 14px;border-bottom:1px solid rgba(255,255,255,0.06);display:flex;justify-content:space-between;gap:10px;align-items:center;background:radial-gradient(circle at 20% 0%, var(--accent3) 0%, transparent 60%), rgba(2,6,23,0.55);}
    .modalHead .t{font-weight:900;letter-spacing:0.12em;text-transform:uppercase;font-size:12px;}
    .modalBody{padding:14px;display:grid;grid-template-columns: 1.1fr 0.9fr;gap:12px;align-items:start;}
    .modalBody .panel{border:1px solid rgba(255,255,255,0.08);border-radius:18px;background:rgba(15,23,42,0.55);padding:12px;}
    .modalFoot{padding:12px 14px;border-top:1px solid rgba(255,255,255,0.06);display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;background:rgba(2,6,23,0.55);}
    .closeX{border:1px solid rgba(255,255,255,0.10);border-radius:999px;background:rgba(2,6,23,0.45);color:rgba(229,231,235,0.92);cursor:pointer;padding:8px 10px;letter-spacing:0.08em;text-transform:uppercase;font-size:11px;}
    .closeX:hover{border-color:var(--accent2);}

    #toastHost{position:fixed;right:calc(14px + env(safe-area-inset-right));bottom:calc(14px + env(safe-area-inset-bottom));z-index:220;display:flex;flex-direction:column;gap:8px;pointer-events:none;}
    .toast{border:1px solid rgba(255,255,255,0.10);border-radius:16px;background:rgba(2,6,23,0.82);padding:10px 12px;min-width:240px;box-shadow:0 18px 50px rgba(0,0,0,0.75);pointer-events:none;animation:toastIn 220ms var(--ease) both;}
    .toast .a{font-weight:900;letter-spacing:0.08em;text-transform:uppercase;font-size:11px;}
    .toast .b{margin-top:4px;color:rgba(229,231,235,0.72);font-size:12px;line-height:1.35;}
    @keyframes toastIn{from{transform:translateY(8px) scale(0.99);opacity:0;}to{transform:translateY(0) scale(1);opacity:1;}}

    @media (max-width: 980px) {
      #app{grid-template-columns:1fr;grid-template-rows:70px auto minmax(0,1fr);grid-template-areas:"top" "side" "main";}
      aside{border-right:none;border-bottom:1px solid rgba(255,255,255,0.06);padding:12px 10px;}
      header{padding:12px 10px;}
      main{padding:12px 10px;}
      .brand .s{display:none;}
      .nav{flex-direction:row;gap:8px;flex-wrap:wrap;}
      .nav button{flex:1;min-width:140px;justify-content:center;text-align:center;min-height:44px;}
      .btn{min-height:44px;}
      .grid{grid-template-columns:1fr;}
      .modalBody{grid-template-columns:1fr;}
      .buyGrid{grid-template-columns:1fr;}
      .preset{grid-template-columns:repeat(2,minmax(0,1fr));}
      .avatarWrap{grid-template-columns:1fr;}
      .portal{height:360px;min-height:320px;}

      /* Mobile: simplify header clutter (desktop remains primary) */
      #chipCredits, #chipEpoch{display:none;}
      .topLeft, .topRight{gap:8px;}
      .chip{padding:6px 9px;font-size:10px;}
      header{align-items:flex-start;}
    }

    /* Small mobile phones: keep it simple and touch-friendly */
    @media (max-width: 560px) {
      html, body{overflow:hidden;}
      main{-webkit-overflow-scrolling:touch;}
      .nav button{min-width:110px;padding:10px 10px;}
      .viewHeader{margin-bottom:10px;}
      .viewHeader .p{max-width:unset;}
      .portal{height:320px;min-height:280px;}
      .portalBottom{flex-direction:column;align-items:stretch;gap:8px;}
      .portalBottom .btn{width:100%;justify-content:center;}
      .portalBottom > div{width:100%;}
      .portalBottom > div .btn{flex:1;}
      .gameTile{min-height:66px;padding:9px;}
      .gameTile .d{display:none;}
      #toastHost{left:calc(12px + env(safe-area-inset-left));right:calc(12px + env(safe-area-inset-right));}
      .toast{min-width:unset;width:100%;}
    }

    @media (prefers-reduced-motion: reduce) {
      *{scroll-behavior:auto !important;}
      .grain{animation:none !important;}
      .view{animation:none !important;}
      .btn,.nav button{transition:none !important;}
    }
  
    .hr{height:1px;background:rgba(255,255,255,0.08);margin:12px 0;border-radius:999px;}
    /* v2.8: claim-ready pulse + lottery subtle emphasis */
    @keyframes pulseGlow {
      0%{ box-shadow: 0 0 0 0 rgba(34,211,238,0.00); }
      40%{ box-shadow: 0 0 0 6px rgba(34,211,238,0.12); }
      100%{ box-shadow: 0 0 0 0 rgba(34,211,238,0.00); }
    }
    .pulse { animation: pulseGlow 1.25s ease-in-out infinite; }
    .txFeed .txItem.winner { border-color: rgba(255,221,85,0.22); background: linear-gradient(90deg, rgba(255,221,85,0.10), rgba(15,23,42,0.58)); }

    /* Access gate overlay (Starfield) */
    #accessGateOverlay{position:fixed;inset:0;z-index:9999;background:#000;opacity:1;visibility:visible;pointer-events:auto;will-change:opacity;transition:opacity 720ms var(--ease), visibility 720ms var(--ease);}
    #accessGateOverlay.is-hidden{opacity:0;visibility:hidden;pointer-events:none;}
    #accessGateFrame{width:100vw;height:100vh;border:0;display:block;background:#000;}

    /* When access is granted, dock the gate into the sidebar header slot */
    #accessDock{display:none;position:relative;width:240px;height:80px;border:1px solid rgba(255,255,255,0.08);border-radius:var(--r2);background:#000;overflow:hidden;box-shadow:0 18px 50px rgba(0,0,0,0.55);}
    #accessDock iframe{position:absolute;inset:0;width:100%;height:100%;border:0;display:block;background:#000;}
     /* Slight zoom to make the Starfield header title more legible.
       Also render the iframe a bit smaller and scale it up to reduce effective pixel workload. */
     #accessDockHeaderFrame{left:4%;top:4%;width:92%;height:92%;transform:scale(1.15);transform-origin:50% 50%;will-change:transform;}
    body.hasDockedGate #accessDock{display:block;}

    .sidebarChips{display:flex;flex-direction:column;gap:8px;margin:10px 0 12px;}
    .sidebarChips .chip{white-space:normal;justify-content:flex-start;}

    /* Helps the dock animation feel smoother on some GPUs */
    #accessDock{contain:layout paint;}
    body.hasDockedGate .brand{display:none;}

</style>

  <link rel="prefetch" href="access/header_240x80.html?v=3.4.1" as="document">
</head>
<body data-view="play" data-grain="1">
  <div id="accessGateOverlay" aria-label="Access gate" role="dialog">
    <iframe id="accessGateFrame" title="Access" src="access/" allow="clipboard-read; clipboard-write"></iframe>
  </div>

  <div id="scene" aria-hidden="true"></div>
  <div class="grain" aria-hidden="true"></div>

  <div id="app" role="application" aria-label="Arcade Dashboard">
    <aside>
      <div id="accessDock" aria-label="Access header"></div>
      <div class="sidebarChips" aria-label="Status">
        <span class="chip warn" id="chipWallet"><span class="dot"></span><span id="chipWalletT">Wallet: not connected</span></span>
        <span class="chip warn" id="chipPOH"><span class="dot"></span><span id="chipPOHT">POH: not verified</span></span>
      </div>
      <div class="brand">
        <div class="t">gruesøme's arcade</div>
        <div class="s">Single-page dashboard · access-gated · v2.8<br/>AC is the universal credit (1 AC = $0.01).</div>
      </div>

      <div class="nav" aria-label="Navigation">
        <button class="active" data-nav="play"><span>Play</span><span>⟡</span></button>
        <button data-nav="wallet"><span>Wallet</span><span>◈</span></button>
        <button data-nav="leaderboard"><span>Leaderboard</span><span>⌁</span></button>
        <button data-nav="proposals"><span>Suggestions</span><span>✦</span></button>
        <button data-nav="settings"><span>Settings</span><span>⚙</span></button>
        <div class="hint">
          Locked v1.5 numbers: 55/35/10 splits · PRO $2/$25/$100. Game config now loads from arcade-games.json.
        </div>
      </div>
    </aside>

    <header>
      <div class="topLeft">
        <div>
          <h1 id="topTitle">Play</h1>
          <div class="sub" id="topSub">Load economy tied games from the game library.</div>
        </div>
      </div>
      <div class="topRight">
        <span class="chip" id="chipCredits"><span class="dot"></span><span id="chipCreditsT">AC: 0 paid · 0 promo</span></span>
        <span class="chip" id="chipEpoch"><span class="dot"></span><span id="chipEpochT">Next payout: --:--:--</span></span>
        <button class="btn ghost" id="btnTutorial">Tutorial</button>
      </div>
    </header>

    <main>
      <div id="netBanner" class="netBanner" role="status" aria-live="polite"></div>

      <!-- PLAY -->
      <section class="view active" id="view-play" aria-label="Play view">
        <div class="viewHeader">
          <div>
            <p class="h" id="playTitle">Loading…</p>
            <p class="p" id="playDesc">Loading game details…</p>
          </div>
          <span class="pill"><strong>Auto payouts</strong> · 55% skill · 35% activity · 10% PRO</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Game Portal</h3>
              <div class="portal" id="portal">
                <iframe id="gameFrame" title="Game Portal" src="/games/moonshot/"></iframe>

                <div class="portalTop">
                  <span class="pill" id="pillRunCost">Loading · -- AC/run</span>
                  <span class="pill" id="pillRunMode">Run type: --</span>
                </div>

                <div class="portalBottom">
                  <button class="btn primary" id="btnClaimPromo">Claim promo (Tx)</button>
                  <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
                    <button class="btn" id="btnFullscreen">Fullscreen</button>
                    <button class="btn" id="btnOpenWallet">Buy AC</button>
                  </div>
                </div>
              </div>

              <div class="split">
                <div class="bar" title="Skill pool 55%"><div id="barSkill"></div></div>
                <div class="bar" title="Activity pool 35%"><div id="barActivity"></div></div>
              </div>
              <div class="bar" title="PRO boost pool 10%"><div id="barPro"></div></div>

              <div class="muted">
                Tip: transactions exist for a reason — promo claims, payout claims, avatar updates, proposals. No spam clicks.
              </div>
            </div>
          </div>

          <div class="card">
            <div class="inner">
              <h3>Game Library</h3>
              <div class="muted">Games are modular files loaded by the dashboard. Add/remove via <span class="mono">arcade-games.json</span>.</div>
              <div class="gameTiles" id="gameTiles" aria-label="Game library tiles"></div>

              <h3>Economy Snapshot</h3>
              <div class="kv">
                <div class="k">Paid AC</div><div class="v" id="statPaid">0</div>
                <div class="k" id="statPromoLabel">Promo AC</div><div class="v" id="statPromo">0</div>
                <div class="k">XP / Level</div><div class="v" id="statXP">0 <small>XP</small> · L1</div>
                <div class="k">PRO</div><div class="v" id="statPRO">NONE</div>
                <div class="k">Best Score</div><div class="v" id="statBest">0</div>
                <div class="k">Tx (24h)</div><div class="v" id="statTx24">0</div>
              </div>

              <div class="muted">
                Payouts are in mUSD (claim-based). This build is UI-first; transactions are simulated.
              </div>

              <div class="btn" id="btnOpenSuggestions">Suggest a game / feature (Tx)</div>

              <h3 style="margin-top:6px">Recent Transactions</h3>
              <div class="txFeed" id="txFeed"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- WALLET -->
      <section class="view" id="view-wallet" aria-label="Wallet view">
        <div class="viewHeader">
          <div>
            <p class="h">Wallet</p>
            <p class="p">Buy any amount of AC (including $0.10). Bigger buys get a smooth bonus. PRO unlocks the 8-bit avatar.</p>
          </div>
          <span class="pill"><strong>AC pricing</strong> · 1 AC = $0.01 · bonus up to 15%</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Buy Arcade Credits (AC)</h3>

              <div class="tabs" role="tablist" aria-label="Buy mode">
                <div class="tab active" id="tabUsd" role="tab">Pay USD</div>
                <div class="tab" id="tabAc" role="tab">Target AC</div>
              </div>

              <div class="buyGrid">
                <div class="panel" id="panelUsd">
                  <div class="row">
                    <div>
                      <div class="muted">Pay (USD preview)</div>
                      <div class="mono" style="font-weight:900;font-size:18px" id="usdBig">$5.00</div>
                    </div>
                    <div style="min-width:180px">
                      <label class="muted">Custom USD</label>
                      <input type="number" id="usdIn" min="0.10" step="0.01" value="5.00" />
                    </div>
                  </div>
                  <input type="range" id="usdRange" min="0.10" max="100" step="0.10" value="5.00" />
                  <div class="preset" aria-label="Presets">
                    <div class="chipBtn" data-usd="0.10">$0.10</div>
                    <div class="chipBtn" data-usd="1">$1</div>
                    <div class="chipBtn" data-usd="5">$5</div>
                    <div class="chipBtn" data-usd="10">$10</div>
                    <div class="chipBtn" data-usd="25">$25</div>
                  </div>
                  <div class="preset">
                    <div class="chipBtn" data-usd="50">$50</div>
                    <div class="chipBtn" data-usd="100">$100</div>
                    <div class="chipBtn" data-usd="7.77">$7.77</div>
                    <div class="chipBtn" data-usd="12.34">$12.34</div>
                    <div class="chipBtn" data-usd="0.50">$0.50</div>
                  </div>
                </div>

                <div class="panel" id="panelAc" style="display:none">
                  <div class="row">
                    <div>
                      <div class="muted">Target</div>
                      <div class="mono" style="font-weight:900;font-size:18px" id="acBig">500 AC</div>
                    </div>
                    <div style="min-width:180px">
                      <label class="muted">Custom AC</label>
                      <input type="number" id="acIn" min="10" step="1" value="500" />
                    </div>
                  </div>
                  <div class="muted">We compute the USD amount that reaches your target after the smooth bonus.</div>
                  <div class="preset">
                    <div class="chipBtn" data-ac="10">10 AC</div>
                    <div class="chipBtn" data-ac="50">50 AC</div>
                    <div class="chipBtn" data-ac="100">100 AC</div>
                    <div class="chipBtn" data-ac="500">500 AC</div>
                    <div class="chipBtn" data-ac="1050">1050 AC</div>
                  </div>
                  <div class="preset">
                    <div class="chipBtn" data-ac="2700">2700 AC</div>
                    <div class="chipBtn" data-ac="5600">5600 AC</div>
                    <div class="chipBtn" data-ac="11500">11500 AC</div>
                    <div class="chipBtn" data-ac="777">777 AC</div>
                    <div class="chipBtn" data-ac="1234">1234 AC</div>
                  </div>
                </div>
              </div>

              <div class="kv">
                <div class="k">Base AC</div><div class="v" id="outBase">500</div>
                <div class="k">Bonus</div><div class="v" id="outBonus">+0.0%</div>
                <div class="k">Total AC</div><div class="v" id="outTotal">500</div>
                <div class="k">Effective $/AC</div><div class="v" id="outEff">$0.0100</div>
              </div>


              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn primary" id="btnBuyAc">Buy AC with ETH (Tx)</button>
                <button class="btn" id="btnCustomExact">Custom exact amount (Tx)</button>
              </div>

              <div class="muted">
                Buy tx is user-gas-paid. Bonus is applied as extra AC (smooth scale, no cliffs).
              </div>
            </div>
          </div>

          <div class="card">
            <div class="inner">
              <h3>PRO Membership</h3>
              <div class="split">
                <div class="tier">
                  <div class="name">PRO Mini</div>
                  <div class="price">$2<span style="font-size:12px;font-weight:800;letter-spacing:0.08em;text-transform:uppercase">/mo</span></div>
                  <ul>
                    <li>Unlock 8-bit avatar</li>
                    <li>Eligible for PRO boost pool</li>
                    <li>Profile badge</li>
                  </ul>
                  <button class="btn primary" id="btnProMini">Activate (Tx)</button>
                </div>
                <div class="tier">
                  <div class="name">PRO Prime</div>
                  <div class="price">$25<span style="font-size:12px;font-weight:800;letter-spacing:0.08em;text-transform:uppercase">/mo</span></div>
                  <ul>
                    <li>Premium perks + tournaments</li>
                    <li>Higher weight in PRO pool</li>
                    <li>Priority drops</li>
                  </ul>
                  <button class="btn primary" id="btnProPrime">Activate (Tx)</button>
                </div>
              </div>

              <div class="tier" style="margin-top:12px">
                <div class="row">
                  <div>
                    <div class="name">PRO Lifetime</div>
                    <div class="muted">Limited-time price until Exponent ends</div>
                  </div>
                  <div class="price">$100</div>
                </div>
                <ul>
                  <li>Lifetime PRO (no renewals)</li>
                  <li>Includes Mini + Prime perks baseline</li>
                  <li>Countdown shown below (UTC)</li>
                </ul>
                <div class="kv">
                  <div class="k">Window ends</div><div class="v" id="expoEnds">Jan 30 2026 00:00 UTC</div>
                  <div class="k">Time left</div><div class="v" id="expoLeft">--d --:--:--</div>
                </div>
                <button class="btn primary" id="btnProLife">Activate (Tx)</button>
              </div>
            </div>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="card">
          <div class="inner">
            <h3>8-bit Avatar (SBT-ready)</h3>
            <div class="avatarWrap">
              <div class="avatarCard" id="avatarCard">
                <div class="muted">Preview</div>
                <div id="avatarSvgHost"></div>
                <div class="muted" style="margin-top:10px">Edits available: <strong id="avatarEdits">0</strong> (1 per level)</div>
              </div>

              <div class="tier">
                <div class="muted">This editor is locked behind PRO. Saving is a transaction (user pays gas) in the final build.</div>
                <div class="kv">
                  <div class="k">PRO required</div><div class="v" id="avatarProReq">NOT ACTIVE</div>
                  <div class="k">Last edit level</div><div class="v" id="avatarLast">0</div>
                  <div class="k">Current level</div><div class="v" id="avatarLvl">1</div>
                </div>

                <div class="split">
                  <div>
                    <label class="muted">Background</label>
                    <select id="avBg">
                      <option value="nebula">Nebula</option>
                      <option value="void">Void</option>
                      <option value="aurora">Aurora</option>
                      <option value="mars">Mars</option>
                    </select>
                  </div>
                  <div>
                    <label class="muted">Accessory</label>
                    <select id="avAcc">
                      <option value="none">None</option>
                      <option value="antenna">Antenna</option>
                      <option value="visor">Visor</option>
                      <option value="cap">Cap</option>
                    </select>
                  </div>
                </div>
                <div class="split">
                  <div>
                    <label class="muted">Eyes</label>
                    <select id="avEyes">
                      <option value="dots">Dots</option>
                      <option value="angry">Angry</option>
                      <option value="glow">Glow</option>
                    </select>
                  </div>
                  <div>
                    <label class="muted">Mouth</label>
                    <select id="avMouth">
                      <option value="smile">Smile</option>
                      <option value="flat">Flat</option>
                      <option value="grin">Grin</option>
                    </select>
                  </div>
                </div>
                <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn" id="btnAvRandom">Randomize</button>
                  <button class="btn primary" id="btnAvSave">Update Avatar (Tx)</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

            <!-- LEADERBOARD -->
      <section class="view" id="view-leaderboard" aria-label="Leaderboard view">
        <div class="viewHeader">
          <div>
            <p class="h">Leaderboard</p>
            <p class="p">Multi-metric boards (daily/weekly/all). Paid-only drives payouts. Hover a row to preview PRO avatar + nickname (if active).</p>
          </div>
        </div>

        <div class="gaLbHost" data-ga-lb-host>
          <div class="mini muted">Loading leaderboards…</div>
        </div>
      </section>

      <!-- PROPOSALS -->
      <section class="view" id="view-proposals" aria-label="Proposals view">
        <div class="viewHeader">
          <div>
            <p class="h">Suggestions + Bounties</p>
            <p class="p">Submit proposals with a gas-paid transaction. If accepted, you earn AC. Supporters can also earn a small thank-you reward.</p>
          </div>
          <span class="pill"><strong>Anti-spam</strong> · submit requires gas · only accepted work pays</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Submit a Proposal (Tx)</h3>
              <div class="split">
                <div>
                  <label class="muted">Category</label>
                  <select id="propCat">
                    <option value="game">New game</option>
                    <option value="remaster">Remaster</option>
                    <option value="feature">Feature</option>
                  </select>
                </div>
                <div>
                  <label class="muted">Title</label>
                  <input type="text" id="propTitle" placeholder="e.g. Remaster Storm the Blockchain 2 (3D)" />
                </div>
              </div>
              <div>
                <label class="muted">Description</label>
                <textarea id="propDesc" placeholder="What should it be, and why would players love it?"></textarea>
              </div>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn primary" id="btnSubmitProp">Submit (Tx)</button>
              </div>
              <div class="muted">Rewards (preview): accepted proposal = 500 AC; supporters (on-chain) = 50 AC (cap 100 supporters).</div>
            </div>
          </div>

          <div class="card">
            <div class="inner">
              <h3>Proposals</h3>
              <div id="propList" style="display:flex;flex-direction:column;gap:10px"></div>

              <h3 style="margin-top:6px">Bounties</h3>
              <div class="proposal">
                <div class="top">
                  <div class="title">Bug report</div>
                  <span class="tag warn">Tx submission</span>
                </div>
                <div class="desc">Submit a reproducible bug. If accepted: <strong>300 AC</strong>.</div>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn primary" id="btnBugTx">Submit bug (Tx)</button>
                </div>
              </div>
              <div class="proposal">
                <div class="top">
                  <div class="title">Replay review</div>
                  <span class="tag warn">Tx submission</span>
                </div>
                <div class="desc">Submit a suspicious run replay for review. If confirmed: <strong>200 AC</strong>.</div>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn primary" id="btnReplayTx">Submit replay (Tx)</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- SETTINGS -->
      <section class="view" id="view-settings" aria-label="Settings view">
        <div class="viewHeader">
          <div>
            <p class="h">Settings</p>
            <p class="p">FX toggles and dev utilities. Dashboard is always access-gated on refresh.</p>
          </div>
          <span class="pill"><strong>UI</strong> · v2.8</span>
        </div>

        <div class="grid">
          <div class="card">
            <div class="inner">
              <h3>Visual</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnToggleGrain">Toggle grain</button>
                <button class="btn" id="btnResetTutorial">Reset tutorial</button>
              </div>
              <div class="muted">Grain is subtle. Turn off if you want a cleaner UI.</div>
            </div>
          </div>
          <div class="card">
            <div class="inner">
              <h3>Data</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnExport">Export local state</button>
                <button class="btn" id="btnResetAll">Reset everything</button>
              </div>
              <pre id="dump" style="margin:0;white-space:pre-wrap;background:rgba(0,0,0,0.30);border:1px solid rgba(255,255,255,0.06);border-radius:16px;padding:12px;color:rgba(229,231,235,0.86);max-height:320px;overflow:auto;">(state preview)</pre>
            </div>
          </div>
          <div class="card">
            <div class="inner">
              <h3>Pitch Deck</h3>
              <div class="btnRow" style="display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn" id="btnOpenDeck">Open deck</button>
              </div>
              <div class="muted">Embeds <span class="mono">/deck/deck.pptx</span> without opening new tabs.</div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <!-- TUTORIAL -->
  <div class="overlay" id="tutorial" aria-label="Tutorial" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:820px">
      <div class="modalHead">
        <div class="t">Quick Tutorial (30s)</div>
        <button class="closeX" id="btnTutSkip">Skip</button>
      </div>
      <div class="modalBody">
        <div class="panel">
          <h3 style="margin:0 0 8px" id="tutTitle">Step</h3>
          <div class="muted" id="tutBody">...</div>
          <div style="height:12px"></div>
          <div class="kv">
            <div class="k">Economy</div><div class="v">1 AC = $0.01 · Moonshot = 10 AC/run</div>
            <div class="k">Tx model</div><div class="v">Meaningful actions only</div>
          </div>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 8px">What to do</h3>
          <div class="muted" id="tutHint">...</div>
          <div style="height:12px"></div>
          <button class="btn primary" id="btnTutAction" style="width:100%;justify-content:center">Do it now</button>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted" id="tutProg">1 / 5</span>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn" id="btnTutBack">Back</button>
          <button class="btn primary" id="btnTutNext">Next</button>
        </div>
      </div>
    </div>
  </div>

  <!-- EMBED MODAL (deck, etc) -->
  <div class="overlay" id="embedModal" aria-label="Embedded content" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:980px">
      <div class="modalHead">
        <div class="t" id="embedTitle">Embed</div>
        <button class="closeX" id="btnEmbedClose">Close</button>
      </div>
      <div class="modalBody">
        <div class="panel" style="padding:0">
          <iframe id="embedFrame" title="Embedded" style="width:100%;height:72vh;border:0;border-radius:16px;background:rgba(0,0,0,0.30)"></iframe>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted">Embed is in-page (no new tabs).</span>
        <span class="muted">Press ESC to close.</span>
      </div>
    </div>
  </div>

  <!-- TX CONFIRM MODAL -->
  <div class="overlay" id="txModal" aria-label="Transaction confirmation" role="dialog" aria-modal="true">
    <div class="modal" style="max-width:720px">
      <div class="modalHead">
        <div class="t">Confirm Transaction</div>
        <button class="closeX" id="btnTxCancel">Cancel</button>
      </div>
      <div class="modalBody">
        <div class="panel">
          <h3 style="margin:0 0 8px" id="txTitle">Tx</h3>
          <div class="muted" id="txDesc">...</div>
          <div style="height:12px"></div>
          <div class="kv">
            <div class="k">Platform fee</div><div class="v">0</div>
            <div class="k">Gas</div><div class="v" id="txGas">~0.0000 ETH (estimate)</div>
          </div>
        </div>
        <div class="panel">
          <h3 style="margin:0 0 8px">Result</h3>
          <div class="muted">In this UI-first build, transactions are simulated. Later the wallet will show the real gas + exact calldata.</div>
          <div style="height:12px"></div>
          <div class="muted" id="txPreview">(no changes yet)</div>
        </div>
      </div>
      <div class="modalFoot">
        <span class="muted">User pays gas</span>
        <button class="btn primary" id="btnTxConfirm">Confirm (pay gas)</button>
      </div>
    </div>
  </div>

  <div id="toastHost" aria-live="polite" aria-atomic="true"></div>

  <script type="module">
    // built by gruesøme
    // SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f

    // ---------- 3D BACKDROP (subtle, UI-first) ----------
    // Defensive: if this page is ever loaded inside an iframe (e.g. a missing
    // /games/* route rewriting back to /index.html), do NOT create WebGL contexts.
    // That scenario can quickly exhaust the browser's WebGL context limit.
    let __setAccent = () => {};
    try {
      if (window.self === window.top) {
        const THREE = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
        const sceneHost = document.getElementById('scene');
        if (sceneHost) {
          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
          renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
          renderer.setSize(window.innerWidth, window.innerHeight);
          sceneHost.appendChild(renderer.domElement);

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
          camera.position.set(0, 0, 7.5);

          const starGeo = new THREE.BufferGeometry();
          const starCount = 1500;
          const positions = new Float32Array(starCount * 3);
          for (let i = 0; i < starCount; i++) {
            const r = 26 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = -r * Math.cos(phi);
          }
          starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          const starMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.03,
            transparent: true,
            opacity: 0.65,
            depthWrite: false
          });
          const stars = new THREE.Points(starGeo, starMat);
          scene.add(stars);

          const ringGroup = new THREE.Group();
          scene.add(ringGroup);

          function mkRing(radius, tube, opacity) {
            const geo = new THREE.TorusGeometry(radius, tube, 18, 120);
            const mat = new THREE.MeshBasicMaterial({
              color: 0x22d3ee,
              transparent: true,
              opacity,
              blending: THREE.AdditiveBlending
            });
            const mesh = new THREE.Mesh(geo, mat);
            return { mesh, geo, mat };
          }
          const ringA = mkRing(2.0, 0.020, 0.22);
          const ringB = mkRing(3.0, 0.015, 0.14);
          const ringC = mkRing(4.0, 0.010, 0.10);
          ringGroup.add(ringA.mesh, ringB.mesh, ringC.mesh);
          ringGroup.rotation.x = 0.55;

          const accentColor = new THREE.Color(0x22d3ee);
          __setAccent = function setAccent(hex) {
            accentColor.set(hex);
            [ringA, ringB, ringC].forEach((r, idx) => {
              r.mat.color = accentColor;
              r.mat.opacity = [0.22, 0.14, 0.10][idx];
            });
          };

          function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          }
          window.addEventListener('resize', onResize);

          let t0 = performance.now();
          let raf = 0;
          function animate() {
            const t = (performance.now() - t0) * 0.001;
            stars.rotation.y = t * 0.02;
            ringGroup.rotation.y = t * 0.08;
            ringGroup.rotation.z = t * 0.03;
            camera.position.x = Math.sin(t * 0.25) * 0.18;
            camera.position.y = Math.cos(t * 0.20) * 0.10;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
            raf = requestAnimationFrame(animate);
          }
          animate();

          window.addEventListener('beforeunload', () => {
            try { if (raf) cancelAnimationFrame(raf); } catch {}
            try { window.removeEventListener('resize', onResize); } catch {}
            try { starGeo.dispose(); } catch {}
            try { starMat.dispose(); } catch {}
            try { ringA.geo.dispose(); ringB.geo.dispose(); ringC.geo.dispose(); } catch {}
            try { ringA.mat.dispose(); ringB.mat.dispose(); ringC.mat.dispose(); } catch {}
            try { renderer.dispose(); } catch {}
          }, { once: true });
        }
      }
    } catch {}

    // Expose to non-module app logic
    window.__arcadeScene = { setAccent: (hex) => __setAccent(hex) };

    // ---------- APP LOGIC ----------
    const ECON = {
      AC_USD: 0.01,
      SPLIT: { skill: 55, activity: 35, pro: 10 },
      EXPO_END_UTC: Date.UTC(2026, 0, 30, 0, 0, 0)
    };

    const MANIFEST_URL = 'arcade-games.json';
    const FALLBACK_CATALOG = {
  "version": "2.6",
  "updatedAtUtc": "2025-12-29T06:49:51Z",
  "bridge": {
    "name": "ArcadeBridge",
    "version": "0.3"
  },
  "defaults": {
    "acUsd": 0.01,
    "maxBonusPct": 0.15,
    "bonusCurveK": 40
  },
  "games": [
    {
      "id": "moonshot",
      "name": "Moonshot",
      "tagline": "Precision flight \u2022 dodge debris \u2022 climb the stars",
      "embedUrl": "/games/moonshot/",
      "status": "live",
      "runCostAC": 10,
      "promoRuns": 5,
      "promoGrantAC": 50,
      "payoutEligible": true,
      "scoreMax": 5000,
      "minDurationMs": 800
    },
    {
      "id": "storm-the-blockchain",
      "name": "Storm the Blockchain (3D Remaster)",
      "tagline": "Classic defense \u2022 rebuilt for the onchain arcade",
      "embedUrl": "/games/stormblockchain/",
      "status": "coming_soon",
      "runCostAC": 0,
      "promoRuns": 0,
      "promoGrantAC": 0,
      "payoutEligible": false,
      "scoreMax": 100000,
      "minDurationMs": 0
    }
  ],
  "meta": {
    "schema": "gruesome-arcade.catalog.v1",
    "signaturePlain": "built by grues\u00f8me",
    "signatureEnc": "SIG_ENC_XOR5A_HEX=382f33362e7a38237a3d282f3f29a2373f"
  }
};

    let CATALOG = null;
    let GAMES = [];
    let currentGameId = 'moonshot';
    let currentGame = null;
    let frameReady = false;

    // ----- Access gate (Starfield) -----
    const accessOverlay = document.getElementById('accessGateOverlay');
    const accessFrame = document.getElementById('accessGateFrame');
    let accessGranted = false;

    // Some gate builds (including star 3.4.1) do not postMessage the parent.
    // Because the gate is same-origin (/access/), we can observe its DOM state instead.
    let T_GATE_WATCH = null;

    const accessDock = document.getElementById('accessDock');
    let dockAnimating = false;

    const HEADER_EMBED_URL = 'access/header_240x80.html?v=3.4.1';

    // Preload a dedicated header iframe in the dock so we can switch instantly
    // without navigating the animated iframe at the end (prevents the "jump").
    let dockHeaderFrame = null;
    let dockHeaderReady = false;

    function ensureDockHeaderFrame(){
      if (!accessDock) return null;
      if (dockHeaderFrame) return dockHeaderFrame;
      try {
        dockHeaderFrame = document.createElement('iframe');
        dockHeaderFrame.id = 'accessDockHeaderFrame';
        dockHeaderFrame.src = HEADER_EMBED_URL;
        dockHeaderFrame.setAttribute('title', 'Access header');
        dockHeaderFrame.setAttribute('aria-hidden', 'true');
        dockHeaderFrame.style.opacity = '0';
        dockHeaderFrame.style.pointerEvents = 'none';
        dockHeaderFrame.style.transition = 'opacity 160ms var(--ease)';
        dockHeaderFrame.addEventListener('load', () => { dockHeaderReady = true; }, { once: true });
        accessDock.appendChild(dockHeaderFrame);
      } catch {
        dockHeaderFrame = null;
      }
      return dockHeaderFrame;
    }

    function showDockHeaderFrame(){
      const f = ensureDockHeaderFrame();
      if (!f) return;
      // If it's already loaded, it will paint instantly; if not, it will paint when ready.
      try { f.style.opacity = '1'; } catch {}
    }

    function hideDockHeaderFrame(){
      if (!dockHeaderFrame) return;
      try { dockHeaderFrame.style.opacity = '0'; } catch {}
    }

    function ensureDockHeaderEmbedLoaded(){
      try {
        // Keep the dock header iframe pointed at the correct header build.
        const f = ensureDockHeaderFrame();
        if (!f) return;
        const current = String(f.getAttribute('src') || f.src || '');
        if (current.includes('access/header_240x80.html')) return;
      } catch {}
      try { if (dockHeaderFrame) dockHeaderFrame.src = HEADER_EMBED_URL; } catch {}
    }

    function showAccessGate(){ accessOverlay?.classList?.remove('is-hidden'); }
    function hideAccessGate(){ accessOverlay?.classList?.add('is-hidden'); }

    function stopAccessGateAudio(){
      // Best-effort: gate is same-origin (/access/), so we can pause any HTMLMediaElements.
      try {
        const doc = accessFrame?.contentDocument;
        const nodes = doc ? Array.from(doc.querySelectorAll('audio,video')) : [];
        nodes.forEach(el => {
          try { el.pause(); } catch {}
          try { el.muted = true; } catch {}
          try { el.volume = 0; } catch {}
          try { el.currentTime = 0; } catch {}
        });
      } catch {}
    }

    function teardownAccessGateFrame(){
      // Strong guarantee: unloading the iframe stops any remaining audio/work.
      try { stopAccessGateAudio(); } catch {}
      try { if (accessFrame) accessFrame.src = 'about:blank'; } catch {}
      try { if (accessFrame) { accessFrame.style.opacity = '0'; accessFrame.style.pointerEvents = 'none'; } } catch {}
    }

    // Smooth path: let the gate animate itself fullscreen, then swap to the docked header.
    function finalizeGateToDock(){
      try { document.body.classList.add('hasDockedGate'); } catch {}
      try { ensureDockHeaderEmbedLoaded(); } catch {}
      try { showDockHeaderFrame(); } catch {}
      // Once the user is in the dashboard, stop all access-gate audio.
      try { teardownAccessGateFrame(); } catch {}
      try { hideAccessGate(); } catch {}

      // Defensive: stop watching the iframe once access is granted.
      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = null;
    }
    function dockAccessGate(){
      if (!accessFrame || !accessDock) {
        try { document.body.classList.add('hasDockedGate'); } catch {}
        try { accessDock?.appendChild?.(accessFrame); } catch {}
        try { hideAccessGate(); } catch {}
        // IMPORTANT: use the dedicated header-only embed. Do not try to shrink the fullscreen gate.
        try { ensureDockHeaderEmbedLoaded(); showDockHeaderFrame(); } catch {}
        return;
      }

      if (dockAnimating) return;
      dockAnimating = true;

      // Measure the current (fullscreen) iframe position.
      const from = accessFrame.getBoundingClientRect();

      // Make dock visible so we can measure its target rect.
      try { document.body.classList.add('hasDockedGate'); } catch {}

      // Ensure header iframe is warming in the background.
      try { ensureDockHeaderEmbedLoaded(); } catch {}

      // Use a FLIP animation (transform translate/scale) for smoother motion.
      // IMPORTANT: avoid end-of-animation "jumps" by ensuring finish() only runs once.
      requestAnimationFrame(() => {
        const to = accessDock.getBoundingClientRect();
        const scaleX = to.width ? (from.width / to.width) : 1;
        const scaleY = to.height ? (from.height / to.height) : 1;
        const dx = from.left - to.left;
        const dy = from.top - to.top;

        const floater = document.createElement('div');
        floater.setAttribute('aria-hidden', 'true');
        floater.style.position = 'fixed';
        floater.style.left = to.left + 'px';
        floater.style.top = to.top + 'px';
        floater.style.width = to.width + 'px';
        floater.style.height = to.height + 'px';
        floater.style.zIndex = '10000';
        floater.style.overflow = 'hidden';
        floater.style.background = '#000';
        floater.style.borderRadius = '0px';
        floater.style.transformOrigin = '0 0';
        floater.style.willChange = 'transform';

        // Set the initial inverted transform BEFORE adding to the DOM to avoid a 1-frame flash.
        floater.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(${scaleX}, ${scaleY})`;
        document.body.appendChild(floater);

        // Move the SAME iframe into the floater for animation (no reload).
        try { floater.appendChild(accessFrame); } catch {}
        try { accessFrame.style.width = '100%'; accessFrame.style.height = '100%'; } catch {}

        // Fade away the overlay background now that the iframe is outside it.
        try { hideAccessGate(); } catch {}

        let finished = false;
        let finishTimer = null;

        const finish = () => {
          if (finished) return;
          finished = true;
          try { if (finishTimer) window.clearTimeout(finishTimer); } catch {}
          try { floater.removeEventListener('transitionend', finish); } catch {}

          try { accessDock.appendChild(accessFrame); } catch {}
          try { accessFrame.style.width = ''; accessFrame.style.height = ''; } catch {}
          // Hide the animated gate iframe in the dock; show the dedicated header iframe instead.
          // This avoids a navigation/paint hitch right at the end of the motion.
          try { accessFrame.style.opacity = '0'; accessFrame.style.pointerEvents = 'none'; } catch {}
          try { floater.remove(); } catch {}
          dockAnimating = false;

          // Once docked, load the provided 240x80 header-only embed.
          // Keep URL stable so it doesn't re-navigate repeatedly.
          try { ensureDockHeaderEmbedLoaded(); showDockHeaderFrame(); } catch {}
        };

        floater.addEventListener('transitionend', finish);
        finishTimer = window.setTimeout(finish, 800);

        requestAnimationFrame(() => {
          floater.style.transition = 'transform 640ms var(--ease)';
          floater.style.transform = 'translate3d(0, 0, 0) scale(1, 1)';
        });
      });
    }

    function onGateEnteredFallback(){
      if (accessGranted) return;

      accessGranted = true;
      finalizeGateToDock();
      try { afterGate(); } catch {}

      // Best-effort: sync with the server session in the background.
      try { refreshSession(true).catch(()=>{}); } catch {}

      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = null;
    }

    function startGateWatch(){
      try { if (T_GATE_WATCH) clearInterval(T_GATE_WATCH); } catch {}
      T_GATE_WATCH = window.setInterval(() => {
        if (accessGranted) return;
        try {
          const body = accessFrame?.contentDocument?.body;
          // Gate collapses into header after ENTER by adding body.is-header
          if (body && body.classList && body.classList.contains('is-header')) {
            onGateEnteredFallback();
          }
        } catch {}
      }, 250);
    }

    function bootAccessGateEveryRefresh(){
      accessGranted = false;
      try { if (accessFrame) accessFrame.src = `access/?v=${Date.now()}`; } catch (e) {}
      // Warm the docked header iframe so the swap is instant.
      try { ensureDockHeaderEmbedLoaded(); } catch {}
      showAccessGate();
      startGateWatch();
    }

    window.addEventListener('message', (ev)=>{
      const m = ev && ev.data;
      if (!m || typeof m !== 'object') return;
      if (m.type === 'GRUESOME_ACCESS_ENTER') {
        // The iframe gate is the only gate. Once it says ENTER, we proceed.
        // Server session/PoH is still used for privileged actions, but we never loop the gate.
        try {
          const d = m.detail || {};
          const addr = d && d.wallet && d.wallet.address ? String(d.wallet.address) : '';
          const pohOk = !!(d && d.poh && d.poh.verified);
          if (addr) lsSet(K.address, addr);
          if (addr) setBool(K.connected, true);
          if (pohOk) setBool(K.poh, true);
        } catch {}

        accessGranted = true;
        finalizeGateToDock();
        try { afterGate(); } catch {}

        // Best-effort: sync with the server session in the background.
        // (No gating/re-opening here.)
        try { refreshSession(true).catch(()=>{}); } catch {}
      }

      // Legacy embedded pages can request in-dashboard navigation (no new tabs).
      if (m.type === 'GRUESOME_NAV') {
        const view = m.view;
        if (typeof view === 'string' && view) setView(view);
      }
    });

    bootAccessGateEveryRefresh();

    const K = {
      connected: 'arcade.session.connected',
      poh: 'arcade.session.pohVerified',
      address: 'arcade.wallet.address',
      paid: 'arcade.credits.paid',
      paidSpent: 'arcade.stats.paidSpent',
      promoBal: (gid)=>`arcade.credits.promo.${gid}`,
      promoClaimed: (gid)=>`arcade.promo.${gid}.claimed`,
      runs: (gid)=>`arcade.runs.${gid}`,
      best: (gid)=>`arcade.stats.${gid}.bestScore`,
      xp: 'arcade.profile.xp',
      level: 'arcade.profile.level',
      proTier: 'arcade.profile.pro.tier',
      proExp: 'arcade.profile.pro.expiresAt',
      avatar: 'arcade.profile.avatar.dna',
      avatarLast: 'arcade.profile.avatar.lastEditLevel',
      txlog: 'arcade.txlog',
      proposals: 'arcade.proposals',
      tutDone: 'arcade.tutorial.v2.8.done',
      settings: 'arcade.settings',
      selectedGame: 'arcade.ui.selectedGame',
      lbGame: 'arcade.ui.lbGame',
      lbPeriod: 'arcade.ui.lbPeriod'
    };

    function lsGet(k) { try { return localStorage.getItem(k); } catch { return null; } }
    function lsSet(k, v) { try { localStorage.setItem(k, String(v)); } catch {} }
    function lsDel(k) { try { localStorage.removeItem(k); } catch {} }
    function getInt(k, d=0) { const v = parseInt(lsGet(k)||'',10); return Number.isFinite(v)?v:d; }
    function setInt(k, n) { lsSet(k, String(Math.max(0, Math.floor(Number(n)||0)))); }
    function getBool(k) { return String(lsGet(k)||'0') === '1'; }
    function setBool(k, b) { lsSet(k, b ? '1' : '0'); }

    function now() { return Date.now(); }
    function clamp(n,a,b) { return Math.max(a, Math.min(b, n)); }

    function shortAddr(addr) {
      const s = String(addr || '');
      if (!s) return '';
      if (!s.startsWith('0x') || s.length < 12) return s;
      return s.slice(0, 6) + '…' + s.slice(-4);
    }

    // Smooth bonus curve for AC
    function bonusPctForUsd(usd) {
      const maxBonus = 0.15;
      const k = 40;
      const u = Math.max(0, Number(usd)||0);
      const pct = maxBonus * (1 - Math.exp(-u / k));
      return clamp(pct, 0, maxBonus);
    }
    function acOutForUsd(usd) {
      const u = Math.max(0, Number(usd)||0);
      const base = u * 100; // 1 AC = $0.01
      const pct = bonusPctForUsd(u);
      const total = Math.floor(base * (1 + pct));
      return { baseAC: Math.floor(base), bonusPct: pct, totalAC: total };
    }
    function usdForTargetAC(targetAC) {
      const t = Math.max(10, Math.floor(Number(targetAC)||10));
      let lo = 0;
      let hi = Math.max(0.10, t/100);
      for (let i=0;i<24;i++) {
        if (acOutForUsd(hi).totalAC >= t) break;
        hi *= 2;
        if (hi > 10000) break;
      }
      for (let i=0;i<40;i++) {
        const mid = (lo+hi)/2;
        if (acOutForUsd(mid).totalAC >= t) hi = mid;
        else lo = mid;
      }
      return Math.max(0.10, Math.round(hi*100)/100);
    }

    function levelFromXP(xp) { return Math.max(1, Math.floor((xp||0)/100) + 1); }
    function syncLevel() {
      const xp = getInt(K.xp, 0);
      const lvl = levelFromXP(xp);
      const stored = getInt(K.level, 0);
      if (stored !== lvl) setInt(K.level, lvl);
      return lvl;
    }

    function proActive() {
      const tier = String(lsGet(K.proTier) || 'none');
      if (tier === 'none') return false;
      if (tier === 'lifetime') return true;
      const exp = getInt(K.proExp, 0);
      return exp > now();
    }

    function proLabel() {
      if (!proActive()) return 'NONE';
      return String(lsGet(K.proTier) || 'none').toUpperCase();
    }

    function nextUtcMidnightMs() {
      const d = new Date(now());
      return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()+1, 0,0,0);
    }
    function fmtCountdown(ms) {
      const s = Math.max(0, Math.floor(ms/1000));
      const hh = Math.floor((s%86400)/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      const dd = Math.floor(s/86400);
      const pad = (x)=>String(x).padStart(2,'0');
      return (dd>0? (dd+'d '):'') + pad(hh)+':'+pad(mm)+':'+pad(ss);
    }

    // ----- Toasts -----
    const toastHost = document.getElementById('toastHost');
    function toast(title, body) {
      const el = document.createElement('div');
      el.className = 'toast';
      el.innerHTML = `<div class="a">${title}</div><div class="b">${body||''}</div>`;
      toastHost.appendChild(el);
      setTimeout(()=>{ try{ el.remove(); }catch{} }, 2600);
    }

    // ----- Transaction log (simulated) -----
    function getTxLog() {
      try {
        const arr = JSON.parse(lsGet(K.txlog) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function setTxLog(arr) { lsSet(K.txlog, JSON.stringify(arr.slice(0,80))); }
    function addTx(tx) {
      const arr = getTxLog();
      arr.unshift(tx);
      setTxLog(arr);
    }

    // Lightweight feed entries (used by run start/finish)
    function addFeed(label) {
      addTx({
        id: 'feed_' + Math.random().toString(16).slice(2),
        kind: 'feed',
        label: String(label || ''),
        gasEth: '0.00000',
        status: 'confirmed',
        ts: now(),
      });
    }

    // Tx modal
    const txModal = document.getElementById('txModal');
    const txTitle = document.getElementById('txTitle');
    const txDesc = document.getElementById('txDesc');
    const txGas = document.getElementById('txGas');
    const txPreview = document.getElementById('txPreview');
    const btnTxCancel = document.getElementById('btnTxCancel');
    const btnTxConfirm = document.getElementById('btnTxConfirm');
    let pendingTxAction = null;

    function openTxConfirm({ title, desc, gasEth, preview, onConfirm }) {
      pendingTxAction = onConfirm || null;
      txTitle.textContent = title || 'Transaction';
      txDesc.textContent = desc || '';
      txGas.textContent = gasEth ? `~${gasEth} ETH (estimate)` : '~0.0000 ETH (estimate)';
      txPreview.textContent = preview || '';
      txModal.classList.add('show');
    }
    function closeTxConfirm() {
      pendingTxAction = null;
      txModal.classList.remove('show');
    }
    btnTxCancel.addEventListener('click', closeTxConfirm);
    btnTxConfirm.addEventListener('click', ()=>{
      const fn = pendingTxAction;
      closeTxConfirm();
      if (typeof fn === 'function') fn();
    });

    function simulateTx({ kind, label, gasEth='0.00005', apply }) {
      const id = '0x' + Math.random().toString(16).slice(2).padEnd(64,'0').slice(0,64);
      const tx = { id, kind, label, gasEth, status:'pending', ts: now() };
      addTx(tx);
      renderTxFeed();
      toast('Tx submitted', label);
      setTimeout(()=>{
        tx.status = 'confirmed';
        tx.confirmedTs = now();
        const arr = getTxLog().map(x => x.id === tx.id ? tx : x);
        setTxLog(arr);
        try { apply && Promise.resolve(apply(tx)).catch(()=>{}); } catch {}
        renderAll();
        renderTxFeed();
        toast('Tx confirmed', label);
      }, 900 + Math.random()*700);
      return tx;
    }

      // ----- Session state (server + local mirror) -----
    const SESSION = { status:'init', authenticated:false, pohVerified:false, address:'' };

    // Detect whether /api is actually being served (static `serve` does not).
    const API_CAPS = { available: true };

    function isLocalhostHost() {
      return /^(localhost|127\.0\.0\.1|::1)$/i.test(location.hostname);
    }

    function isApiPath(u) {
      return typeof u === 'string' && u.startsWith('/api/');
    }

    function randAddr() {
      const hex = '0123456789abcdef';
      let s = '0x';
      for (let i=0;i<40;i++) s += hex[Math.floor(Math.random()*16)];
      return s;
    }

    const UI_CAPS = {
      mobile: window.matchMedia && window.matchMedia('(max-width: 980px)').matches,
      reducedMotion: window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
    };

    function updateUiCaps() {
      try {
        UI_CAPS.mobile = window.matchMedia && window.matchMedia('(max-width: 980px)').matches;
        UI_CAPS.reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      } catch {}
    }

    async function apiJson(url, opts) {
      const started = now();
      try {
        const timeoutMs = (opts && Number.isFinite(opts.timeoutMs)) ? Math.max(1000, Math.floor(opts.timeoutMs)) : (UI_CAPS.mobile ? 6500 : 9000);
        const ctrl = (window.AbortController) ? new AbortController() : null;
        const to = ctrl ? window.setTimeout(() => { try { ctrl.abort(); } catch {} }, timeoutMs) : null;

        const res = await fetch(url, {
          method: (opts && opts.method) || 'GET',
          headers: { 'content-type': 'application/json', ...(opts && opts.headers ? opts.headers : {}) },
          body: opts && opts.body ? JSON.stringify(opts.body) : undefined,
          credentials: 'include',
          signal: ctrl ? ctrl.signal : undefined
        });

        if (to) window.clearTimeout(to);

        // If we got a response at all, the server is reachable.
        API_STATE.online = true;
        API_STATE.lastOk = now();
        API_STATE.lastErr = '';

        const text = await res.text();
        let data = {};
        try { data = text ? JSON.parse(text) : {}; } catch { data = { raw: String(text||'') }; }

        // Some endpoints may return a 200 with an explicit error payload (e.g. missing Redis config).
        // Treat these as logical errors so callers continue to use existing catch/fallback paths.
        if (res.ok && data && data.ok === false && data.error) {
          const err = new Error(String(data.error));
          err.status = 503;
          err.data = data;
          throw err;
        }

        if (!res.ok) {
          const err = new Error((data && data.error) ? String(data.error) : ('HTTP_' + res.status));
          err.status = res.status;
          err.data = data;

          // Local static dev server: treat /api 404s as "API not present" and stop trying.
          if (res.status === 404 && isApiPath(url) && isLocalhostHost()) {
            API_CAPS.available = false;
            API_STATE.online = false;
            API_STATE.lastErr = 'api_not_served';
          }

          // Only ping telemetry for server problems / throttling.
          if (API_CAPS.available && !document.hidden && (res.status >= 500 || res.status === 429)) {
            sendTelemetry('api_http_error', {
              url, status: res.status,
              error: err.message,
              ms: Math.round(now() - started)
            });
          }
          throw err;
        }
        return data;
      } catch (e) {
        // HTTP errors are handled above; don't misclassify them as network failures.
        if (e && typeof e.status === 'number') throw e;

        // Network error / CORS / offline
        API_STATE.online = false;
        API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
        if (API_CAPS.available && !document.hidden) {
          sendTelemetry('api_network_error', {
            url,
            error: API_STATE.lastErr,
            ms: Math.round(now() - started)
          });
        }
        throw e;
      }
    }

    function mirrorSessionToLocal(s) {
      setBool(K.connected, !!s.authenticated);
      setBool(K.poh, !!s.pohVerified);
      if (s.address) lsSet(K.address, String(s.address));
      else lsDel(K.address);
    }

    const API_STATE = { online:true, lastOk:0, lastErr:'' };

    // Production: global network banner
    const netBanner = document.getElementById('netBanner');
    function setNetBanner(kind, title, body) {
      if (!netBanner) return;
      if (!kind) {
        netBanner.className = 'netBanner';
        netBanner.innerHTML = '';
        return;
      }
      netBanner.className = 'netBanner show ' + String(kind);
      netBanner.innerHTML = `<div class="a">${String(title||'Status')}</div><div class="b">${String(body||'')}</div>`;
    }

    function renderNetBanner() {
      // Hide while iframe gate is visible (avoid UI noise under the gate).
      try {
        if (accessOverlay && !accessOverlay.classList.contains('is-hidden')) {
          setNetBanner(null);
          return;
        }
      } catch {}

      if (!API_CAPS.available && isLocalhostHost()) {
        setNetBanner('warn', 'API not served', 'Run `npm run preview` for full-stack mode. Static `npm run dev` does not serve /api/*.' );
        return;
      }

      if (SESSION && SESSION.status === 'loading') {
        setNetBanner('warn', 'Checking session', 'Connecting to server…');
        return;
      }

      if (!API_STATE.online) {
        const msg = API_STATE.lastErr ? String(API_STATE.lastErr) : 'offline';
        setNetBanner('bad', 'Server offline', `Some features disabled. (${msg})`);
        return;
      }

      if (SESSION && SESSION.status === 'ok' && SESSION.authenticated && !SESSION.pohVerified) {
        setNetBanner('warn', 'PoH required', 'Complete PoH in Linea Hub, then refresh session in the access gate.');
        return;
      }

      setNetBanner(null);
    }

    // Lightweight client telemetry (writes to /api/telemetry; no web3 yet)
    const TELEMETRY_STATE = {
      budget: 8,
      sent: 0,
      lastTs: 0
    };

    function sendTelemetry(type, payload) {
      try {
        if (!API_CAPS.available) return;
        if (!type) return;
        if (TELEMETRY_STATE.sent >= TELEMETRY_STATE.budget) return;
        const nowTs = Date.now();
        if (nowTs - TELEMETRY_STATE.lastTs < 400) return; // small anti-burst
        TELEMETRY_STATE.lastTs = nowTs;

        const body = {
          type,
          message: (payload && payload.message) ? String(payload.message) : '',
          url: (payload && payload.url) ? String(payload.url) : location.href,
          view: (document.body && document.body.dataset && document.body.dataset.view) ? document.body.dataset.view : '',
          uiVersion: document.documentElement.getAttribute('data-ui-version') || '2.8',
          gameId: currentGameId || '',
          extra: payload || undefined
        };

        TELEMETRY_STATE.sent++;

        // Prefer sendBeacon (non-blocking)
        if (navigator.sendBeacon) {
          const blob = new Blob([JSON.stringify(body)], { type: 'application/json' });
          navigator.sendBeacon('/api/telemetry', blob);
          return;
        }

        // Fallback
        fetch('/api/telemetry', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body),
          credentials: 'include',
          keepalive: true
        }).catch(()=>{});
      } catch {}
    }

    // Global error listeners (best-effort)
    window.addEventListener('error', (ev) => {
      try {
        const msg = ev && ev.message ? String(ev.message) : 'error';
        const src = ev && ev.filename ? String(ev.filename) : '';
        sendTelemetry('client_error', { message: msg, src, line: ev.lineno, col: ev.colno, stack: (ev.error && ev.error.stack) ? String(ev.error.stack) : '' });
      } catch {}
    });

    window.addEventListener('unhandledrejection', (ev) => {
      try {
        const r = ev && ev.reason;
        const msg = r ? (r.message || String(r)) : 'unhandledrejection';
        const stack = (r && r.stack) ? String(r.stack) : '';
        sendTelemetry('client_rejection', { message: String(msg), stack });
      } catch {}
    });

    const LB_CACHE = { key:'', ts:0, loading:false, entries:null, you:null, err:'' };
    const PROP_CACHE = { ts:0, loading:false, list:null, err:'' };
    const EPOCH_CACHE = { ts:0, loading:false, data:null, err:'' };

    function applyServerState(st) {
      if (!st) return;
      if (st.address) lsSet(K.address, String(st.address));
      if (st.paidAC != null) setInt(K.paid, Math.max(0, Math.floor(Number(st.paidAC)||0)));
      if (st.xp != null) setInt(K.xp, Math.max(0, Math.floor(Number(st.xp)||0)));
      if (st.level != null) setInt(K.level, Math.max(1, Math.floor(Number(st.level)||0)));
      if (st.proTier) lsSet(K.proTier, String(st.proTier));
      if (st.proExp != null) lsSet(K.proExp, String(st.proExp));

      if (st.promoAC && typeof st.promoAC === 'object') {
        for (const [gid, v] of Object.entries(st.promoAC)) {
          setInt(K.promoBal(gid), Math.max(0, Math.floor(Number(v||0))));
        }
      }
      if (st.best && typeof st.best === 'object') {
        for (const [gid, v] of Object.entries(st.best)) {
          setInt(K.best(gid), Math.max(0, Math.floor(Number(v||0))));
        }
      }
    }

    async function refreshLedger() {
      try {
        const st = await apiJson('/api/ledger/balance');
        API_STATE.online = true;
        API_STATE.lastOk = now();
        API_STATE.lastErr = '';
        applyServerState(st);
        return st;
      } catch (e) {
        API_STATE.online = false;
        API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
        return null;
      }
    }

    async function serverBuyAC(usd) {
      return apiJson('/api/ledger/buy', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { usd }
      });
    }
    async function serverProfilePatch(patch) {
      return apiJson('/api/ledger/profile', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: patch||{}
      });
    }
    async function serverClaimPromo(gameId) {
      return apiJson('/api/promo/claim', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId }
      });
    }
    async function serverRunStart(gameId) {
      return apiJson('/api/run/start', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId }
      });
    }
    async function serverRunSubmit(payload) {
      return apiJson('/api/run/submit', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: payload||{}
      });
    }

    async function refreshLeaderboard(gameId, period) {
      const key = String(gameId) + '|' + String(period);
      if (LB_CACHE.loading) return;
      const stale = (!LB_CACHE.ts) || (now() - LB_CACHE.ts > 15000) || (LB_CACHE.key !== key);
      if (!stale) return;
      LB_CACHE.loading = true;
      LB_CACHE.err = '';
      try {
        const url = '/api/leaderboard/top?gameId=' + encodeURIComponent(gameId) + '&period=' + encodeURIComponent(period) + '&eligible=1';
        const data = await apiJson(url);
        LB_CACHE.key = key;
        LB_CACHE.ts = now();
        LB_CACHE.entries = (data && Array.isArray(data.entries)) ? data.entries : [];
        LB_CACHE.you = data ? data.you : null;
        API_STATE.online = true;
        API_STATE.lastOk = now();
        renderLocalLB();
      } catch (e) {
        LB_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        LB_CACHE.loading = false;
      }
    }

    async function refreshProposals() {
      if (PROP_CACHE.loading) return;
      const stale = (!PROP_CACHE.ts) || (now() - PROP_CACHE.ts > 20000);
      if (!stale) return;
      PROP_CACHE.loading = true;
      PROP_CACHE.err = '';
      try {
        const data = await apiJson('/api/proposals/list?limit=20');
        PROP_CACHE.ts = now();
        PROP_CACHE.list = (data && Array.isArray(data.proposals)) ? data.proposals : [];
        API_STATE.online = true;
        API_STATE.lastOk = now();
        renderProposals();
      } catch (e) {
        PROP_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        PROP_CACHE.loading = false;
      }
    }



    async function refreshEpochStatus(force=false) {
      if (EPOCH_CACHE.loading) return;
      const stale = force || (!EPOCH_CACHE.ts) || (now() - EPOCH_CACHE.ts > 20000);
      if (!stale) return;
      EPOCH_CACHE.loading = true;
      EPOCH_CACHE.err = '';
      try {
        const data = await apiJson('/api/epoch/status');
        EPOCH_CACHE.data = data;
        EPOCH_CACHE.ts = now();
        API_STATE.online = true;
        API_STATE.lastOk = now();
      } catch (e) {
        EPOCH_CACHE.err = (e && e.message) ? String(e.message) : 'offline';
      } finally {
        EPOCH_CACHE.loading = false;
      }
    }

    async function serverEpochClaim(ymd) {
      return apiJson('/api/epoch/claim', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { ymd: ymd||'' }
      });
    }

    async function serverMintBadge(gameId) {
      return apiJson('/api/badge/mint', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: { gameId: String(gameId||'') }
      });
    }

    async function refreshSession(silent=false) {
      SESSION.status = 'loading';
      try {
        const s = await apiJson('/api/session');
        SESSION.status = 'ok';
        SESSION.authenticated = !!s.authenticated;
        SESSION.pohVerified = !!s.pohVerified;
        SESSION.address = String(s.address || '');
        mirrorSessionToLocal(SESSION);
        if (SESSION.authenticated) { await refreshLedger(); await refreshEpochStatus(true); }
      } catch (e) {
        // Offline fallback: use local demo state
        SESSION.status = 'offline';
        SESSION.authenticated = getBool(K.connected);
        SESSION.pohVerified = getBool(K.poh);
        SESSION.address = lsGet(K.address) || '';
        API_STATE.online = false;
      }
      renderAll();
      return SESSION;
    }

    // ----- Adaptive timers (mobile-simple + background tab throttling) -----
    let T_EPOCH = null;
    let T_RENDER = null;
    let T_EPOCH_POLL = null;
    function stopTimers() {
      try { if (T_EPOCH) clearInterval(T_EPOCH); } catch {}
      try { if (T_RENDER) clearInterval(T_RENDER); } catch {}
      try { if (T_EPOCH_POLL) clearInterval(T_EPOCH_POLL); } catch {}
      T_EPOCH = T_RENDER = T_EPOCH_POLL = null;
    }

    function startTimers() {
      const hidden = !!document.hidden;
      const mobile = !!UI_CAPS.mobile;

      const epochTickMs = hidden ? 5000 : (mobile ? 1000 : 250);
      const renderTickMs = hidden ? 15000 : (mobile ? 4000 : 2500);
      const epochPollMs = hidden ? 60000 : (mobile ? 30000 : 20000);

      T_EPOCH = setInterval(()=>{ renderEpoch(); renderExpoCountdown(); }, epochTickMs);
      T_RENDER = setInterval(()=>{ renderAll(); renderNetBanner(); }, renderTickMs);
      T_EPOCH_POLL = setInterval(()=>{ if (API_CAPS.available && SESSION.authenticated) refreshEpochStatus(); }, epochPollMs);
    }

    function restartTimers() {
      stopTimers();
      startTimers();
    }

    async function afterGate() {
      if (!getBool(K.tutDone)) {
        setTimeout(()=>startTutorial(), 450);
      }
      await refreshLedger();
      refreshProposals();
      // best-effort warm caches for visible views
      try { refreshLeaderboard(getLbGameId(), getLbPeriod()); } catch {}
      syncToGame();
      renderAll();
    }

// ----- Navigation -----
    const navBtns = Array.from(document.querySelectorAll('.nav button[data-nav]'));
    const views = {
      play: document.getElementById('view-play'),
      wallet: document.getElementById('view-wallet'),
      leaderboard: document.getElementById('view-leaderboard'),
      proposals: document.getElementById('view-proposals'),
      settings: document.getElementById('view-settings')
    };
    const topTitle = document.getElementById('topTitle');
    const topSub = document.getElementById('topSub');

    function setView(name) {
      document.body.dataset.view = name;
      navBtns.forEach(b => b.classList.toggle('active', b.dataset.nav === name));
      Object.entries(views).forEach(([k, el]) => el.classList.toggle('active', k === name));
      topTitle.textContent = name.charAt(0).toUpperCase()+name.slice(1);
      topSub.textContent = (name === 'play') ? ((currentGame && currentGame.name) ? (currentGame.name + ' · ' + (currentGame.tagline||'')) : 'Choose a game to play.')
        : (name === 'wallet') ? 'Buy credits + manage PRO + avatar.'
        : (name === 'leaderboard') ? 'Ranks, payouts, and daily epochs.'
        : (name === 'proposals') ? 'Pay gas to submit ideas. Earn if accepted.'
        : 'Preferences + utilities.';

      

      // Leaderboard v2 loader
      if (name === 'leaderboard') {
        try { ensureLeaderboardV2Loaded(); } catch {}
      }

      // Update 3D accent
      const cssAccent = getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#22d3ee';
      try { window.__arcadeScene && window.__arcadeScene.setAccent(cssAccent); } catch {}
    }
    navBtns.forEach(btn => btn.addEventListener('click', ()=>setView(btn.dataset.nav)));

    function getRouteIntent() {
      // Single-dashboard URL rule: only use hash/query to select a view.
      // Do NOT route based on pathname like /wallet or /avatar_studio.
      let view = 'play';
      let scrollId = '';

      try {
        const u = new URL(window.location.href);
        const hash = String(u.hash || '').replace('#', '').toLowerCase();
        const qpView = String(u.searchParams.get('view') || '').toLowerCase();

        if (qpView && ['play','wallet','leaderboard','proposals','settings'].includes(qpView)) view = qpView;
        if (hash && ['play','wallet','leaderboard','proposals','settings'].includes(hash)) view = hash;
        if (hash === 'avatar') { view = 'wallet'; scrollId = 'avatarCard'; }
      } catch {}

      return { view, scrollId };
    }

    // ----- Leaderboard v2 (drop-in bundle) -----
    let GA_LB_V2_LOADED = false;

    function gaFetchText(url) {
      return fetch(url, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error('HTTP_' + r.status);
        return r.text();
      });
    }

    function gaLoadCssOnce(href, id) {
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      link.href = href;
      document.head.appendChild(link);
    }

    function gaLoadScriptOnce(src, id) {
      return new Promise((resolve, reject) => {
        if (document.getElementById(id)) return resolve();
        const s = document.createElement('script');
        s.id = id;
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error('script_load_failed'));
        document.head.appendChild(s);
      });
    }

    async function serverWeekClaim(yw) {
      return apiJson('/api/week/claim', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: { yw }
      });
    }

    async function ensureLeaderboardV2Loaded() {
      if (GA_LB_V2_LOADED) return;
      GA_LB_V2_LOADED = true;

      // Adapter surface consumed by /public/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.js
      window.__ARCADE_LB_ADAPTER__ = {
        version: '2.0',
        apiJson,
        toast,
        shortAddr,
        openWallet: () => setView('wallet'),
        getSession: () => ({
          connected: isConnected(),
          address: (SESSION && SESSION.address) ? SESSION.address : (lsGet(K.address) || null),
          pohVerified: (SESSION && typeof SESSION.pohVerified === 'boolean') ? SESSION.pohVerified : getBool(K.poh),
        }),
        getEpoch: () => (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : {},
        getCatalog: async () => (CATALOG || null),

        claimDaily: async () => {
          try {
            if (!isConnected()) return toast('Wallet', 'Connect wallet to claim.');
            const e = (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : null;
            const ymd = e && e.lastSettledYmd ? String(e.lastSettledYmd) : '';
            if (!ymd) return toast('Claim', 'No settled day available yet.');
            const cents = (e && e.claimable && e.claimable.record) ? Number(e.claimable.record.totalCents || 0) : 0;
            const usd = Math.max(0, cents) / 100;

            openTxConfirm({
              title: 'Claim daily payout',
              lines: [
                `Epoch: ${ymd}`,
                `Estimated: ${usd.toFixed(2)} mUSD`,
                'You will pay user gas.',
              ],
              onConfirm: async () => {
                await simulateTx({
                  title: 'Claiming…',
                  steps: [
                    { label: 'Prepare claim' },
                    { label: 'Submit claim' },
                    { label: 'Finalize' },
                  ],
                  run: async (step) => {
                    step(0);
                    await sleep(180);
                    step(1);
                    const r = await serverEpochClaim(ymd);
                    await sleep(180);
                    step(2);
                    return r;
                  },
                  onDone: async (r) => {
                    toast('Claim', `Daily claimed: ${(r && r.amountUsd != null) ? Number(r.amountUsd).toFixed(2) : '0.00'} mUSD`);
                    try { await refreshEpochStatus(true); } catch {}
                    try { await refreshLedger(); } catch {}
                    try { window.__GA_LB_V2__ && window.__GA_LB_V2__.refresh && window.__GA_LB_V2__.refresh(); } catch {}
                  }
                });
              }
            });
          } catch (err) {
            toast('Claim', 'Failed to claim daily.');
          }
        },

        claimWeekly: async () => {
          try {
            if (!isConnected()) return toast('Wallet', 'Connect wallet to claim.');
            const e = (EPOCH_CACHE && EPOCH_CACHE.data) ? EPOCH_CACHE.data : null;
            const yw = e && e.lastSettledYw ? String(e.lastSettledYw) : '';
            if (!yw) return toast('Claim', 'No settled week available yet.');
            const cents = (e && e.weekClaimable && e.weekClaimable.record) ? Number(e.weekClaimable.record.totalCents || 0) : 0;
            const usd = Math.max(0, cents) / 100;

            openTxConfirm({
              title: 'Claim weekly payout',
              lines: [
                `Week: ${yw}`,
                `Estimated: ${usd.toFixed(2)} mUSD`,
                'You will pay user gas.',
              ],
              onConfirm: async () => {
                await simulateTx({
                  title: 'Claiming…',
                  steps: [
                    { label: 'Prepare claim' },
                    { label: 'Submit claim' },
                    { label: 'Finalize' },
                  ],
                  run: async (step) => {
                    step(0);
                    await sleep(180);
                    step(1);
                    const r = await serverWeekClaim(yw);
                    await sleep(180);
                    step(2);
                    return r;
                  },
                  onDone: async (r) => {
                    toast('Claim', `Weekly claimed: ${(r && r.amountUsd != null) ? Number(r.amountUsd).toFixed(2) : '0.00'} mUSD`);
                    try { await refreshEpochStatus(true); } catch {}
                    try { await refreshLedger(); } catch {}
                    try { window.__GA_LB_V2__ && window.__GA_LB_V2__.refresh && window.__GA_LB_V2__.refresh(); } catch {}
                  }
                });
              }
            });
          } catch (err) {
            toast('Claim', 'Failed to claim weekly.');
          }
        },
      };

      gaLoadCssOnce('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.css', 'ga-lb-v2-css');

      const host = document.querySelector('[data-ga-lb-host]');
      if (!host) return;

      try {
        host.innerHTML = await gaFetchText('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard-panel.html');
      } catch (e) {
        host.innerHTML = '<div class="card"><div class="mini muted">Failed to load Leaderboard UI bundle.</div></div>';
        return;
      }

      try {
        await gaLoadScriptOnce('/gruesome-arcade-leaderboard-ui-v2.0/leaderboard.js', 'ga-lb-v2-js');
      } catch (e) {
        host.innerHTML = '<div class="card"><div class="mini muted">Failed to load Leaderboard UI script.</div></div>';
        return;
      }

      try { window.__GA_LB_V2__ && window.__GA_LB_V2__.onShow && window.__GA_LB_V2__.onShow(); } catch {}
    }


    // ----- Top chips -----
    const chipWallet = document.getElementById('chipWallet');
    const chipWalletT = document.getElementById('chipWalletT');
    const chipPOH = document.getElementById('chipPOH');
    const chipPOHT = document.getElementById('chipPOHT');
    const chipCreditsT = document.getElementById('chipCreditsT');
    const chipEpochT = document.getElementById('chipEpochT');

    function renderTopChips() {
      const connected = getBool(K.connected);
      const poh = getBool(K.poh);
      const addr = lsGet(K.address) || '0x…';
      chipWallet.className = 'chip ' + (connected ? 'good' : 'warn');
      chipWalletT.textContent = connected ? ('Wallet: ' + addr.slice(0,6) + '…' + addr.slice(-4)) : 'Wallet: not connected';
      chipPOH.className = 'chip ' + (poh ? 'good' : 'warn');
      chipPOHT.textContent = poh ? 'POH: verified' : 'POH: not verified';

      const paid = getInt(K.paid, 0);
      const promo = getInt(K.promoBal(currentGameId), 0);
      const g = (currentGame && currentGame.name) ? currentGame.name : currentGameId;
      chipCreditsT.textContent = `AC: ${paid} paid · ${promo} promo (${g})`;
    }

    function renderEpoch() {
      const ms = nextUtcMidnightMs() - now();
      const countdown = fmtCountdown(ms);

      // Append claim hint if available
      let hint = '';
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;
      if (rec && !claimed) {
        const amt = Number(rec.totalUsd || 0);
        if (amt > 0) hint = ` · Claim ${amt.toFixed(2)} mUSD`;
      }

      chipEpochT.textContent = 'Next payout: ' + countdown + hint;
      const el = document.getElementById('lbEpoch');
      if (el) el.textContent = countdown;
    }

    // ----- Bars (55/35/10) -----
    const barSkill = document.getElementById('barSkill');
    const barActivity = document.getElementById('barActivity');
    const barPro = document.getElementById('barPro');

    // Leaderboard + rewards refs (avoid relying on implicit window.id globals)
    const lbSkillPts = document.getElementById('lbSkillPts');
    const lbActPts = document.getElementById('lbActPts');
    const lbProBoost = document.getElementById('lbProBoost');
    const lbTickets = document.getElementById('lbTickets');
    const lbLottery = document.getElementById('lbLottery');
    const lbWinners = document.getElementById('lbWinners');
    const lbClaim = document.getElementById('lbClaim');
    const lbNextEst = document.getElementById('lbNextEst');
    const btnClaimPayout = document.getElementById('btnClaimPayout');
    const btnMintBadge = document.getElementById('btnMintBadge');

    function renderSplitBars() {
      barSkill.style.width = ECON.SPLIT.skill + '%';
      barActivity.style.width = ECON.SPLIT.activity + '%';
      barPro.style.width = ECON.SPLIT.pro + '%';
    }

    // ----- Play view actions + Game Library -----
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnClaimPromo = document.getElementById('btnClaimPromo');
    const btnOpenWallet = document.getElementById('btnOpenWallet');
    const btnOpenSuggestions = document.getElementById('btnOpenSuggestions');
    const gameFrame = document.getElementById('gameFrame');
    const gameTiles = document.getElementById('gameTiles');

    const playTitle = document.getElementById('playTitle');
    const playDesc = document.getElementById('playDesc');
    const pillRunCost = document.getElementById('pillRunCost');

    btnOpenWallet.addEventListener('click', ()=>setView('wallet'));
    btnOpenSuggestions.addEventListener('click', ()=>setView('proposals'));
    btnFullscreen.addEventListener('click', ()=>{
      const portal = document.getElementById('portal');
      if (!document.fullscreenElement) portal.requestFullscreen?.();
      else document.exitFullscreen?.();
    });

    async function loadCatalog() {
      try {
        const res = await fetch(MANIFEST_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('manifest not ok');
        CATALOG = await res.json();
      } catch (e) {
        CATALOG = FALLBACK_CATALOG;
      }
      GAMES = Array.isArray(CATALOG?.games) ? CATALOG.games : [];
      if (!GAMES.length) GAMES = FALLBACK_CATALOG.games || [];
      return CATALOG;
    }

    function gameById(id) {
      return (GAMES || []).find(g => g.id === id) || null;
    }

    function clampGameId(id) {
      if (gameById(id)) return id;
      const firstLive = (GAMES||[]).find(g => g.status === 'live') || (GAMES||[])[0];
      return firstLive ? firstLive.id : 'moonshot';
    }

    function renderGameTiles() {
      if (!gameTiles) return;
      gameTiles.innerHTML = '';
      (GAMES||[]).forEach(g => {
        const isActive = g.id === currentGameId;
        const disabled = g.status !== 'live';
        const el = document.createElement('div');
        el.className = 'gameTile' + (isActive ? ' active' : '') + (disabled ? ' disabled' : '');
        el.innerHTML = `
          <div class="n">${g.name}</div>
          <div class="d">${g.tagline || ''}</div>
          <div class="meta">
            <span class="badge ${disabled ? 'soon':'live'}">${disabled ? 'coming soon' : 'live'}</span>
            <span class="badge">${disabled ? '—' : (g.runCostAC + ' AC/run')}</span>
          </div>
        `;
        el.addEventListener('click', ()=>{
          if (disabled) {
            toast('Coming soon', 'This game is not live yet.');
            return;
          }
          selectGame(g.id);
        });
        gameTiles.appendChild(el);
      });
    }

    function setPlayCopy() {
      const g = currentGame;
      if (!g) {
        playTitle.textContent = 'Choose a game';
        playDesc.textContent = 'Select a live game from the library.';
        pillRunCost.textContent = 'Loading · -- AC/run';
        btnClaimPromo.textContent = 'Claim promo (Tx)';
        return;
      }
      playTitle.textContent = g.name;
      const promoLine = (g.promoRuns && g.promoRuns > 0) ? (`Promo: first ${g.promoRuns} runs free (claim is gas-paid later).`) : 'No promo currently.';
      playDesc.textContent = `Run cost: ${g.runCostAC} AC ($${(g.runCostAC*ECON.AC_USD).toFixed(2)}). ${promoLine}`;
      pillRunCost.textContent = `${g.name} · ${g.runCostAC} AC/run`;
      const claimed = getBool(K.promoClaimed(currentGameId));
      btnClaimPromo.textContent = claimed ? 'Promo claimed' : 'Claim promo (Tx)';
      btnClaimPromo.disabled = claimed || !(g.promoRuns > 0);
    }

    function selectGame(id) {
      currentGameId = clampGameId(id);
      currentGame = gameById(currentGameId);
      lsSet(K.selectedGame, currentGameId);

      frameReady = false;
      try { if (gameFrame) gameFrame.src = currentGame.embedUrl; } catch {}

      renderGameTiles();
      setPlayCopy();
      renderAll();

      // Reset run-mode pill until the game reports a run.
      const pill = document.getElementById('pillRunMode');
      if (pill) pill.textContent = 'Run type: --';
    }

    function claimPromoTx(gameId) {
      const g = gameById(gameId);
      if (!g || !(g.promoRuns > 0)) {
        toast('No promo', 'This game has no promo right now.');
        return;
      }
      if (getBool(K.promoClaimed(gameId))) {
        toast('Promo already claimed', 'You already claimed the promo for this game.');
        return;
      }
      openTxConfirm({
        title: `Claim Promo · ${g.name}`,
        desc: `Claim ${g.promoRuns} free runs (adds ${g.promoGrantAC} promo AC for ${g.name}).`,
        gasEth: '0.00004',
        preview: `Writes: ${K.promoClaimed(gameId)}=1, +${g.promoGrantAC} to ${K.promoBal(gameId)}`,
        onConfirm: ()=>{
          simulateTx({
            kind:'promo-claim',
            label:`Claim ${g.promoRuns} free runs · ${g.name}`,
            gasEth:'0.00004',
            apply: async ()=>{
              // Server-authoritative promo claim (idempotent)
              try{
                const r = await serverClaimPromo(gameId);
                setBool(K.promoClaimed(gameId), true);
                if (r && r.promoAC!=null) setInt(K.promoBal(gameId), r.promoAC);
              } catch {
                setBool(K.promoClaimed(gameId), true);
                setInt(K.promoBal(gameId), getInt(K.promoBal(gameId),0) + Number(g.promoGrantAC||0));
              }
              syncToGame();
              sendToGame('ARCADE:PROMO_CLAIMED', { gameId, promoAC: getInt(K.promoBal(gameId),0) });
            }
          });
        }
      });
    }

    btnClaimPromo.addEventListener('click', ()=>claimPromoTx(currentGameId));

    // Leaderboard game select options (populated after catalog load)
    const lbGameSelect = document.getElementById('lbGameSelect');
    function getLbGameId() {
      try {
        const v = (lbGameSelect && lbGameSelect.value) ? String(lbGameSelect.value) : String(lsGet(K.lbGame) || currentGameId);
        return clampGameId(v);
      } catch {
        return currentGameId;
      }
    }
    function getLbPeriod() {
      try { return String(lsGet(K.lbPeriod) || 'daily'); } catch { return 'daily'; }
    }
    function populateLbSelect() {
      if (!lbGameSelect) return;
      lbGameSelect.innerHTML = '';
      (GAMES||[]).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g.id;
        opt.textContent = g.name;
        lbGameSelect.appendChild(opt);
      });
      const saved = lsGet(K.lbGame) || currentGameId;
      lbGameSelect.value = clampGameId(saved);
    }
    lbGameSelect?.addEventListener('change', ()=>{
      lsSet(K.lbGame, lbGameSelect.value);
      renderAll();
    });

    // ----- Wallet: buy AC -----
    const tabUsd = document.getElementById('tabUsd');
    const tabAc = document.getElementById('tabAc');
    const panelUsd = document.getElementById('panelUsd');
    const panelAc = document.getElementById('panelAc');
    const usdIn = document.getElementById('usdIn');
    const usdRange = document.getElementById('usdRange');
    const usdBig = document.getElementById('usdBig');
    const acIn = document.getElementById('acIn');
    const acBig = document.getElementById('acBig');

    const outBase = document.getElementById('outBase');
    const outBonus = document.getElementById('outBonus');
    const outTotal = document.getElementById('outTotal');
    const outEff = document.getElementById('outEff');
    const btnBuyAc = document.getElementById('btnBuyAc');
    const btnCustomExact = document.getElementById('btnCustomExact');

    let buyMode = 'usd'; // 'usd' | 'ac'

    function setBuyMode(mode) {
      buyMode = mode;
      tabUsd.classList.toggle('active', mode==='usd');
      tabAc.classList.toggle('active', mode==='ac');
      panelUsd.style.display = (mode==='usd') ? '' : 'none';
      panelAc.style.display = (mode==='ac') ? '' : 'none';
      recalcBuyOutputs();
    }
    tabUsd.addEventListener('click', ()=>setBuyMode('usd'));
    tabAc.addEventListener('click', ()=>setBuyMode('ac'));

    function recalcBuyOutputs() {
      let usd = Number(usdIn.value || 0);
      let targetAC = Number(acIn.value || 0);

      if (buyMode === 'ac') {
        usd = usdForTargetAC(targetAC);
        usdIn.value = usd.toFixed(2);
        usdRange.value = String(clamp(usd, Number(usdRange.min), Number(usdRange.max)));
        acBig.textContent = `${Math.floor(targetAC||0)} AC`;
      } else {
        usdRange.value = String(clamp(usd, Number(usdRange.min), Number(usdRange.max)));
        usdBig.textContent = '$' + usd.toFixed(2);
      }

      const out = acOutForUsd(usd);
      outBase.textContent = String(out.baseAC);
      outBonus.textContent = '+' + (out.bonusPct*100).toFixed(1) + '%';
      outTotal.textContent = String(out.totalAC);
      const eff = usd / Math.max(1, out.totalAC);
      outEff.textContent = '$' + eff.toFixed(4);

      usdBig.textContent = '$' + usd.toFixed(2);
    }

    usdIn.addEventListener('input', ()=>{
      const usd = clamp(Number(usdIn.value||0.10), 0.10, 10000);
      usdIn.value = usd.toFixed(2);
      usdBig.textContent = '$' + usd.toFixed(2);
      usdRange.value = String(clamp(usd, Number(usdRange.min), Number(usdRange.max)));
      if (buyMode === 'ac') {
        const out = acOutForUsd(usd);
        acIn.value = String(out.totalAC);
        acBig.textContent = `${out.totalAC} AC`;
      }
      recalcBuyOutputs();
    });

    usdRange.addEventListener('input', ()=>{
      const usd = Number(usdRange.value||0.10);
      usdIn.value = usd.toFixed(2);
      usdBig.textContent = '$' + usd.toFixed(2);
      if (buyMode === 'ac') {
        const out = acOutForUsd(usd);
        acIn.value = String(out.totalAC);
        acBig.textContent = `${out.totalAC} AC`;
      }
      recalcBuyOutputs();
    });

    acIn.addEventListener('input', ()=>{
      const ac = Math.max(10, Math.floor(Number(acIn.value)||10));
      acIn.value = String(ac);
      acBig.textContent = `${ac} AC`;
      recalcBuyOutputs();
    });

    document.querySelectorAll('.chipBtn[data-usd]').forEach(el => el.addEventListener('click', ()=>{
      const usd = Number(el.getAttribute('data-usd'));
      usdIn.value = usd.toFixed(2);
      usdRange.value = String(clamp(usd, Number(usdRange.min), Number(usdRange.max)));
      usdBig.textContent = '$' + usd.toFixed(2);
      setBuyMode('usd');
      recalcBuyOutputs();
    }));
    document.querySelectorAll('.chipBtn[data-ac]').forEach(el => el.addEventListener('click', ()=>{
      const ac = Number(el.getAttribute('data-ac'));
      acIn.value = String(ac);
      acBig.textContent = `${ac} AC`;
      setBuyMode('ac');
      recalcBuyOutputs();
    }));

    function buyACtx(customUsdOverride=null) {
      const usd = (customUsdOverride!=null) ? Number(customUsdOverride) : Number(usdIn.value||0);
      const safeUsd = clamp(usd, 0.10, 100000);
      const out = acOutForUsd(safeUsd);
      const label = `Buy ${out.totalAC} AC`;

      openTxConfirm({
        title: 'Buy Arcade Credits',
        desc: `Pay $${safeUsd.toFixed(2)} equivalent in Linea (native) to receive ${out.totalAC} AC (onchain later).`,
        gasEth: '0.00006',
        preview: `Adds +${out.totalAC} to ${K.paid} (bonus included).`,
        onConfirm: ()=>{
          simulateTx({
            kind:'buy-ac',
            label,
            gasEth:'0.00006',
            apply: async ()=>{
              // Server-authoritative AC (Redis). Local fallback if offline.
              try{
                const r = await serverBuyAC(safeUsd);
                if (r && r.paidAC!=null) setInt(K.paid, r.paidAC);
              } catch {
                setInt(K.paid, getInt(K.paid,0) + out.totalAC);
              }
              renderTopChips(); syncToGame();
            }
          });
        }
      });
    }

    btnBuyAc.addEventListener('click', ()=>buyACtx(null));
    btnCustomExact.addEventListener('click', ()=>{
      openTxConfirm({
        title: 'Custom AC Purchase',
        desc: 'Enter any USD amount you want. Even $0.10 works. Bonus scales smoothly with size.',
        gasEth: '0.00006',
        preview: 'This is the same buy flow, just emphasizing exact micro-buys.',
        onConfirm: ()=>{
          buyACtx(Number(usdIn.value||0.10));
        }
      });
    });

    // ----- PRO purchases -----
    const btnProMini = document.getElementById('btnProMini');
    const btnProPrime = document.getElementById('btnProPrime');
    const btnProLife = document.getElementById('btnProLife');
    const expoLeft = document.getElementById('expoLeft');

    function proTx(tier) {
      const price = (tier==='mini') ? 2 : (tier==='prime') ? 25 : 100;
      const label = (tier==='lifetime') ? 'Activate PRO Lifetime' : `Activate PRO ${tier}`;
      openTxConfirm({
        title: 'Activate PRO',
        desc: `Activate ${tier.toUpperCase()} for $${price}. (Tx is user-gas-paid)`,
        gasEth: '0.00007',
        preview: `Writes: ${K.proTier}=${tier}, updates expiry (monthly) or lifetime.`,
        onConfirm: ()=>{
          simulateTx({
            kind:'pro',
            label,
            gasEth:'0.00007',
            apply: async ()=>{
              lsSet(K.proTier, tier);
              if (tier === 'lifetime') {
                setInt(K.proExp, 0);
              } else {
                setInt(K.proExp, now() + 30*24*3600*1000);
              }
              try{
                await serverProfilePatch({ proTier: tier, proExp: String(getInt(K.proExp,0)) });
              } catch {}
            }
          });
        }
      });
    }
    btnProMini.addEventListener('click', ()=>proTx('mini'));
    btnProPrime.addEventListener('click', ()=>proTx('prime'));
    btnProLife.addEventListener('click', ()=>proTx('lifetime'));


    // ----- Rewards actions -----
    if (btnClaimPayout) btnClaimPayout.addEventListener('click', ()=>{
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;
      const amt = rec ? Number(rec.totalUsd || 0) : 0;

      if (!SESSION.authenticated) return toast('Connect wallet', 'Required to claim.');
      if (!SESSION.pohVerified) return toast('PoH required', 'Verify Proof of Humanity to claim payouts.');
      if (!rec || amt <= 0) return toast('No claimable rewards', 'Play more to earn rewards.');
      if (claimed) return toast('Already claimed', 'This epoch is already claimed.');

      openTxConfirm({
        title: 'Claim mUSD payout',
        desc: `Claim ${amt.toFixed(2)} mUSD from the last settled epoch. (User pays gas)`,
        gasEth: '0.00006',
        preview: `Writes: epoch claim (${rec.ymd || ''}) · Server records claim + audit.`,
        onConfirm: ()=>{
          simulateTx({
            kind:'claim',
            label:`Claim ${amt.toFixed(2)} mUSD`,
            gasEth:'0.00006',
            apply: async ()=>{
              try{
                await serverEpochClaim(rec.ymd || '');
                await refreshEpochStatus(true);
                await refreshLedger();
              } catch(e){
                toast('Claim failed', (e&&e.message)?String(e.message):'server error');
              }
            }
          });
        }
      });
    });

    if (btnMintBadge) btnMintBadge.addEventListener('click', ()=>{
      if (!SESSION.authenticated) return toast('Connect wallet', 'Required to mint.');
      openTxConfirm({
        title: 'Mint daily badge',
        desc: 'Mint a daily badge. Grants small XP + promo AC. (User pays gas)',
        gasEth: '0.00005',
        preview: `Writes: daily badge minted · Grants: +3 XP, +2 promo AC (${currentGameId}).`,
        onConfirm: ()=>{
          simulateTx({
            kind:'badge',
            label:'Mint daily badge',
            gasEth:'0.00005',
            apply: async ()=>{
              try{
                await serverMintBadge(currentGameId);
                await refreshEpochStatus(true);
                await refreshLedger();
              } catch(e){
                toast('Mint failed', (e&&e.message)?String(e.message):'server error');
              }
            }
          });
        }
      });
    });



    function renderExpoCountdown() {
      const ms = ECON.EXPO_END_UTC - now();
      expoLeft.textContent = fmtCountdown(ms);
    }

    // ----- Avatar -----
    const avBg = document.getElementById('avBg');
    const avAcc = document.getElementById('avAcc');
    const avEyes = document.getElementById('avEyes');
    const avMouth = document.getElementById('avMouth');
    const btnAvRandom = document.getElementById('btnAvRandom');
    const btnAvSave = document.getElementById('btnAvSave');
    const avatarSvgHost = document.getElementById('avatarSvgHost');
    const avatarEdits = document.getElementById('avatarEdits');
    const avatarProReq = document.getElementById('avatarProReq');
    const avatarLast = document.getElementById('avatarLast');
    const avatarLvl = document.getElementById('avatarLvl');
    const avatarCard = document.getElementById('avatarCard');

    const BG = {
      nebula: ['#050b1a','#0ea5e9','#22d3ee'],
      void: ['#000000','#111827','#334155'],
      aurora: ['#03151a','#22c55e','#22d3ee'],
      mars: ['#120608','#f97316','#ffdd55']
    };

    function getAvatarDNA() {
      try {
        const d = JSON.parse(lsGet(K.avatar) || 'null');
        if (d && typeof d === 'object') return d;
      } catch {}
      return { bg:'nebula', acc:'antenna', eyes:'dots', mouth:'smile' };
    }
    function setAvatarDNA(d) { lsSet(K.avatar, JSON.stringify(d)); }

    function svgRect(x,y,w,h,fill) {
      return `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${fill}"/>`;
    }
    function renderAvatarSvg(dna) {
      const size = 16;
      const [bg0,bg1,bg2] = BG[dna.bg] || BG.nebula;

      const skin = 'rgba(229,231,235,0.92)';
      const outline = 'rgba(0,0,0,0.55)';
      const accent = getComputedStyle(document.body).getPropertyValue('--accent').trim() || '#22d3ee';

      const head = [
        [4,4,8,8], // main
        [5,3,6,1],
        [5,12,6,1]
      ];

      let rects = '';
      rects += svgRect(0,0,size,size,bg0);
      rects += svgRect(0,0,size,6,bg1);
      rects += svgRect(0,6,size,10,bg0);
      rects += svgRect(0,10,size,6,bg2);

      head.forEach(([x,y,w,h])=>{ rects += svgRect(x,y,w,h,skin); });
      rects += svgRect(4,4,8,1,outline);
      rects += svgRect(4,11,8,1,outline);
      rects += svgRect(4,4,1,8,outline);
      rects += svgRect(11,4,1,8,outline);

      if (dna.eyes === 'dots') {
        rects += svgRect(6,7,1,1,'#0b1220');
        rects += svgRect(9,7,1,1,'#0b1220');
      } else if (dna.eyes === 'angry') {
        rects += svgRect(6,7,2,1,'#0b1220');
        rects += svgRect(8,6,1,1,'#0b1220');
        rects += svgRect(9,7,2,1,'#0b1220');
        rects += svgRect(9,6,1,1,'#0b1220');
      } else {
        rects += svgRect(6,7,1,1,accent);
        rects += svgRect(9,7,1,1,accent);
        rects += svgRect(5,6,1,1,'rgba(34,211,238,0.25)');
        rects += svgRect(10,6,1,1,'rgba(34,211,238,0.25)');
      }

      if (dna.mouth === 'smile') {
        rects += svgRect(7,9,2,1,'#0b1220');
        rects += svgRect(6,8,1,1,'#0b1220');
        rects += svgRect(9,8,1,1,'#0b1220');
      } else if (dna.mouth === 'flat') {
        rects += svgRect(6,9,4,1,'#0b1220');
      } else {
        rects += svgRect(6,9,4,1,'#0b1220');
        rects += svgRect(6,10,1,1,'#0b1220');
        rects += svgRect(9,10,1,1,'#0b1220');
      }

      if (dna.acc === 'antenna') {
        rects += svgRect(8,2,1,2,accent);
        rects += svgRect(7,1,3,1,accent);
      } else if (dna.acc === 'visor') {
        rects += svgRect(5,6,6,3,'rgba(34,211,238,0.25)');
        rects += svgRect(5,6,6,1,'rgba(34,211,238,0.45)');
      } else if (dna.acc === 'cap') {
        rects += svgRect(4,3,8,2,'rgba(15,23,42,0.90)');
        rects += svgRect(5,2,6,1,'rgba(15,23,42,0.90)');
      }

      const svg = `
        <svg class="avatarSvg" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
          ${rects}
        </svg>
      `;
      return svg;
    }

    function renderAvatar() {
      const dna = getAvatarDNA();
      avatarSvgHost.innerHTML = renderAvatarSvg(dna);

      avBg.value = dna.bg;
      avAcc.value = dna.acc;
      avEyes.value = dna.eyes;
      avMouth.value = dna.mouth;

      const lvl = syncLevel();
      const last = getInt(K.avatarLast, 0);
      const edits = Math.max(0, lvl - last);

      avatarEdits.textContent = String(edits);
      avatarLast.textContent = String(last);
      avatarLvl.textContent = String(lvl);
      avatarProReq.textContent = proActive() ? 'ACTIVE' : 'NOT ACTIVE';
      avatarCard.classList.toggle('pulse', !proActive() || edits === 0);
    }

    function randomChoice(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
    btnAvRandom.addEventListener('click', ()=>{
      const dna = getAvatarDNA();
      dna.bg = randomChoice(Object.keys(BG));
      dna.acc = randomChoice(['none','antenna','visor','cap']);
      dna.eyes = randomChoice(['dots','angry','glow']);
      dna.mouth = randomChoice(['smile','flat','grin']);
      setAvatarDNA(dna);
      renderAvatar();
    });

    function saveAvatarTx() {
      if (!proActive()) {
        toast('PRO required', 'Activate PRO to unlock avatar edits.');
        return;
      }
      const lvl = syncLevel();
      const last = getInt(K.avatarLast, 0);
      const edits = Math.max(0, lvl - last);
      if (edits <= 0) {
        toast('No edits available', 'You unlock 1 avatar edit each time you level up.');
        return;
      }

      const dna = {
        bg: avBg.value,
        acc: avAcc.value,
        eyes: avEyes.value,
        mouth: avMouth.value
      };
      openTxConfirm({
        title: 'Update Avatar',
        desc: 'Update your 8-bit avatar. In the final build this writes to your soulbound NFT.' ,
        gasEth: '0.00005',
        preview: `Consumes 1 edit. Writes: ${K.avatar}, ${K.avatarLast}=${lvl}`,
        onConfirm: ()=>{
          simulateTx({
            kind:'avatar',
            label:'Update avatar',
            gasEth:'0.00005',
            apply: ()=>{
              setAvatarDNA(dna);
              setInt(K.avatarLast, lvl);
            }
          });
        }
      });
    }
    btnAvSave.addEventListener('click', saveAvatarTx);
    [avBg,avAcc,avEyes,avMouth].forEach(el => el.addEventListener('change', renderAvatar));

    // ----- Leaderboard (local, multi-game) -----
    const lbLocal = document.getElementById('lbLocal');
    const lbTitle = document.getElementById('lbTitle');
    const lbMe = document.getElementById('lbMe');

    function cutoffForPeriod(period) {
      const t = now();
      if (period === 'daily') {
        const d = new Date(t);
        return Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0,0,0);
      }
      if (period === 'weekly') return t - 7*24*3600*1000;
      return 0;
    }

    function runsFor(gameId, period) {
      const cutoff = cutoffForPeriod(period);
      const arr = getRuns(gameId);
      return (arr||[]).filter(r => Number(r.ts||0) >= cutoff);
    }

    function seedRand(seed) {
      let x = 0;
      for (let i=0;i<seed.length;i++) x = (x*31 + seed.charCodeAt(i)) >>> 0;
      return function() {
        x ^= x << 13; x >>>= 0;
        x ^= x >> 17; x >>>= 0;
        x ^= x << 5;  x >>>= 0;
        return (x >>> 0) / 4294967296;
      };
    }

    function renderLocalLB() {
      if (!lbLocal || !lbTitle) return;
      const gameId = getLbGameId();
      const period = getLbPeriod();
      const g = gameById(gameId);

      // Best-effort warm cache (async)
      try { refreshLeaderboard(gameId, period); } catch {}

      const key = String(gameId) + '|' + String(period);
      const haveLive = !!(API_STATE.online && SESSION.status === 'ok' && LB_CACHE.entries && LB_CACHE.key === key);

      // Header line
      lbTitle.textContent = `${g ? g.name : gameId} · ${period.charAt(0).toUpperCase()+period.slice(1)} · ${haveLive ? 'Global' : 'Local'}`;

      // Build entries
      let entries = [];
      const meAddr = (SESSION.address || lsGet(K.address) || '').toLowerCase();

      if (haveLive) {
        entries = (LB_CACHE.entries||[]).slice(0, 12).map((e, idx) => ({
          rank: e.rank || (idx+1),
          address: String(e.address||e.member||''),
          name: shortAddr(String(e.address||e.member||'')),
          best: Number(e.score||0),
          runs: '—',
          xp: '—',
          me: meAddr && String(e.address||e.member||'').toLowerCase() === meAddr
        }));

        // If you're not in top, append your row if known
        if (LB_CACHE.you && meAddr && !entries.some(x=>x.me)) {
          entries.push({
            rank: LB_CACHE.you.rank || '—',
            address: meAddr,
            name: shortAddr(meAddr),
            best: Number(LB_CACHE.you.score||0),
            runs: runsFor(gameId, period).length,
            xp: getInt(K.xp, 0),
            me: true
          });
        }
      } else {
        // Local fallback leaderboard (seeded)
        const myRuns = runsFor(gameId, period);
        const myBest = bestFromRuns(myRuns);
        const myXp = getInt(K.xp, 0);

        const r = seedRand((meAddr||'guest') + '|' + gameId + '|' + period);
        const bots = [];
        for (let i=0;i<9;i++) {
          const addr = '0x' + Math.floor(r()*0xffffffffffffff).toString(16).padStart(14,'0') + Math.floor(r()*0xffff).toString(16).padStart(4,'0');
          const bBest = Math.max(0, Math.floor(myBest * (0.65 + r()*0.7) + r()*12));
          bots.push({
            address: addr,
            name: shortAddr(addr),
            best: bBest,
            runs: Math.floor(r()*18),
            xp: Math.floor(10 + Math.log10(bBest+1)*40 + r()*200),
            me: false
          });
        }

        entries = [{ address: meAddr||'guest', name: meAddr?shortAddr(meAddr):'Guest', best: myBest, runs: myRuns.length, xp: myXp, me: true }].concat(bots);
        entries.sort((a,b)=>b.best - a.best);
        entries = entries.map((e, idx)=>({ ...e, rank: idx+1 }));
      }

      // Render table
      lbLocal.innerHTML = entries.map(e=>`
        <tr class="${e.me ? 'row-me' : ''}">
          <td class="num">${e.rank}</td>
          <td><span class="addr">${escapeHtml(e.name)}</span></td>
          <td class="num">${fmtInt(e.best)}</td>
          <td class="num">${(e.runs==='—') ? '<span class="muted">—</span>' : fmtInt(e.runs)}</td>
          <td class="num">${(e.xp==='—') ? '<span class="muted">—</span>' : fmtInt(e.xp)}</td>
        </tr>
      `).join('');

      if (lbMe) lbMe.textContent = entries.find(e=>e.me)?.rank ? `Your rank: ${entries.find(e=>e.me).rank}` : 'Your rank: —';
    }



    function computeActivityPoints(gameId, period) {
      // Local preview only. Server is authoritative (paid-only activity = AC spent on paid runs).
      const paidSpent = getInt(K.paidSpent, 0);
      const paidRuns = runsFor(gameId, period).filter(x => x.runType === 'paid').length;
      return Math.max(0, Math.floor((paidSpent * 1.0) + (paidRuns * 2)));
    }

    function computeSkillPoints(gameId, period) {
      const r = runsFor(gameId, period);
      const best = bestFromRuns(r);
      return Math.max(0, Math.floor(best / 25));
    }

    function renderPayoutPreview() {
      const period = String(lsGet(K.lbPeriod) || 'daily');
      const gameId = clampGameId(String(lsGet(K.lbGame) || currentGameId));

      const sp = computeSkillPoints(gameId, period);
      const ap = computeActivityPoints(gameId, period);
      const pb = proActive() ? Math.floor(ap * 0.15) : 0;

      if (lbSkillPts) lbSkillPts.textContent = String(sp);
      if (lbActPts) lbActPts.textContent = String(ap);
      if (lbProBoost) lbProBoost.textContent = String(pb);
      // Lottery tickets (today): prefer server-derived tickets (paid-only activity), fallback to local estimate.
      const serverTickets = (EPOCH_CACHE && EPOCH_CACHE.data && Number.isFinite(EPOCH_CACHE.data.todayTickets)) ? Number(EPOCH_CACHE.data.todayTickets) : null;
      const tickets = (serverTickets != null) ? Math.max(0, Math.floor(serverTickets)) : Math.max(0, Math.floor(Math.sqrt(Math.max(0, ap))));
      if (lbTickets) lbTickets.textContent = String(tickets);


      const estNext = (sp*0.002) + (ap*0.0012) + (pb*0.0008);
      if (lbNextEst) lbNextEst.textContent = estNext.toFixed(2) + ' mUSD';

      // Prefer server-settled claimable rewards (last settled epoch)
      const claim = EPOCH_CACHE && EPOCH_CACHE.data && EPOCH_CACHE.data.claimable ? EPOCH_CACHE.data.claimable : null;
      const rec = claim && claim.record ? claim.record : null;
      const claimed = claim ? !!claim.claimed : false;

      if (rec && lbClaim) {
        const amt = Number(rec.totalUsd || 0);
        const lotUsd = Math.max(0, Number(rec.lotteryCents || 0) / 100);
        if (lbLottery) lbLottery.innerHTML = lotUsd.toFixed(2) + ' mUSD <small>(' + (lotUsd > 0 ? 'won' : 'settled') + ')</small>';

        lbClaim.innerHTML = amt.toFixed(2) + ' mUSD <small>(' + (claimed ? 'claimed' : 'ready') + ')</small>';
        if (btnClaimPayout) {
          btnClaimPayout.disabled = claimed || amt <= 0 || !SESSION.authenticated || !SESSION.pohVerified;
          btnClaimPayout.classList.toggle('pulse', (!btnClaimPayout.disabled && amt > 0));
        }

        // Last lottery winners (yesterday’s settled epoch)
        const w = (EPOCH_CACHE && EPOCH_CACHE.data && Array.isArray(EPOCH_CACHE.data.lastLotteryWinners)) ? EPOCH_CACHE.data.lastLotteryWinners : [];
        if (lbWinners) {
          if (!w.length) {
            lbWinners.innerHTML = '<div class="mini muted">No winners yet.</div>';
          } else {
            lbWinners.innerHTML = w.slice(0, 8).map((x, i) => `
              <div class="txItem winner">
                <div class="l">#${i + 1}</div>
                <div class="m">${escapeHtml(shortAddr(x.address || ''))}</div>
                <div class="r"><span class="pill" style="background:rgba(255,221,85,.12);border-color:rgba(255,221,85,.18)">${Number(x.prizeUsd || 0).toFixed(2)} mUSD</span></div>
              </div>
            `).join('');
          }
        }
      } else {
        if (lbClaim) lbClaim.innerHTML = '0.00 mUSD <small>(settled)</small>';
        if (lbLottery) lbLottery.innerHTML = '0.00 mUSD <small>(settled)</small>';
        if (lbWinners) lbWinners.innerHTML = '<div class="mini muted">No winners yet.</div>';
        if (btnClaimPayout) btnClaimPayout.disabled = true;
      }
    }

    // Period tab clicks
    const lbTabs = Array.from(document.querySelectorAll('#view-leaderboard .tabs .tab'));
    lbTabs.forEach(t => t.addEventListener('click', ()=>{
      lsSet(K.lbPeriod, t.dataset.period || 'daily');
      renderAll();
    }));

    // ----- Proposals -----
    const propCat = document.getElementById('propCat');
    const propTitle = document.getElementById('propTitle');
    const propDesc = document.getElementById('propDesc');
    const btnSubmitProp = document.getElementById('btnSubmitProp');
    const propList = document.getElementById('propList');
    const btnBugTx = document.getElementById('btnBugTx');
    const btnReplayTx = document.getElementById('btnReplayTx');

    function getProposals() {
      try {
        const arr = JSON.parse(lsGet(K.proposals) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }
    function setProposals(arr) { lsSet(K.proposals, JSON.stringify(arr.slice(0,60))); }

    function renderProposals() {
      // Best-effort load from server (Redis). Local fallback stays available.
      try { refreshProposals(); } catch {}

      const canSupport = getBool(K.connected) && getBool(K.poh);

      const arrRaw = (PROP_CACHE.list && PROP_CACHE.list.length) ? PROP_CACHE.list : getProposals();
      const arr = (arrRaw||[]).map(x => ({
        id: x.id || ('p_' + Math.random().toString(16).slice(2)),
        kind: x.kind || 'feature',
        title: x.title || 'Untitled',
        desc: (x.detail || x.desc || '').trim(),
        ts: x.ts || new Date().toISOString(),
        address: x.address || '',
        status: x.status || 'submitted',
        supporters: Number(x.supporters||0),
        rewardAC: Number(x.rewardAC||50),
        claimed: !!x.claimed,
        supportedByYou: !!x.supportedByYou
      }));

      if (!arr.length) {
        propList.innerHTML = `<div class="card"><div class="muted">No proposals yet.</div>${PROP_CACHE.err?`<div class="mini muted" style="margin-top:8px">Server: ${escapeHtml(PROP_CACHE.err)}</div>`:''}</div>`;
        return;
      }

      propList.innerHTML = arr.map(p => `
        <div class="card" style="margin-bottom:10px">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px">
            <div>
              <div class="mini muted">${escapeHtml(p.kind.toUpperCase())} · <span class="addr">${escapeHtml(shortAddr(p.address||'anon'))}</span> · ${escapeHtml(new Date(p.ts).toLocaleString())}</div>
              <div style="font-weight:800;margin-top:4px">${escapeHtml(p.title)}</div>
            </div>
            <div class="pill" style="background:rgba(255,255,255,.08)">${escapeHtml(p.status)}</div>
          </div>
          <div class="mini" style="margin-top:8px">${escapeHtml(p.desc||'')}</div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
            <div class="mini muted">Supporters: ${fmtInt(p.supporters)} · Reward: ${fmtInt(p.rewardAC)} AC</div>
            <div style="display:flex;gap:8px">
              <button class="btn primary" data-act="support" data-id="${escapeHtml(p.id)}" ${(!canSupport || p.supportedByYou) ? "disabled" : ""}>${p.supportedByYou ? "Supported ✓" : "Support (Tx)"}</button>
              <button class="btn" data-act="claim" data-id="${escapeHtml(p.id)}" disabled>Claim (soon)</button>
            </div>
          </div>
        </div>
      `).join('');

      // Wire handlers (server now records supports; claiming rewards stays disabled until admin acceptance is implemented).
      Array.from(propList.querySelectorAll('button[data-act]')).forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-id');
          const act = btn.getAttribute('data-act');
          if (act === 'support') supportProposalTx(id);
          if (act === 'claim') claimProposalTx(id);
        });
      });
    }



    function submitProposalTx() {
      const title = String(propTitle.value||'').trim();
      const desc = String(propDesc.value||'').trim();
      const cat = String(propCat.value||'feature');
      if (title.length < 6 || desc.length < 10) {
        toast('More detail needed', 'Add a longer title and description.');
        return;
      }
      openTxConfirm({
        title:'Submit proposal',
        desc:'Submit an idea. If accepted, you earn AC. This is gas-paid to prevent spam.',
        gasEth:'0.00005',
        preview:'Writes a proposal hash on-chain (final build). For now: server ledger + Redis.',
        onConfirm: ()=>{
          simulateTx({
            kind:'proposal',
            label:'Submit proposal (Tx)',
            gasEth:'0.00005',
            apply: async ()=>{
              // Prefer server (Redis); fallback to local if offline.
              try {
                const data = await apiJson('/api/proposals/submit', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ kind:cat, title, detail:desc })
                });
                API_STATE.online = true;
                API_STATE.lastOk = now();
                API_STATE.lastErr = '';
                propTitle.value='';
                propDesc.value='';
                PROP_CACHE.ts = 0;
                await refreshProposals();
                toast('Proposal submitted', 'It is now visible in the public list.');
              } catch (e) {
                API_STATE.online = false;
                API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
                // local fallback
                const arr = getProposals();
                const p = {
                  id: 'p_' + Math.random().toString(16).slice(2),
                  kind: cat,
                  title,
                  desc,
                  status: 'submitted',
                  supporters: 0,
                  claimed: false,
                  createdAt: now()
                };
                arr.unshift(p);
                setProposals(arr);
                propTitle.value='';
                propDesc.value='';
                toast('Saved locally', 'Server offline — will sync when available.');
              }
              renderProposals();
            }
          });
        }
      });
    }
    btnSubmitProp.addEventListener('click', submitProposalTx);

    function supportProposalTx(id) {
      if (!id) return;
      if (!getBool(K.connected)) {
        toast('Connect first', 'You need to connect (and pass the gate) to support proposals.');
        return;
      }
      openTxConfirm({
        title:'Support proposal',
        desc:'Signal demand for this idea. Gas-paid to prevent vote spam. Supporters may earn AC if it ships.',
        gasEth:'0.00003',
        preview:'Adds your address to the support set (final build = onchain vote).',
        onConfirm: ()=>{
          simulateTx({
            kind:'support',
            label:'Support proposal (Tx)',
            gasEth:'0.00003',
            apply: async ()=>{
              try {
                const r = await apiJson('/api/proposals/support', {
                  method:'POST',
                  headers:{'Content-Type':'application/json'},
                  body: JSON.stringify({ id })
                });
                API_STATE.online = true;
                API_STATE.lastOk = now();
                API_STATE.lastErr = '';
                if (r && r.alreadySupported) {
                  toast('Already supported', 'You have already supported this proposal.');
                } else {
                  toast('Support recorded', 'Thanks — this increases priority.');
                }
                PROP_CACHE.ts = 0;
                await refreshProposals();
              } catch (e) {
                API_STATE.online = false;
                API_STATE.lastErr = (e && e.message) ? String(e.message) : 'offline';
                // local fallback (best effort)
                const arr = getProposals();
                const p = arr.find(x => x.id === id);
                if (p) p.supporters = Number(p.supporters||0) + 1;
                setProposals(arr);
                toast('Saved locally', 'Server offline — your support will sync later.');
              }
              renderProposals();
            }
          });
        }
      });
    }

    function claimProposalTx(id) {
      toast('Not available yet', 'Claiming proposal rewards will be enabled after admin acceptance + payout ledger.');
    }



    function bountyTx(kind, rewardAC) {
      openTxConfirm({
        title:'Submit bounty',
        desc:'Submit this bounty. If accepted, you earn AC.',
        gasEth:'0.00005',
        preview:`If accepted: +${rewardAC} AC`,
        onConfirm: ()=>{
          simulateTx({
            kind,
            label:'Submit bounty',
            gasEth:'0.00005',
            apply: ()=>{}
          });
        }
      });
    }
    btnBugTx.addEventListener('click', ()=>bountyTx('bug', 300));
    btnReplayTx.addEventListener('click', ()=>bountyTx('replay', 200));

    // ----- TX Feed rendering -----
    const txFeed = document.getElementById('txFeed');
    function renderTxFeed() {
      const arr = getTxLog().slice(0,6);
      if (!arr.length) {
        txFeed.innerHTML = '<div class="muted">No transactions yet. Claim promo, buy AC, or submit a proposal.</div>';
        return;
      }
      txFeed.innerHTML = '';
      arr.forEach(tx => {
        const el = document.createElement('div');
        el.className = 'txItem';
        const tag = (tx.status === 'confirmed') ? '<span class="txTag ok">confirmed</span>' : '<span class="txTag pend">pending</span>';
        const time = new Date(tx.ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        el.innerHTML = `
          <div>
            <div class="l">${tx.label}</div>
            <div class="s">${tx.kind} · ${tag}</div>
          </div>
          <div class="r">
            <div>${time}</div>
            <div class="mono">${tx.gasEth} ETH</div>
          </div>
        `;
        txFeed.appendChild(el);
      });
    }

    // ----- Sync stats -----
    const statPaid = document.getElementById('statPaid');
    const statPromoLabel = document.getElementById('statPromoLabel');
    const statPromo = document.getElementById('statPromo');
    const statXP = document.getElementById('statXP');
    const statPRO = document.getElementById('statPRO');
    const statBest = document.getElementById('statBest');
    const statTx24 = document.getElementById('statTx24');
    const pillRunMode = document.getElementById('pillRunMode');

    function tx24hCount() {
      const cutoff = now() - 24*3600*1000;
      return getTxLog().filter(tx => tx.ts >= cutoff).length;
    }

    function getRuns(gameId) {
      try {
        const arr = JSON.parse(lsGet(K.runs(gameId)) || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch { return []; }
    }

    function setRuns(gameId, arr) {
      try { lsSet(K.runs(gameId), JSON.stringify((arr||[]).slice(0,200))); } catch {}
    }

    function bestFromRuns(runs) {
      return (runs||[]).reduce((m,r)=>Math.max(m, Number(r.score||0)), 0);
    }

    function bestByGame() {
      const out = {};
      (GAMES||[]).forEach(g => {
        const b = getInt(K.best(g.id), 0);
        out[g.id] = b;
      });
      return out;
    }

    function renderStats() {
      const paid = getInt(K.paid, 0);
      const promo = getInt(K.promoBal(currentGameId), 0);
      const xp = getInt(K.xp, 0);
      const lvl = syncLevel();
      const best = getInt(K.best(currentGameId), 0);

      statPaid.textContent = String(paid);
      statPromo.textContent = String(promo);
      statPromoLabel.textContent = `Promo AC (${(currentGame && currentGame.name) ? currentGame.name : currentGameId})`;
      statXP.textContent = `${xp} XP · L${lvl}`;
      statPRO.textContent = proLabel();
      statBest.textContent = String(best);
      statTx24.textContent = String(tx24hCount());
    }

    // ----- ArcadeBridge (iframe comms) -----
    const activeRun = { runId:'', gameId:'', runType:'', startedAt:0, costAC:0 };

    function sendToGame(type, payload) {
      try { gameFrame?.contentWindow?.postMessage(Object.assign({ type }, payload||{}), '*'); } catch {}
    }

    function syncToGame() {
      const g = currentGame;
      if (!g) return;
      sendToGame('ARCADE:SYNC', {
        game: {
          id: g.id,
          runCostAC: Number(g.runCostAC||0),
          promoRuns: Number(g.promoRuns||0),
          promoGrantAC: Number(g.promoGrantAC||0),
          promoClaimed: getBool(K.promoClaimed(g.id)),
          promoAC: getInt(K.promoBal(g.id), 0)
        },
        player: {
          address: lsGet(K.address) || '',
          paidAC: getInt(K.paid, 0),
          xp: getInt(K.xp, 0),
          level: getInt(K.level, 1),
          pro: proLabel(),
          bestByGame: bestByGame()
        }
      });
    }

    function addOffchain(label) {
      addTx({
        id: 'off_' + Math.random().toString(16).slice(2),
        kind: 'offchain',
        label,
        gasEth: '0.00000',
        status: 'confirmed',
        ts: now()
      });
    }

    async function grantRun(gameId) {
      const g = gameById(gameId);
      if (!g) return;

      if (activeRun.runId) { toast('Finish the current run first.'); return; }

      // Prefer server-authoritative run start (deducts promo/paid AC in Redis).
      try {
        const r = await serverRunStart(gameId);
        if (r && r.runId) {
          activeRun.runId = r.runId;
          activeRun.gameId = gameId;
          activeRun.runType = r.runType || 'free';
          activeRun.startedAt = r.startedAt || new Date().toISOString();
          activeRun.costAC = Number(r.costAC||0);

          if (r.paidAC != null) setInt(K.paid, r.paidAC);
          if (r.promoAC != null) setInt(K.promoBal(gameId), r.promoAC);

          addFeed(`Run started: ${g.name} (${activeRun.runType}) · -${activeRun.costAC} AC`);
          renderTopChips(); syncToGame();

          sendToGame('ARCADE:RUN_GRANTED', {
            gameId,
            runId: activeRun.runId,
            runType: activeRun.runType,
            costAC: activeRun.costAC,
            promoAC: getInt(K.promoBal(gameId),0),
            paidAC: getInt(K.paid,0)
          });
          return;
        }
      } catch (e) {
        // fall through to offline/local flow
      }

      // Offline/local fallback (keeps play working if APIs are unavailable).
      const cost = Number(g.runCostAC||0);
      const promoBal = getInt(K.promoBal(gameId), 0);
      let runType = 'free';

      if (cost > 0) {
        if (promoBal >= cost) {
          runType = 'promo';
          setInt(K.promoBal(gameId), promoBal - cost);
        } else {
          const paid = getInt(K.paid, 0);
          if (paid < cost) {
            toast('Not enough AC', 'Buy more AC or claim promo if available.');
            return;
          }
          runType = 'paid';
          setInt(K.paid, paid - cost);
          setInt(K.paidSpent, getInt(K.paidSpent,0) + cost);
        }
      }

      const runId = 'run_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(36);
      activeRun.runId = runId;
      activeRun.gameId = gameId;
      activeRun.runType = runType;
      activeRun.startedAt = new Date().toISOString();
      activeRun.costAC = cost;

      addFeed(`Run started (offline): ${g.name} (${runType}) · -${cost} AC`);
      renderTopChips(); syncToGame();

      sendToGame('ARCADE:RUN_GRANTED', {
        gameId,
        runId,
        runType,
        costAC: cost,
        promoAC: getInt(K.promoBal(gameId),0),
        paidAC: getInt(K.paid,0)
      });
    }

async function recordRunResult(gameId, runId, score, durationMs) {
      const g = gameById(gameId);
      if (!g) return;

      const s = Math.max(0, Math.floor(Number(score||0)));
      const dur = Math.max(0, Math.floor(Number(durationMs||0)));

      let xpEarned = 0;
      let bestLocal = Math.max(getInt(K.best(gameId),0), s);

      // Prefer server-authoritative submit (updates XP/level/best + Redis leaderboards).
      let usedServer = false;
      try{
        const r = await serverRunSubmit({ gameId, runId, score: s, durationMs: dur });
        if (r && r.state){
          applyServerState(r.state);
          xpEarned = Number(r.xpEarned||0);
          bestLocal = Math.max(bestLocal, Number(((r.state.best||{})[gameId])||0));
          usedServer = true;
        }
      } catch(e){
        // Offline/local fallback
        xpEarned = calcXpEarned(s, activeRun.runType || 'free');
        bestLocal = Math.max(bestLocal, s);
        setInt(K.best(gameId), bestLocal);
        setInt(K.xp, getInt(K.xp,0) + xpEarned);
        syncLevel();
      }

      // Local history (UI convenience)
      const runs = getRuns(gameId);
      runs.unshift({
        ts: new Date().toISOString(),
        runId,
        score: s,
        durationMs: dur,
        runType: activeRun.runType || 'free',
        costAC: Number(activeRun.costAC||0),
        xp: xpEarned,
        bestAfter: Math.max(getInt(K.best(gameId),0), bestLocal),
        synced: usedServer
      });
      setRuns(gameId, runs.slice(0, 20));

      addFeed(`Run complete: ${g.name} · score ${s} · +${xpEarned} XP`);
      renderAll();
      syncToGame();

      sendToGame('ARCADE:RUN_RECORDED', {
        gameId,
        runId,
        score: s,
        durationMs: dur,
        xpEarned,
        best: Math.max(getInt(K.best(gameId),0), bestLocal)
      });

      // Clear active run
      activeRun.runId = '';
      activeRun.gameId = '';
      activeRun.runType = '';
      activeRun.costAC = 0;
      activeRun.startedAt = '';
    }

    // ----- Game iframe bridge (postMessage)
    window.addEventListener('message', (ev) => {
      const data = ev && ev.data;
      if (!data || typeof data !== 'object') return;
      const type = String(data.type || '');
      const isArcade = type.startsWith('ARCADE:');
      const isLegacyScore = (type === 'SCORE_SUBMIT');
      if (!isArcade && !isLegacyScore) return;

      // Only trust messages from the active game iframe (defense-in-depth).
      try {
        if (gameFrame && gameFrame.contentWindow && ev.source !== gameFrame.contentWindow) return;
      } catch {}

      const payload = data.payload || {};

      // Compatibility: Moonshot 3D reports legacy SCORE_SUBMIT. Translate it into a run result.
      if (type === 'SCORE_SUBMIT') {
        const gid = String(payload.gameId || currentGameId || '');
        const score = Number(payload.score || 0);
        let durationMs = 0;
        try {
          const t0 = activeRun.startedAt ? Date.parse(String(activeRun.startedAt)) : NaN;
          if (Number.isFinite(t0)) durationMs = Math.max(0, Date.now() - t0);
        } catch {}

        // If we somehow got a score without a granted run, still record it as a free/offline run.
        const runId = activeRun.runId || ('run_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(36));
        recordRunResult(gid, String(runId), score, durationMs);
        return;
      }

      if (type === 'ARCADE:READY') {
        syncToGame();
        return;
      }
      if (type === 'ARCADE:REQUEST_PROMO') {
        const gid = String(payload.gameId || currentGameId || '');
        if (gid) claimPromoTx(gid);
        return;
      }
      if (type === 'ARCADE:REQUEST_RUN') {
        const gid = String(payload.gameId || currentGameId || '');
        if (gid) grantRun(gid);
        return;
      }
      if (type === 'ARCADE:RUN_RESULT') {
        const gid = String(payload.gameId || currentGameId || '');
        recordRunResult(gid, String(payload.runId||''), Number(payload.score||0), Number(payload.durationMs||0));
        return;
      }
    });



    function clearPulse() {
      document.querySelectorAll('.pulse').forEach(el=>{
        if (el.id === 'avatarCard') return;
        el.classList.remove('pulse');
      });
    }
    function applyPulse(id) {
      clearPulse();
      const el = document.getElementById(id);
      if (el) el.classList.add('pulse');
    }

    function renderTutorial() {
      const s = steps[tutIdx];
      tutTitle.textContent = s.title;
      tutBody.textContent = s.body;
      tutHint.textContent = s.hint;
      tutProg.textContent = (tutIdx+1) + ' / ' + steps.length;
      btnTutBack.disabled = tutIdx === 0;
      btnTutNext.textContent = (tutIdx === steps.length-1) ? 'Finish' : 'Next';
      btnTutAction.textContent = s.actionText || 'Do it now';

      setView(s.view);
      if (s.pulseId) applyPulse(s.pulseId); else clearPulse();
    }

    function startTutorial() {
      tutorial.classList.add('show');
      tutIdx = 0;
      renderTutorial();
    }
    function endTutorial() {
      tutorial.classList.remove('show');
      clearPulse();
      setBool(K.tutDone, true);
    }
    btnTutorial.addEventListener('click', startTutorial);
    btnTutSkip.addEventListener('click', endTutorial);
    btnTutBack.addEventListener('click', ()=>{ tutIdx = Math.max(0, tutIdx-1); renderTutorial(); });
    btnTutNext.addEventListener('click', ()=>{
      if (tutIdx >= steps.length-1) { endTutorial(); return; }
      tutIdx += 1; renderTutorial();
    });
    btnTutAction.addEventListener('click', ()=>{
      const s = steps[tutIdx];
      try { s.action && s.action(); } catch {}
    });

    // ----- Settings -----
    const btnToggleGrain = document.getElementById('btnToggleGrain');
    const btnResetTutorial = document.getElementById('btnResetTutorial');
    const btnResetAll = document.getElementById('btnResetAll');
    const btnExport = document.getElementById('btnExport');
    const dump = document.getElementById('dump');
    const btnOpenDeck = document.getElementById('btnOpenDeck');

    const embedModal = document.getElementById('embedModal');
    const embedTitle = document.getElementById('embedTitle');
    const embedFrame = document.getElementById('embedFrame');
    const btnEmbedClose = document.getElementById('btnEmbedClose');

    btnToggleGrain.addEventListener('click', ()=>{
      document.body.dataset.grain = (document.body.dataset.grain === '1') ? '0' : '1';
      toast('FX updated', 'Grain toggled.');
    });
    btnResetTutorial.addEventListener('click', ()=>{
      setBool(K.tutDone, false);
      toast('Tutorial reset', 'Open Tutorial to run it again.');
    });
    btnExport.addEventListener('click', ()=>{
      const state = exportState();
      navigator.clipboard?.writeText(JSON.stringify(state, null, 2));
      dump.textContent = JSON.stringify(state, null, 2);
      toast('Exported', 'State copied to clipboard (if allowed).');
    });
    btnResetAll.addEventListener('click', ()=>{
      openTxConfirm({
        title:'Reset everything',
        desc:'Clears local state. (No chain)',
        gasEth:'0.00000',
        preview:'Clears localStorage keys under arcade.*',
        onConfirm: ()=>{
          for (const k of Object.keys(localStorage)) {
            if (k.startsWith('arcade.')) localStorage.removeItem(k);
          }
          location.reload();
        }
      });
    });

    function openEmbed(title, url) {
      if (!embedModal) return;
      embedTitle.textContent = title || 'Embed';
      embedFrame.src = url || 'about:blank';
      embedModal.classList.add('show');
    }
    function closeEmbed() {
      if (!embedModal) return;
      embedModal.classList.remove('show');
      embedFrame.src = 'about:blank';
    }
    btnEmbedClose?.addEventListener('click', closeEmbed);
    window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeEmbed(); });

    btnOpenDeck?.addEventListener('click', ()=>{
      const isLocal = /^(localhost|127\.0\.0\.1)$/i.test(location.hostname);
      const deckAbs = location.origin + '/deck/deck.pptx';
      if (isLocal) {
        openEmbed('Pitch deck', '/deck/deck.pptx');
        toast('Deck (local)', 'Browser may download instead of previewing.');
        return;
      }
      const viewer = 'https://view.officeapps.live.com/op/embed.aspx?src=' + encodeURIComponent(deckAbs);
      openEmbed('Pitch deck', viewer);
    });

    function exportState() {
      const out = {};
      for (const k of Object.keys(localStorage)) {
        if (k.startsWith('arcade.')) out[k] = localStorage.getItem(k);
      }
      return out;
    }

    // ----- Global render loop -----
    function renderAll() {
      renderTopChips();
      renderSplitBars();
      renderStats();
      renderTxFeed();
      renderLocalLB();
      renderPayoutPreview();
      renderProposals();
      renderAvatar();
      renderExpoCountdown();
      dump.textContent = JSON.stringify(exportState(), null, 2);
      setPlayCopy();
      syncToGame();
    }

    // Init
    (async function init() {
      const route = getRouteIntent();
      await loadCatalog();
      renderGameTiles();
      populateLbSelect();

      // Restore selected game
      const saved = lsGet(K.selectedGame) || currentGameId;
      selectGame(saved);

      // Default LB selections
      if (!lsGet(K.lbPeriod)) lsSet(K.lbPeriod, 'daily');
      if (!lsGet(K.lbGame)) lsSet(K.lbGame, currentGameId);

      setView(route.view || 'play');
      recalcBuyOutputs();
      renderAll();

      if (route && route.scrollId) {
        try {
          const el = document.getElementById(route.scrollId);
          if (el) setTimeout(() => { try { el.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {} }, 50);
        } catch {}
      }
      // Primary gate is the starfield iframe overlay (runs every refresh).
      // Keep the in-dashboard gate as a fallback only.

      updateUiCaps();
      restartTimers();
    })();


    // timers (adaptive)
    window.addEventListener('visibilitychange', ()=>{
      try { renderNetBanner(); } catch {}
      restartTimers();
    });
    window.addEventListener('resize', ()=>{
      updateUiCaps();
      restartTimers();
    }, { passive:true });
  </script>
</body>
</html>
